
# ---------- 计网

# 基础概念

## OSI 七层模型？每一层的作用是什么？

OSI 七层模型 是国际标准化组织提出的一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：

![500](../求职/assets/Pasted%20image%2020240408180031.png)

> 物链网输会示用

每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能

> 比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去

![600](../求职/assets/Pasted%20image%2020240408175847.png)

## TCP/IP 四层模型是什么？每一层的作用是什么？

TCP/IP 四层模型 是目前被广泛采用的一种模型，由以下 4 层组成：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层

> 我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来

![600](../求职/assets/Pasted%20image%2020240408180654.png)

### 为什么网络要分层？

#TODO

## 常见网络协议

#TODO完善

应用层：

- *HTTP*（Hypertext Transfer Protocol，超文本传输协议）：基于 **TCP** 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。
- *FTP*（File Transfer Protocol，文件传输协议） : 基于 **TCP** 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。
  - 注意：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP
- *SSH*（Secure Shell Protocol，安全的网络传输协议）：基于 **TCP** 协议，通过加密和认证机制实现安全的访问和文件传输等业务
- *DNS*（Domain Name System，域名管理系统）: 基于 **UDP** 协议，用于解决域名和 IP 地址的映射问题

传输层

- *TCP*（Transmission Control Protocol，传输控制协议 ）：提供 **面向连接** 的，**可靠** 的数据传输服务。
- *UDP*（User Datagram Protocol，用户数据协议）：提供 **无连接** 的，**尽最大努力** 的数据传输服务（不保证数据传输的可靠性），简单高效

网络层


# TCP

## TCP 和 UDP 的区别 #面试2 #笔试

|             | TCP                 | UDP                 |
| ----------- | ------------------- | ------------------- |
| 是否面向连接      | 是，需要三次握手四次挥手        | 否                   |
| 可靠性         | 是，通过确认和重传机制确保数据正确送达 | 不可靠                 |
| 传输效率        | 比UDP慢               | 比TCP快               |
| 传输形式        | 字节流                 | 报文                  |
| 首部开销        | 20 ～ 60 bytes       | 8 bytes             |
| 是否提供广播或多播服务 | 否，只支持点对点通信          | 是，支持一对一、一对多、多对一、多对多 |
| 应用场景        | web浏览器、文件传输、邮件      | 网络游戏，视频流，语音通话等      |


## TCP 三次握手和四次挥手

> - [卧槽！牛皮了，头一次见有大佬把TCP/IP三次握手四次挥手解释的这么明白 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/141396896)
> - [✅什么是TCP三次握手、四次挥手？](https://www.yuque.com/hollis666/krcpbs/gbsihwp8q22wc3cn)

![500](../assets/Pasted%20image%2020241108141118.png)

三次握手：
- 第一次：
	- client 向 server 发送同步信号 SYN，seq=x。
	- client 置为 **SYN_SENT** 状态
- 第二次：
	- server 收到 SYN，此时 server 知晓 client 发送能力正常，server 接收能力正常。server 向 client 发送 同步+确认信号 SYN+ACK，ack = x + 1, seq = y。
	- server 置为 **SYN_RCVD** 状态
- 第三次：
	- client 收到 SYN+ACK，此时 client 知晓 client 和 server 收发能力都正常。client 向 server 发送 ACK，ack = y + 1， seq = x + 1。
	- client 置为 **ESTABLISHED** 状态
	- server 收到 ACK 后也进入 **ESTABLISHED** 状态

![500](../assets/Pasted%20image%2020241108142342.png)

四次挥手：
- 第一次：
	- client 向 server 发送 FIN。
	- client 置为 **FIN_WAIT_1**
- 第二次
	- server 收到 FIN，server 向 client 发送 ACK。
	- server 进入 **CLOSE_WAIT**
	- client 收到 ACK，置为 **FIN_WAIT_2**，等待 server 传输数据完毕
- 第三次
	- server 传输数据完毕后，向 client 发送 FIN。
	- server 置为 **LAST_ACK**
- 第四次：
	- client 向 server 发送 ack。
	- client 置为 **TIME_WAIT**。
	- 之后等待 2MSL，client 进入 **CLOSED**。
	- server 接收到后置为 **CLOSED**

> 其中等待2倍的最大报文段生存时间（2MSL，Maximum Segment Lifetime）是为了确保在网络中的所有剩余数据报文段都被丢弃，以防止旧的数据报文段在之后的连接中引发混淆或冲突。

## 粘包与拆包 #面过

> - [应用层的拆包和粘包 - 知乎](https://zhuanlan.zhihu.com/p/77275039)
> - [✅什么是TCP的粘包、拆包问题？](https://www.yuque.com/hollis666/krcpbs/qotkxkmmhwo0i5os)
> - [聊聊TCP协议的粘包、拆包以及http是如何解决的？_tcp拆包粘包-CSDN博客](https://blog.csdn.net/cj_eryue/article/details/131046881)

**为什么会发生？**

TCP 传输的数据是以流的形式，而流数据是==没有明确的开始结尾边界==，所以 TCP 也没办法判断哪一段流属于一个消息

TCP 粘包和拆包问题主要是接收方接收到粘合的包，需要手动拆分

TCP 粘包和拆包问题主要出现在以下两种情况下：

1. **发送方合并**：多次间隔较小、数据量小的数据包，会合并成一个大的数据包
2. **发送方发送速度与接收方处理速度不一致**：发送方发送数据的速度过快，而接收方的处理速度较慢，可能导致多个数据包在接受方的缓冲区合并
3. **缓冲区大小限制**：接收方在接收数据时，如果接收缓存区的大小有限，可能会将一个大的数据包拆分成多个小数据包进行接收，从而导致粘包和拆包

常见的解决方案：

1. **固定数据包大小**：将业务层协议包的长度固定下来，每个包都固定长度，比如 512 个字节大小，如果客户端发送的数据长度不足 512 个字节，则通过补充空格的方式补全到指定长度；
2. **分隔符**：在每个包的末尾使用固定的分隔符，如换行符 `/n`，如果一个包被拆分了，则等待下一个包发送过来之后找到其中的 `\n`，然后对其拆分后的头部部分与前一个包的剩余部分进行合并即可；
3. **自定义协议**：仿照 TCP/IP 协议栈，将消息分为 header 和 body，在 header 中保存有当前整个消息的长度，只有在读取到足够长度的消息之后才算是读到了一个完整的消息；

## TCP 怎么保证可靠传输？

> - [✅TCP是如何保证可靠传输的？](https://www.yuque.com/hollis666/krcpbs/gqb3is)

**有序性**：应用数据被分割成 TCP 认为最适合发送的数据块。TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。

**校验和 ---> 不被篡改**： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

**ARQ 协议**： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

**超时重传**： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。


**流量控制**： TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

**拥塞控制**： TCP 使用拥塞控制算法来确保网络中不会因为过多的数据而导致拥塞。当网络拥塞时，发送端会减少发送速率，以避免进一步加重网络拥塞。常用的拥塞控制算法包括慢启动、拥塞避免和快速重传等。


## 其他 #todo 

> 讲讲TCP的拥塞控制（*）
>
> UDP的可靠设计（*）
>
> 滑动窗口（连续ARQ、停止等待ARQ（*）
>
> 发送窗口 接收窗口 拥塞窗口（*）
>
> 拥塞控制（四个[算法](https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95)、具体实现）（*）


# HTTP

## HTTP 协议

超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。

设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。通过 HTTP 或者 HTTPS 协议请求的资源由统一资源标识符（Uniform Resource Identifiers，URI）来标识。

HTTP 协议是
- 面向文本，以 ASCII 码传输
- 基于请求与响应模式的、无状态的，
- 建立在 TCP/IP 协议之上的应用层规范。
- 它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。

![](http://www.hollischuang.com/wp-content/uploads/2018/03/http.jpg)

HTTP 协议主要的版本有 3 个，分别是 HTTP/1.0、HTTP/1.1 和 HTTP/2。HTTPS 是另外一个协议，简单讲是 HTTP 的安全版。


## HTTP/1.0 和 HTTP/1.1

### 持久和非持久连接

HTTP/1.0 默认使用非持久连接，即浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成请求处理后立即断开 TCP 连接

> 每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。我们知道 TCP 连接的建立需要三次握手，是很耗费时间的一个过程。所以，HTTP/1.0 版本的性能比较差。现在，随便打开一个网页，上面都会有很多图片、视频等资源，HTTP/1.0 显然无法满足性能要求。

HTTP/1.1 默认使用持久连接，即在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。

也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。

如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持==超时时间==。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。

> 持久连接又分为非流水线和流水线方式。
> - 对于非流水线方式，客户在收到前一个响应后才能发出下一个请求。
> - HTTP/1.1默认采用流水线方式，客户每遇到一个对象引用就立即发出一个请求，因而客户可以逐个地连续发出对各个引用对象的请求。如果所有的请求和响应都是连续发送的，那么所有引用的对象共计经历1个 RTT 延迟，而不是像非流水线方式那样，每个引用都必须有1个 RTT 延迟

HTTP/1.1 延用至今


### Host 头处理

域名系统（DNS）允许==多个主机名绑定到同一个 IP 地址上==，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是 `[http://example1.org/home.html，HTTP/1.0` 的请求报文中，将会请求的是 `GET /home.html HTTP/1.0`.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。

因此，**HTTP/1.1 在请求头中加入了 Host 字段**。加入 `Host` 字段的报文头部将会是:

```
GET /home.html HTTP/1.1
Host: example1.org
```

这样，服务器端就可以确定客户端想要请求的真正的网址了


### 范围请求（带宽优化） 

HTTP/1.1 可以==在请求中加入 Range 头部==，以请求（并只能请求字节型数据）数据的一部分。

服务器端可以忽略 `Range` 头部，也可以==返回若干 Range 响应==。简单解释一下 HTTP 范围响应头部中的字段：
- `Content-Range` 头部：指示返回数据在整个资源中的位置，包括起始和结束字节以及资源的总长度。
	- 例如，`Content-Range: bytes 0-1023/146515` 表示服务器端返回了第 0 到 1023 字节的数据（共 1024 字节），而整个资源的总长度是 146,515 字节。
- `Content-Length` 头部：指示此次响应中实际传输的字节数。
	- 例如，`Content-Length: 1024` 表示服务器端传输了 1024 字节的数据。

Range 请求头不仅可以请求单个字节范围，还可以一次性请求多个范围，这种方式被称为“==多重范围请求==”（multiple range requests）

> `206 (Partial Content)` 状态码的主要作用是确保客户端和代理服务器能正确识别部分内容响应，避免将其误认为完整资源并错误地缓存。这对于正确处理范围请求和缓存管理非常重要。


### 缓存技术

缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。

HTTP/1.0 提供的缓存机制非常简单。
- 服务器端使用 Expires 标签来标志（时间）一个**响应体**，**在 Expires 标志时间内的请求**，都会获得该响应体缓存。
- 服务器端在**初次返回给客户端的响应体**中，有一个 **Last-Modified 标签**标记了**被请求资源在服务器端的最后一次修改**。
- **在请求头中**，使用 **If-Modified-Since 标签标志一个时间**，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”。
	- 通常情况下，请求头中的 If-Modified-Since 的值即为==上一次获得该资源时，响应体中的 Last-Modified 的值。==

如果服务器接收到了请求头，并判断 If-Modified-Since 时间后
- **资源确实没有修改过**，则返回给客户端一个 304 not modified 响应头，表示”缓冲可用，你从浏览器里拿吧！”。
- **资源被修改过**，则返回给客户端一个 200 OK 的响应体，并附带==全新的资源内容==，表示”你要的我已经改过的，给你一份新的”。

HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。


### 压缩（了解）

许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。

HTTP/1.1 则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。

HTTP/1.0 包含了 `Content-Encoding` 头部，对消息进行端到端编码。HTTP/1.1 加入了 `Transfer-Encoding` 头部，可以对消息进行==逐跳传输编码==。HTTP/1.1 还加入了 `Accept-Encoding` 头部，是==客户端用来指示他能处理什么样的内容编码==


## HTTP/2

### 二进制分帧

在 HTTP/2 中，在应用层（HTTP2.0）和传输层（TCP 或者 UDP）之间加了一层：二进制分帧层。这是 HTTP2 中最大的改变。HTTP2 之所以性能会比 HTTP1.1 有那么大的提高，很大程度上正是由于这一层的引入。

**也就是说，HTTP/2 使用二进制帧进行数据传输**

![](http://www.hollischuang.com/wp-content/uploads/2018/03/frame-layer.png)

在二进制分帧层中， HTTP/2 会==将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码==。

好处：
- 这种单连接多资源的方式，减少了服务端的压力，使得内存占用更少，连接吞吐量更大。
- 而且，TCP连接数的减少使得网络拥塞状况得以改善，同时慢启动时间的减少，使拥塞和丢包恢复速度更快。

### 多路复用

多路复用允许==同时通过==单一的 HTTP/2.0 连接发起多重的请求-响应消息。

- 在 HTTP1.1 协议中，浏览器客户端在同一时间，==针对同一域名下的请求有一定数量的限制==，超过了这个限制的请求就会被阻塞。

![600](http://www.hollischuang.com/wp-content/uploads/2018/03/IMG_1960.png)

HTTP2 的请求的 TCP 的 connection 一旦建立，后续请求以 stream 的方式发送。每个 stream 的基本组成单位是 frame（二进制帧）。==客户端和服务器可以把 HTTP 消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来==。

![](http://www.hollischuang.com/wp-content/uploads/2018/03/multi.png)

也就是说，HTTP2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。就好比，我请求一个页面 [http://www.hollischuang.com](http://www.hollischuang.com) 。==页面上所有的资源请求都是客户端与服务器上的一条 TCP 上请求和响应的！==

### 头部压缩

HTTP/1.1 的 header 带有大量信息，而且每次都要重复发送，不支持 header 压缩，只支持 body 压缩

HTTP/2 为了减少这部分开销，采用了 **HPACK 头部压缩算法**对 Header 进行压缩。

### 服务端推送

当客户端请求一个资源时，==服务器主动将一些其他相关资源推送给浏览器并缓存起来的机制==，从而减少了客户端的请求次数和延迟


## HTTP 想要尽可能少的数据量发送？ #秋招24

body 压缩、http2 头部压缩、http2 服务器推送、缓存


## 从输入 URL 到页面展示发生了什么？ #高频 #面过

![500](../求职/assets/Pasted%20image%2020240408234200.png)

- 在浏览器中输入指定网页的 URL。浏览器通过 **DNS** 协议，获取域名对应的 **IP 地址**。
- 浏览器根据 **IP 地址和端口号**，和目标服务器建立 **TCP** 连接
- 浏览器在 TCP 连接上，向服务器发送一个 **HTTP 请求报文**，请求获取网页的内容。
- 服务器收到 HTTP 请求报文后，处理请求，并返回 **HTTP 响应报文**给浏览器。
- 浏览器收到 HTTP 响应报文后，解析响应体中的 HTML 代码，渲染网页的结构和样式，同时根据 HTML 中的其他资源的 URL（如图片、CSS、JS 等），再次发起 HTTP 请求，获取这些资源的内容，直到网页完全加载显示。
- 浏览器在不需要和服务器通信时，可以主动关闭 TCP 连接，或者等待服务器的关闭请求。


## URL 组成部分


## HTTP 状态码 #高频

> HTTP 常见的状态码（2）
>
> 302 401 403 502 504

![600](../求职/assets/Pasted%20image%2020240408235104.png)

> 1xx 碰不到

2xx Success（**成功**状态码）

- *200 OK*（最常见）：请求被成功处理
  - 比如发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据
- *201 Created*：请求被成功处理并且在服务端创建了一个新的资源。
  - 比如通过 POST 请求创建一个新的用户
- *202 Accepted*：服务端已经接收到了请求，但是还未处理。
- *204 No Content*（少见）：服务端已经成功处理了请求，但是没有返回任何内容。

3xx Redirection（**重定向**状态码）

- *301 Moved Permanently*：资源被**永久重定向**了。
  - 比如你的网站的网址更换了。
- *302 Found*：资源被**临时重定向**了。
  - 比如你的网站的某些资源被暂时转移到另外一个网址。

4xx Client Error（**客户端错误**状态码）

- *400* Bad Request：发送的 HTTP 请求存在问题。
  - 比如请求参数不合法、请求方法错误。
- *401* Unauthorized：**未认证**却请求需要认证之后才能访问的资源。
- *403* Forbidden：直接**拒绝** HTTP 请求，不处理。一般用来针对非法请求。
- *404* Not Found：你请求的资源未在服务端找到。
  - 比如你请求某个用户的信息，服务端并没有找到指定的用户。
- *409* Conflict：表示请求的资源与服务端当前的状态存在**冲突**，请求无法被处理。

5xx Server Error（**服务端错误**状态码）

- *500* Internal Server Error：服务端出问题了（通常是服务端出 Bug 了）
  - 比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理
- *502* Bad Gateway：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应
- *504*：网关超时


## HTTP 报文结构（1）

#TODO完善

请求报文

- 请求行
  - 请求方法（GET、POST）
  - URI（资源位置）
  - HTTP 协议版本
- 请求头
- 请求体

报文主体

- 状态行
  - 协议版本
  - 状态码
  - 状态描述：状态码的补充
- 响应头
- 响应体


## HTTP Header 中常见的字段有哪些？ #秋招24 

| 字段名                   | 说明                                                                                                                                                            | 示例                                                                                     |
| :-------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------ | :------------------------------------------------------------------------------------- |
| Accept                | 能够接受的回应内容类型（Content-Types）                                                                                                                                    | Accept: application/json, text/plain                                                   |
| Accept-Encoding（压缩）   | 能够接受的编码方式列表。参考 HTTP 压缩。                                                                                                                                       | Accept-Encoding: gzip, deflate                                                         |
| Authorization         | 用于超文本传输协议的认证的认证信息                                                                                                                                             | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==                                      |
| Connection            | 该浏览器想要优先使用的连接类型<br>1）keep-alive：请求服务器保持连接活动状态，以便后续的请求可以继续使用这个连接。这是 HTTP/1.1协议中默认的连接管理方式。<br>2）close：请求服务器在响应完成后立即关闭连接。这通常用于 HTTP/1.0 协议或当客户端和服务器中的一方不希望保持连接时。 | Connection: keep-alive                                                                 |
| Cookie                | 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie                                                                                                               | Cookie: $Version=1; Skin=new;                                                          |
| Host                  | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。                                                                                              | Host:[en.wikipedia.org:80](http://en.wikipedia.org/)                                   |
| Origin                | 发起一个针对 跨来源资源共享 的请求。                                                                                                                                           | Origin:[http://www.example-social-network.com](http://www.example-social-network.com/) |
| If-Modified-Since（缓存） | 允许服务器在请求的资源自指定的日期以来未被修改的情况下返回 `304 Not Modified` 状态码                                                                                                          | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT                                       |








## HTTP 与 RPC 的区别？为什么用 RPC 而不是 HTTP 或是相反？ #面过

RPC 是 Remote Procedure Call 的缩写，译为远程过程调用。要想实现 RPC 通常需要包含==传输协议和序列化协议的实现==。

而我们熟知的 HTTP，他的中文名叫超文本传输协议，所以他就是一种传输协议。所以，我们可以认为 RPC 和 HTTP ==并不是同一个维度的两个概念==。只不过他们都是可以作为远程调用的，所以经常拿来对比。

RPC 的具体实现上，可以像 HTTP 一样，基于 TCP 协议来实现，也可以直接基于 HTTP 协议实现。

区别：
- RPC 主要用于==公司内部服务之间的互相调用==，所以他性能消耗低，传输效率高，服务治理方便。
- 而 HTTP 主要用于对外的异构环境，浏览器调用，APP 接口调用，第三方接口调用等等。

在异构系统（跨语言和跨平台），==HTTP 具有更好的兼容性==，因为 HTTP 是一种通用的协议，几乎所有的编程语言和操作系统都支持 HTTP 协议，而不是所有的编程语言和操作系统都支持相同的 RPC 协议。

> feign 和 dubbo 的选择[微服务架构下feign和dubbo对比 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/610549397)

## URI 和 URL 的区别是什么？

- URI (Uniform Resource Identifier) 是统一资源**标志**符，可以唯一标识一个资源。
- URL (Uniform Resource Locator) 是统一资源**定位**符，可以提供该资源的路径。它是一种**具体的 URI**，即 URL 可以用来**标识**一个资源，而且还指明了如何**定位**这个资源。


## Cookie、Session、Token #秋招24 

![](../求职/Java/assets/image%20(5).png)

[✅Cookie，Session，Token的区别是什么？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/chxc9y)


## GET 和 POST 的区别？ #面过

> 重点搞清两者在语义上的区别即可


|           | GET                                           | POST             |
| --------- | --------------------------------------------- | ---------------- |
| 语义（约定好即可） | 用于获取或查询资源                                     | 创建或修改资源          |
| 幂等性       | 幂等的，重复请求不会改变资源的状态                             | 不幂等，重复请求会影响资源的状态 |
| 请求参数      | 放在 URL 中，长度受到浏览器限制（也能放在请求体中，不符合语义）            | 放在请求体中，大小没有明确限制  |
| 缓存        | 因为是幂等的，请求结果可以被浏览器或其他中间节点（代理、网关等）缓存起来，以调高性能和效率 | 不适合缓存            |
| 安全性       | 更容易泄露敏感数据                                     | 比GET强            |

> 如果是 http 协议，都不安全，因为协议本身是明文传输，必须使用 https 协议

URL 参数好处是，可以复制给别人，请求体没法给别人，例如内推码

## HTTP 如何减少重定向请求？ #秋招24 #TODO



# HTTPs #秋招24

HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 **TCP** 作为底层协议，并额外使用 **SSL/TLS** 协议用作加密和安全认证。

> SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，**新版本被命名为 TLS 1.0**。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS


## SSL/TLS 工作原理

### 非对称加密与对称加密

SSL/TLS 的核心要素是**非对称加密**。非对称加密采用两个密钥——一个公钥，一个私钥。
- 在通信时，私钥仅由解密者保存，
- 公钥由任何一个想与解密者通信的发送者（加密者）所知。

> 在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。
> 
> 但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。
> 
> 这样，通信信息就不会被其他人截获了，这==依赖于私钥的保密性==。

“非对称加密”设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，==SSL/TLS 实际对消息的加密使用的是对称加密。==

在双方通信之前，需要商量一个用于对称加密的密钥。由于网络通信的信道是不安全的，传输报文对任何人是可见的，对称密钥的交换肯定**不能直接**在网络信道中传输。因此，使用==非对称加密，对对称加密的密钥进行加密==，保护该密钥不在网络信道中被窃听。

这样，通信双方只需要一次==非对称加密，交换对称加密的密钥==，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。

### 公钥传输的信赖性

#TODO完善

客户端 C 需要先知道服务器 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。

> 要注意网络信道通信中有几个前提：
>
> 1. 任何人都可以捕获通信包
> 2. 通信包的保密性由发送者设计
> 3. 保密算法设计方案默认为公开，而（解密）密钥默认是安全的
>
> 因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。
>
> 同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！

为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的**电子签名**（见下节）。

当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥


## SSL/TLS 协议下建立连接的流程？ #秋招24 #TODO



## 对称加密和非对称加密 #秋招24 

[✅对称加密和非对称加密有什么区别？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/reb5c7)


## HTTP 和 HTTPS 有什么区别？ #秋招24

- *端口号*：HTTP 默认是 80，HTTPS 默认是 443。
- *URL 前缀*：HTTP 的 URL 前缀是 `http://`，HTTPS 的 URL 前缀是 `https://`
- *安全性和资源消耗*：
  - HTTP 协议运行在 TCP 之上，所有传输的内容都是**明文**，客户端和服务器端都**无法验证**对方的身份。
  - HTTPS 是运行在 **SSL/TLS** 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过**加密**，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
  - 所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。
- *SEO*（搜索引擎优化）：搜索引擎通常会**更青睐**使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。

## HTTPS怎么保证应用数据的完整性？ #秋招24 #TODO


# WebSocket

## HTTP 与 WebSocket 的区别？ #秋招24 #TODO 

## 怎么建立 WebSocket 连接？如何实现扫码请求？ #秋招24 #TODO 




项目介绍：药品知识库后台项目，为公司现有产品“药视通”和“药费通”提供数据服务，能够全维度展示并对数据进行精细化管理，实现对全国和属地知识库版本的全生命周期管理（提交、审批、发布、生效），此外支持认证登录、账户管理、权限隔离、审核中心、文件导入、操作记录、知识包生成等功能。

个人工作：根据产品需求独立完成项目从 0-1 开发、库表设计、接口设计，与前端、测试、产品、运维配合并顺利在项目排期内完成产品的评审、发版、迭代。

# 应用层

## 应用层常见协议有哪些？ #面过 

**超文本传输协议（HTTP，HyperText Transfer Protocol)** 是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。

**WebSocket** 是一种基于 TCP 连接的全双工通信协议，即客户端和服务器可以同时发送和接收数据。

> 下面是 WebSocket 的常见应用场景：
> 
> - 视频弹幕
> - 实时消息推送，详见[Web 实时消息推送详解](https://javaguide.cn/system-design/web-real-time-message-push.html)这篇文章
> - 实时游戏对战
> - 多用户协同编辑
> - 社交聊天
> - ……

**简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）** 基于 TCP 协议，是一种用于发送电子邮件的协议

**FTP 协议** 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。

> FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（SSH File Transfer Protocol，一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）

**SSH（Secure Shell）** 基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务。

**DNS**（Domain Name System，域名管理系统）基于 UDP 协议，用于解决域名和 IP 地址的映射问题。