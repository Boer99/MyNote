# ---------- 基本概念
## 进程和线程

“进程”是**程序的一次执行过程**，是系统运行程序的基本单位，因此进程是动态的。
- 系统运行一个程序即是一个进程从创建，运行到消亡的过程。
- 在 Java 中，启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称**主线程**。

线程与进程相似，操作系统进行调度的基本单元。线程也被称为“**轻量级进程**”

线程与进程不同的是，
- 一个进程在其执行的过程中可以产生多个线程。
- 是一个比进程更小的**执行单位**
- 线程执行开销小，但不利于资源的管理和保护；而进程正相反。
	- 系统在**产生一个线程**，或是在**各个线程之间作切换工作**时，负担要比进程小得多，
- 同类的多个线程**共享**进程的“堆”和“方法区”资源，但每个线程有自己的“程序计数器”、“虚拟机栈”和“本地方法栈”。
- 各进程是**独立**的，同一进程中的线程极有可能会**相互影响**

> 【拓展】
> 
> 程序计数器为什么是线程私有的?
> - 线程切换后能恢复到正确的执行位置
> 
> 虚拟机栈和本地方法栈为什么是线程私有的?
> - 保证线程中的局部变量不被别的线程访问到


Java 程序天生就是多线程程序

> JMX 查看一个普通的 Java 程序有哪些线程
> 
> ```java
> public class MultiThread {
> 	public static void main(String[] args) {
> 		// 获取 Java 线程管理 MXBean
> 	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
> 		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
> 		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
> 		// 遍历线程信息，仅打印线程 ID 和线程名称信息
> 		for (ThreadInfo threadInfo : threadInfos) {
> 			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
> 		}
> 	}
> }
> ```
> 
> 上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：
> 
> ```
> [5] Attach Listener //添加事件
> [4] Signal Dispatcher // 分发处理给 JVM 信号的线程
> [3] Finalizer //调用对象 finalize 方法的线程
> [2] Reference Handler //清除 reference 线程
> [1] main //main 线程,程序入口
> ```
> 
> 从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行

%%  %%
## Java 线程和 os 里的线程的区别是什么？(2)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB)

**现在的 Java 线程的本质其实就是操作系统的线程。**

JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种**用户级线程**（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。

在 JDK 1.2 及以后，Java 线程改为**基于“原生线程”（Native Threads）实现**，也就是说 JVM 直接使用**操作系统原生的内核级线程**（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

> 【提示】
> 
> 绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核）
> 
> 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

在 **Windows** 和 **Linux** 等主流操作系统中，Java 线程采用的是 **“一对一”的线程模型**，也就是一个 Java 线程对应一个系统内核线程。

> **Solaris** 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持**多对多**和**一对一**。具体可以参考 R 大的回答: [JVM 中的线程模型是用户级的么？open in new window](https://www.zhihu.com/question/23096638/answer/29617153)。

> 虚拟线程在 **JDK 21** 顺利转正，关于虚拟线程、平台线程（也就是我们上面提到的 Java 线程）和内核线程三者的关系可以参考：[Java 20 新特性概览](/java/new-features/java20.html)。

## 并发 和 并行

#字节_23_秋招_Java  

并发：
- 是在**同一实体**上的多个事件,
- 是在同一台处理器上的**同一时间段**内处理多个任务，
- 同一时刻，其实是只有一个事件在发生。

并行：
- 是在**不同实体**上的多个事件，
- 是在多台处理器上“**同时**”处理多个任务，
- 同一时刻，大家都真的在做事情，你做你的，我做我的

## 同步 和 异步

- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。

## 为什么要使用多线程？

先从总体上来说：
- *从计算机底层来说*： 
	- 线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。
	- 另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。
- *从当代互联网发展趋势来说*： 现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。

再深入到计算机底层来探讨：
- *单核时代* ：
	- 主要是为了**提高单进程利用 CPU 和 IO 系统的效率**。 
		- 假设只运行了一个 Java 进程的情况，当我们请求 IO 的时候，如果 Java 进程中只有一个线程，此线程被 IO 阻塞则整个进程被阻塞。CPU 和 IO 设备只有一个在运行，那么可以简单地说系统整体效率只有 50%。当使用多线程的时候，**一个线程被 IO 阻塞，其他线程还可以继续使用 CPU**。从而**提高了 Java 进程利用系统资源的整体效率**。
	- #Boer 用户交互及时（例子：wx）
- *多核时代* : 
	- 主要是为了**提高进程利用多核 CPU 的能力**。
		- 举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，不论系统有几个 CPU 核心，都只会有一个 CPU 核心被利用到。而创建多个线程，这些线程可以被映射到底层多个 CPU 上执行，在任务中的**多个线程没有资源竞争的情况下，任务执行的效率会有显著性的提高**，约等于（单核时执行时间/CPU 核心数）。

## 使用多线程可能带来什么问题？

**并发编程并不总是能提高程序运行速度的**，且可能会遇到很多问题，比如：
- 内存泄漏、
- 死锁、
- 线程不安全
- 等等。

如何理解线程安全和不安全？
- 线程安全和不安全是在**多线程环境**下对于**同一份数据的访问是否能够保证其正确性和一致性**的描述。
- 线程安全：不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全：多个线程同时访问时可能会导致数据混乱、错误或者丢失。

## 单核 CPU 上运行多个线程效率一定会高吗？

单核 CPU 同时运行多个线程的效率是否会高，取决于**线程的类型**和**任务的性质**。

一般来说，有两种类型的线程：CPU 密集型和 IO 密集型。
- CPU 密集型的线程主要进行计算和逻辑处理，需要占用大量的 CPU 资源。
- IO 密集型的线程主要进行输入输出操作，如读写文件、网络通信等，需要等待 IO 设备的响应，而不占用太多的 CPU 资源。

在单核 CPU 上，同一时刻只能有一个线程在运行，其他线程需要等待 CPU 的时间片分配。
- 如果线程是 CPU 密集型的，那么多个线程同时运行会导致**频繁的线程切换**，增加了系统的开销，降低了效率。
- 如果线程是 IO 密集型的，那么多个线程同时运行可以**利用 CPU 在等待 IO 时的空闲时间**，提高了效率。

# ---------- Java 线程

## 线程的生命周期和状态？线程状态的转换？

#B站SRE_Java后端 

> 其他问法：
> - 有实战监控过吗？(1)

Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：
- *NEW* : 初始状态，线程被**创建**出来但没有被调用 `start()` 。
- *RUNNABLE* : 运行/就绪状态，线程被调用了 `start()` **等待运行/运行**的状态。
- *BLOCKED* ：阻塞状态，**需要等待锁释放**。
- *WAITING* ：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。
- *TIME_WAITING* ：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。
- *TERMINATED* ：终止状态，表示该线程已经运行完毕。

![](assets/Pasted%20image%2020240204194329.png)

- 线程创建之后它将处于 **`NEW（新建）`** 状态，调用 `start()` 方法后开始运行，线程这时候处于 **`READY（可运行）`** 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 **`RUNNING（运行）`** 状态。
- 当线程执行 `wait()` 方法之后，线程进入 **`WAITING（等待）`** 状态。进入等待状态的线程需要**依靠其他线程的通知**才能够返回到运行状态。
- **`TIMED_WAITING(超时等待)`** 状态相当于在等待状态的基础上增加了超时限制，比如通过 `sleep（long millis）` 方法或 `wait（long millis）` 方法可以将线程置于TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。
- 当线程进入 `synchronized` 方法/块或者调用 `wait` 后（被 `notify`）重新进入 `synchronized` 方法/块，但是锁被其它线程占有，这个时候线程就会进入 **`BLOCKED（阻塞）`** 状态。
- 线程在执行完了 `run()` 方法之后将会进入到 **`TERMINATED（终止）`** 状态。

## 什么是线程上下文切换？

> 哪些情况引起线程上下文切换

上下文：线程在执行过程中会有自己的**运行条件和状态**（也称"上下文"），比如程序计数器，栈信息等。

当出现如下情况的时候，线程会从占用 CPU 状态中退出。
- 主动让出 CPU，
	- 比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，
	- 因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，
	- 比如请求 IO，线程被阻塞。
- 被终止或结束运行

上下文切换：这其中**前三种都会发生线程切换**，线程切换意味着需要保存**当前**线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载**下一个**将要占用 CPU 的线程上下文。

> 切出去还要切回来

上下文切换是现代操作系统的基本功能，因其每次需要保存信息恢复信息，这将会占用 CPU，内存等系统资源进行处理，也就意味着效率会有一定损耗，如果**频繁切换就会造成整体效率低下**

## 线程创建方式(1)

- Thread：自定义线程类继承 Thread 类，重写 `run()` 方法
- Runnable：
	- 实现 Runnable 接口重写 `run()` 方法，
	- 创建 Thread 对象，构造器传入 Runnable 对象
- Callable
	- 实现 Callable 接口重写 `call()` 方法
	- 创建 FutureTask 的对象，构造器传入 Callable 对象
	- 创建 Thread 对象，构造器传入 FutureTask 对象

最后，`Thread.start()`

还有 线程池

## sleep 和 wait

> 区别？ #PDD_23_秋招_后端

共同点：
- 两者都可以暂停线程的执行。
- 线程状态都变成 `TIMED_WAITING`

区别：
- *锁*：
	- `wait()` 需要和 syncronized 配合使用，`sleep()` 不强制
	- `wait()` 会释放锁，`sleep()` 不会
- *使用场景*：`wait()` 通常被用于线程间交互/通信，`sleep()` 通常被用于暂停执行。
- *唤醒机制*：
	- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()` 或者 `notifyAll()` 方法。
		- 或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
	- `sleep()` 方法执行完成后，线程会自动苏醒，
- *所属类*：`sleep()` 是 `Thread` 类的**静态本地**方法，`wait()` 则是 `Object` 类的**本地**方法。

> 为什么 `wait()` 方法不定义在 `Thread` 中？
> - `wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象 `Object` 都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
> 
> 为什么 `sleep()` 方法定义在 `Thread` 中？
> - 因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁

## start 和 run

> 可以直接调用 Thread 类的 run 方法吗？

new 一个 `Thread`，线程进入了新建状态。调用 `start()`方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 `start()` 会执行线程的相应准备工作，然后自动执行 `run()` 方法的内容，这是真正的多线程工作。 

但是，直接执行 `run()` 方法，会把 `run()` 方法当成一个 **main 线程下的普通方法**去执行，并不会在某个线程中执行它，所以这并不是多线程工作。


## 乐观锁 和 悲观锁

> 乐观锁与悲观锁 #顺丰_22_秋招_Java  #字节_飞书_24_实习_Java 
> 
> 两个用户修改数据，怎么防止另一个用户负载上一个用户的修改？ #PDD_23_秋招_基础电商_后端 
> - 加上版本号，或者把原来的状态放到条件里。
> 
> 乐观锁实现方式（版本号、CAS） #顺丰_23_秋招_Java 

悲观锁：每次在获取资源操作的时候都会上锁，共享资源每次只给一个线程使用，其它线程阻塞
- synchronized 和 Lock 实现类
- 适合“**多写场景，竞争激烈**”，可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。
- 缺点：
	- 高并发的场景下，激烈的锁竞争会造成线程阻塞，大量阻塞线程会导致系统的**上下文切换**，增加系统的性能开销
	- 存在死锁

乐观锁：不添加锁，只是在提交修改的时候去验证对应的资源是否被其它线程修改了
- 适合“**多读场景，竞争较少**”，这样可以避免频繁加锁影响性能
- 乐观锁主要针对的对象是**单个共享变量**
- 缺点：写占比非常多的情况，会频繁失败和重试，这样同样会非常影响性能，导致 CPU 飙升。不过，大量失败重试的问题也是可以解决的，像 `LongAdder` 以空间换时间的方式就解决了这个问题。

### 如何实现乐观锁？

版本号机制 或 CAS 算法

## lock 底层原理(1)

#得物_训练营_Java 

> Lock 底层实现？

# ---------- 共享模型_管程  

## 介绍下 synchronized 关键字

#得物_实习_Java

> 为什么 Synchronized 效率高？ #小红书_23_秋招_后端
> 
> 锁优化机制 #PDD_23_秋招_后端 

### 如何使用 Synchronized？

> √ synchronized怎么去使用，有哪几种用法？ #PDD_暑期实习_后端 
> - √ synchronized 加在普通方法上和静态方法上有什么区别？ #PDD_暑期实习_后端 #字节_23_秋招_Java 
> - √ syn 锁对象和锁类 #PDD_暑期实习_后端 
> - 加在 final 修饰的方法上 #字节_23_秋招_Java 
> - JDK1.8 里的 sychronized 锁是锁的哪里？ #小红书_实习_后端 

- 修饰实例方法
	- 给当前对象实例加锁，进入同步代码前要获得 **当前对象实例的锁**
- 修饰静态方法
	- 给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 **当前 class 的锁**
	- 静态同步方法与普通同步方法之间是不会有竞态条件的
- 修饰代码块
	- `synchronized(object)` 表示进入同步代码库前要获得 **给定对象的锁**。
	- `synchronized(类.class)` 表示进入同步代码前要获得 **给定 Class 的锁**

> 构造方法不能用 syncronized 修饰吗，构造方法本身就属于线程安全的，不存在同步的构造方法一说

### 底层原理

> 底层原理？ #字节_23_秋招_Java 
> - √ synchronized 上锁解锁流程 #字节_商业化_23_秋招_Java 
> - √ synchronized 是如何用字节码表达的？虚拟机是怎么支持它的？ #小红书_23_秋招_后端
> - synchronized 关联的 monitor 信息存储在哪？ #得物_实习_Java 

#### 锁得是什么？

每个对象都可以关联一个 Monitor，如果使用 synchronized 给对象上锁（重量级）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针

> 在 HotSpot 虚拟机中，monitor 采用 `ObjectMonitor` 实现 `ObjectMonitor.java` --> `ObjectMonitor.cpp` --> `objectMonitor.hpp` 其主要数据结构如下（位于 HotSpot 虚拟机源码 `objectMonitor.hpp` 文件，C++实现的）

ObjectMonitor 中的几个关键属性

![](assets/Pasted%20image%2020231127220305.png)

![](assets/Pasted%20image%2020240307135941.png)

> `wait/notify` 等方法也依赖于 `monitor` 对象，所以只有在同步块或者方法中才能调用 `wait/notify` 等方法，否则会抛出 `java.lang.IllegalMonitorStateException` 的异常

实现原理：
- Monitor 拥有一个锁计数器 count 和 一个指向持有该锁的线程的指针 owner
- 当执行 `monitorenter` 时，
	- count 为零，那么说明它没有被其他线程持有
		- owner 设置为当前线程，并将 count+1
	- count 不为零，
		- 如果 owner 是当前线程，那么 count+1，
		- 否则进入 EntryList，状态【BLOCKED】
- 当执行 `monitorexit` 时，count-1。count 为零代表锁已被释放
	- 唤醒 EntryList 中等待的线程来竞争锁，竞争是**非公平**的
- WaitSet 中是之前获得过锁，释放后在等待的线程

#### 字节码

```java
static final Object lock = new Object();
static int counter = 0;

public static void main(String[] args) {
	synchronized (lock) {
		counter++;
	}
}

Code:
	stack=2, locals=3, args_size=1
		0: getstatic #2 // <- lock引用 （synchronized开始）
		3: dup
		4: astore_1 // lock引用 -> slot 1
		5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针
		6: getstatic #3 // <- i
		9: iconst_1 // 准备常数 1
		10: iadd // +1
		11: putstatic #3 // -> i
		14: aload_1 // <- lock引用
		15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
		16: goto 24
		19: astore_2 // e -> slot 2 
		20: aload_1 // <- lock引用
		21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList
		22: aload_2 // <- slot 2 (e)
		23: athrow // throw e
		24: return
 Exception table:
	 from to target type
		 6 16 19 any
		 19 22 19 any
```

> 方法级别的 synchronized 不会在字节码指令中有所体现

1）同步代码块

`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令

- `monitorenter` 指向同步代码块的开始位置，`monitorexit` 指向结束位置
- 一般情况是 1 个 enter 对应 2 个 exit，一个正常退出、一个异常退出

owner 线程才可以执行 `monitorexit` 指令来释放锁

2）同步方法

`synchronized` 修饰的方法并**没有** `monitorenter` 指令和 `monitorexit` 指令

- JVM 通过该 `ACC_SYNCHRONIZED` **访问标志**来辨别一个方法是否声明为同步方法（静态同步方法还有 `ACC STATIC` 标识）
- 如果设置了，执行线程会将先持有 monitor，然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放 monitor

### synchronized 锁优化

#todo

### synchronized 和 volatile 有什么区别？

`synchronized` 关键字和 `volatile` 关键字是两个互补的存在
- 性能：`volatile` 是线程同步的轻量级实现，性能肯定比 `synchronized` 要好 。
- 作用对象：
	- `volatile` 只能用于变量
	- 而 `synchronized` 关键字可以修饰方法以及代码块 
- 线程安全：
	- `volatile` 关键字能保证数据的可见性，但不能保证数据的原子性。
	- `synchronized` 关键字两者都能保证。
- 适用场景：
	- `volatile` 关键字主要用于解决变量在多个线程之间的可见性，、
	- 而 `synchronized` 关键字解决的是多个线程之间访问资源的同步性。

## ReentrantLock

> √ synchronized 和 ReentrantLock 区别？ #PDD_服务端研发 #小红书_23_秋招_后端
> - Sychronized 和 ReetrantLock 哪个性能好些？ #小红书_23_秋招_后端 
> 
> 可重入的底层是如何实现的？ #得物_训练营_Java 
> - reentrantlock 原理 #得物_训练营_Java 

### 可重入锁

> √ 可重入锁是什么 #得物_训练营_Java 
> - synchronized 为什么设计为可重入锁？ #字节_商业化_23_秋招_Java 

*可重入锁* 也叫递归锁，指的是**线程可以再次获取自己的内部锁**。

> 如果是不可重入锁的话，就会造成死锁。

`Lock` 实现类（显式锁），包括 `synchronized` 关键字锁（隐式锁）都是可重入的。

synchronized 为什么设计为可重入锁？
- 调用完一个类的同步方法后还能再调用其他同步方法
- synchronized 修饰的递归调用方法

### 公平锁

#PDD_23_秋招_后端 #小红书_23_秋招_后端

公平锁：是指多个线程按照**申请锁的顺序**来获取锁
- 优缺点：
	- 保证时间上的绝对顺序
	- 性能较差一些，**上下文切换更频繁**。
- `Lock lock = new ReentrantLock(true)`---表示公平锁，先来先得。

非公平锁：有可能后申请的线程比先申请的线程优先获取锁，
- 优缺点：
	- 性能较好
	- **在高并发环境**下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）
- `Lock lock = new ReentrantLock(false)` 表示非公平锁，**默认为非公平锁**

> 为什么默认非公平？
> 
> 非公平锁能**更充分的利用 CPU 的时间片，尽量减少 CPU 空闲状态时间**。
> - **恢复挂起的线程到真正锁的获取还是有时间差的**，从开发人员来看这个时间微乎其微，但是从 CPU 的角度来看，这个时间差存在的还是很明显的。
> - 使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当 1 个线程请求锁获取同步状态，然后释放同步状态，所以**刚释放锁的线程在此刻再次获取同步状态的概率就变得非常大**，所以就**减少了线程的开销**。

### synchronized 和 ReentrantLock 区别？

#todo 

### reentrantlock 原理

#todo


## 死锁

> √ 什么是死锁？ #小红书_23_秋招_后端 #字节_商业化_24_Java 
> 
> √ 死锁的必要（产生）条件 #顺丰_22_秋招_Java #字节_商业化_24_Java  #字节_国际电商_23_秋招_Java 构造一个场景 #字节_国际电商_23_秋招_Java 
> 
> √ 代码模拟死锁，要百分之百会出现死锁（while+yield，这tm不是py？），而不是偶现 #小红书_23_秋招_后端
> 
> 怎么解决死锁？ #字节_国际电商_23_秋招_Java 
> 
> √ 如何预防（避免）死锁的发生？(2) #顺丰_22_秋招_Java  #字节_国际电商_23_秋招_Java 
> 
> √ 发生死锁怎么排查？(2)

### 是什么？

两个或两个以上的线程在执行过程中，因**争夺资源**而造成的一种**互相等待**的现象，若无外力干涉那它们都将无法推进下去。由于线程被**无限期地阻塞**，因此程序不可能正常终止。

产生死锁主要原因：
- 系统资源不足
- 进程运行推进的顺序不合适
- 资源分配不当

### 代码案例

> 来源于《并发编程之美》

![](assets/Pasted%20image%2020240205160141.png)

```java
public class DeadLockDemo {
    private static Object resource1 = new Object();//资源 1
    private static Object resource2 = new Object();//资源 2

    public static void main(String[] args) {
        new Thread(() -> {
            synchronized (resource1) {
                sleep(1000);
                
                synchronized (resource2) {
                    
                }
            }
        }, "线程 1").start();

        new Thread(() -> {
            synchronized (resource2) {
                sleep(1000);
                
                synchronized (resource1) {
                    
                }
            }
        }, "线程 2").start();
    }
}
```

### 必要条件

上面的例子符合产生死锁的四个必要条件：
1. *【互斥】条件* ：该资源任意一个时刻只由**一个线程**占用。
2. *【请求与保持】条件* ：一个线程因请求资源而**阻塞**时，对已获得的资源**保持不放**。
3. *【不剥夺】条件* ：线程已获得的资源在未使用完之前**不能被其他线程强行剥夺**，只有自己使用完毕后才释放资源。
4. *【循环等待】条件* ：若干线程之间形成一种**头尾相接**的循环等待资源关系 #todo 

### 如何预防

如何“预防”线程死锁？破坏死锁的产生的必要条件即可：
1. *破坏请求与保持条件*：一次性申请**所有**的资源。
2. *破坏不剥夺条件*：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以**主动释放**它占有的资源。
3. *破坏循环等待条件*：靠**按序申请资源**来预防。按某一顺序申请资源，释放资源则反序释放。

### 排查死锁

1）命令方式
- `jps -l` 查出进程号
- `jstack <进程号>` 打印进程的栈信息

2）图形化界面：jconsole工具

### 如何避免

注意加锁顺序！

在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态。

> *安全状态* 指的是系统能够按照某种线程推进顺序（P1、P2、P3……Pn）来为每个线程分配所需资源，直到满足每个线程对资源的最大需求，使每个线程都可顺利完成。称 `<P1、P2、P3.....Pn>` 序列为安全序列。

我们对线程 2 的代码修改成下面这样就不会产生死锁了。

```java
new Thread(() -> {
	synchronized (resource1) {
		System.out.println(Thread.currentThread() + "get resource1");
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		System.out.println(Thread.currentThread() + "waiting get resource2");
		synchronized (resource2) {
			System.out.println(Thread.currentThread() + "get resource2");
		}
	}
}, "线程 2").start();
```

> 线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。

## java 里有哪几种上锁方式，了解他们的区别吗？

#pdd_暑期实习_后端 


  
## Future 获得结果怎么处理？

#B站SRE_Java后端 



%% -- %%
## 说一下 ThreadLocal

#B站Java后端23_秋招 #B站后端日常实习 

> 其他问法：
> 
> - ThreadLocal 是什么, 怎么使用的？ #PDD_服务端研发
> - 可能会有哪些问题？ #PDD_服务端研发 #PDD_23_秋招_基础电商_后端 
> - 怎么避免内存泄漏？ #PDD_服务端研发
> - 底层怎么优化的？ #PDD_服务端研发
> - key是弱引用，可以为null，那么value呢？ #PDD_服务端研发
> - 用 ThreadLocal 有什么好处？ #PDD_服务端研发
> - 主线程的 ThreadLocal 如何向子线程的 ThreadLocal 传递数据？(1)
> - 如何实现多个线程修改同一个变量，互不影响？ #PDD_23_秋招_基础电商_后端 

%% -- %%

## AQS 原理

#PDD_23_秋招_后端 

(讲了讲 clh 锁，拿 reentrantlock 举了个例子)(1)
 

# ---------- 内存

## 介绍一下 java 内存模型 JMM

#得物_实习_Java #顺丰_23_秋招_Java #字节_24_实习_Java 

> 共享变量的副本是存储在 jvm 哪里的？ #得物_实习_Java

### JMM 是什么？

- JVM 规范中试图定义一种 Java 内存模型（Java Memory Model，简称 JMM）
- 说法一：
	- 本身是一种**抽象的概念**并不真实存在，它仅仅叙述的是一组约定或**规范**，
	- 通过这组规范定义了**程序中（尤其是多线程）各个变量的读写访问方式**，
	- 并决定**一个线程对共享变量的写入何时** 以及 **如何变成对另一个线程可见**
- 说法二（推荐）：
	- Java 定义的并发编程相关的一组规范，
	- 除了抽象了**线程和主内存之间**的关系之外，
	- 其还规定了从 **Java 源代码到 CPU 可执行指令**的这个转化过程要**遵守哪些和并发相关的原则和规范**，
	- 其主要目的是为了简化多线程编程，增强程序可移植性的。
- 原则：JMM 的关键技术点都是围绕多线程的**原子性、可见性和有序性**展开的

为什么需要 JMM？/ JMM 能干嘛？
- 来**屏蔽**掉各种硬件和操作系统的内存访问差异，实现让 Java 在各种平台下都能达到一致的内存访问效果。
- 并发编程下，像 CPU 多级缓存和指令重排这类设计可能会导致程序运行出现一些问题。
	- 就比如说我们上面提到的指令重排序就可能会让多线程程序的执行出现问题，为此，JMM 抽象了 happens-before 原则来解决这个指令重排序问题。

> 一般来说，编程语言也可以直接复用操作系统层面的内存模型。不过，不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。

### JMM 是如何抽象线程和主内存之间的关系？

- Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中
- 每条线程还有自己的工作内存，
    - 保存了被该线程使用的**变量的主内存副本**，
    - 线程对变量的所有操作（读取、赋值等）都**必须在工作内存中进行**，而不能直接读写主内存中的数据
- 不同的线程之间也无法直接访问对方工作内存中的变量，**线程间变量值的传递均需要通过主内存**来完成

8 个基本操作和 8 条并发原则

> 更详细的原则见 [JUC_atguigu#主内存与工作内存](../Java/JUC/JUC_atguigu.md#主内存与工作内存)

### Java 内存区域和 JMM 有何区别？

> 这是一个比较常见的问题，很多初学者非常容易搞混

- JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何**分区存储程序数据**，就比如说堆主要用于存放对象实例。
- Java 内存模型和 Java 的并发编程相关，
	- 是啥
	- 有啥用

### happens-before

#todo 

### 三大特性

#todo 

## 说一下 volatile 关键字

#B站Java后端23_秋招 #得物_实习_Java

> volatile可以保证线程安全吗？ #B站Java后端23_秋招 

volatile（易变关键字）：它可以用来修饰**成员变量**和**静态成员变量**，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存


volatile 保证可见性和有序性，不保证原子性。
- 当**写**一个 volatile 变量时，JMM 会把该线程对应的本地内存中的**共享变量值立即刷新回主内存中**
- 当**读**一个 volatile 变量时，JMM 会把该线程对应的本地内存设置为无效，**重新回到主内存中读取最新共享变量的值**
- 所以 volatile 的写内存语义是直接刷新到主内存中，读的内存语义是直接从主内存中读取

### 如何保证变量的可见性？

每次使用它都到主存中进行读取

> #JavaGuide 
> 
> `volatile` 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是**禁用 CPU 缓存**。如果我们将一个变量使用 `volatile` 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

### 如何禁止指令重排序

#todo 内存屏障

### volatile 可以保证原子性吗？

不能，i++案例

### 应用场景

#todo

### DCL 单例模式

在单例 INSTANCE 上用 volatile 修饰

```java
public final class Singleton {
    private Singleton() {}

    private static volatile Singleton INSTANCE = null;

    public static Singleton getInstance() {
        // 实例没创建，才会进入内部的 synchronized代码块
        if (INSTANCE == null) {
            synchronized (Singleton.class) {
                // 也许有其它线程已经创建实例，所以再判断一次
                if (INSTANCE == null) {
                    INSTANCE = new Singleton();
                }
            }
        }
        return INSTANCE;
    }
}
```

# ---------- 无锁


## CAS

> 操作系统层面，CAS 操作是怎么做的？ #B站cdn_服务端开发
> 
> 原理？ #PDD_23_秋招_后端
> 
> CAS底层怎么实现？ #字节_飞书_24_实习_Java
> 
> ABA如何解决？ #PDD_23_秋招_后端  #顺丰_22_秋招_Java 
> 
> CAS 的优缺点是什么？ #PDD_服务端研发 #PDD_23_秋招_基础电商_后端
> 
> 超卖的 cas，cas 的逻辑是什么? #PDD_服务端研发
> 
> cas 和普通的锁的区别，什么时候用 cas 什么时候用到锁 #PDD_服务端研发
> 
> 项目里的乐观锁怎么实现的？ #字节_飞书_24_实习_Java

# ---------- 工具

## JUC 工具类用过哪些？

#B站SRE_Java后端  #字节_飞书_24_实习_Java 


## CountDownlaunch 使用场景和原理

#得物_训练营_Java 

# ---------- 线程池

## 线程池创建方法

#得物_训练营_Java

## 线程池的常见配置?

#B站Java后端23_秋招 

## 假如现在有 15 个任务 5个核心线程 最大线程是10 工作队列是5 请问执行顺序是怎样的？

#B站Java后端23_秋招 

## 线程池有哪些（核心）参数？

#PDD_23_秋招_基础电商_后端 #PDD_23_秋招_后端 #字节_国际电商_23_秋招_Java

> 核心线程数、最大线程数、最大线程数过期时间、阻塞队列、线程工厂、拒绝策略
> 
> 线程池大小如何设置(2)
> 
> 拒绝策略 #顺丰_22_秋招_Java 

## 怎么 保证/确定（核心）线程数的？

#PDD_23_秋招_后端

> 核心线程数不够会怎么处理？(1)

## 如果针对业务场景设计线程池参数应该根据哪些？(1)



## 线程池工作流程？

#得物_训练营_Java #字节_国际电商_23_秋招_Java

> 线程池没有新任务进来，线程池会如何变化？ #得物_训练营_Java 

## 什么时候用到线程池？

#得物_训练营_Java 

> 怎么用线程池，应用场景(1)
> 
> 线程池在项目中是做什么的？(1)
> 
> 你平常用哪个线程池，和别的有什么区别？ #字节_国际电商_23_秋招_Java

## 在线程池中多个线程的结果是如何去合并的，说出两种解决方式(1)


## 线程池是怎么实现线程的保活和停止管理的？(1)

答：不是很理解面试官的意思，沉默了几分钟说了一下shutdown()、shutdownNow()以及awaitTermination()三种方法的使用，面试官没有反驳，点了点头，估计瞎猫碰上死耗子了

## 线程池设置2个核心线程数，4个最大线程数，什么时候用核心线程数，什么时候用最大线程数？(1)


## 线程池是使用的自己实现的线程池吗？(1)


## 线程池中提交任务想要得到运行结果怎么办，其原理是什么(1)


## schedule 线程池原理(1)


## fixed, single, cache 线程池原理(1)


## 自定义线程池需要重写什么(1)


## 线程池核心部分和原理(1)


## 线程池新增任务的执行流程是怎么样的(1)


# ---------- 多线程集合
## java 中线程安全的类有哪些？(1) 

> map、set、list中哪些是线程安全的？(1)
> 
> HashTable为什么线程安全 #小红书_实习_后端

## List、Map 要使用线程安全要怎么办？

#得物_后端

## ConcurrentHashMap 原理(1)

#PDD_服务端研发

> ConcurrentHashMap1.7 和 1.8线程安全怎么做的？ #小红书_实习_后端
> 
> HashMap 和 ConcurrentHashMap 的对比和区别 #顺丰_23_秋招_Java 
> 
> ConcurrentHashMap 是通过什么手段保证（怎么实现）线程安全的？ #顺丰_23_秋招_Java  #字节_飞书_24_实习_Java #字节_商业化_23_秋招_Java 
> 
> 底层结构？ #字节_飞书_24_实习_Java 

## ConcurrentHashMap 和 HashTable 有什么区别？

#得物_后端


# ---------- 多线程业务和场景

## 平时怎么用多线程？遇到的多线程问题怎么解决？(1)

## 3 个线程交替打印 1-100 伪代码，则么让 main 线程等待这三个线程执行完再执行？(1)



# ---------- 线程通信
## 线程通信的方式有哪些？

#字节_24_实习_Java 

> 大概的原理？(2)


# ---------- 未知

## 真正使用时，Java 里的线程和进程是如何调度？(1)

## java怎么处理多线程并发的问题？

#PDD_暑期实习_后端 


## 多线程的底层实现原理(1)


## 进程有哪些状态？

> 有一个问过，忘了哪个了

## 多线程事务失效(1)

## Spring多线程支持(1)

## 救急线程是什么时候过期的？

## 协程和线程区别，对应关系

#pdd_暑期实习_后端