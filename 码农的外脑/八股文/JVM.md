
你在做项目过程中，有没有遇到哪些不使用类加载器的（？？？[滴滴一面二面面经 Java后端_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/983772?type=0&order=7&pos=4&page=1&source_id=discuss_center_0_nctrack&channel=1009&ncTraceId=38730988c36848d1a1f097f071d1fc11.271.16594426100403233&gio_id=6E37BDC2FA182C9B5BCED98C56AAF69F-1659442610771)）

# ---------- 未知

## 内存 gc 怎么排查，有哪些工具，怎么优化的？

> PDD Java 后端研发

## 内存泄漏，如何排查？

> PDD 服务端研发

## jvm 分析工具

> PDD Java 后端研发

## 创建对象的过程

> B 站 Java 后端

## 对象的生命周期

> B 站 Java 后端

？

## 初始化的链接有什么作用？

> PDD 暑期 Java 后端

这个题没看懂？链接和连接应该是一个意思

# ---------- 类加载机制

> 类的生命周期：
> - 加载
> - 连接（验证--->准备--->解析）
> - 初始化
> - 使用
> - 卸载

%%  %%
## 类加载的机制

> B 站 Java 后端
> 
> 类是怎么加载的？PDD 暑期 Java后端

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制

主要分为三步：加载-->连接-->初始化

1）加载阶段

主要完成三件事：
- **类加载器**根据**类的全限定名**通过不同的渠道以**二进制流**的方式获取字节码信息
- 两种表述
	- 将字节流所代表的静态存储结构转换为**方法区的运行时数据结构**。
	- 将字节码中的信息保存到**方法区**中，生成一个 **InstanceKlass 对象**，保存类的所有信息
- 在堆中生成一个代表该类的 `java.Lang.Class` 对象，作为**方法区**这些数据的**访问入口**。
	- 作用是在 Java 代码中去获取**类的信息** 以及存储**静态字段**的数据 (JDK 8 及之后)

> 渠道包括
> - 本地文件：磁盘上的字节码文件
> - 动态代理生成：程序运行时使用动态代理生成
> - 通过网络传输的类：早期的 Applet 技术使用

2）连接阶段

分为验证、准备和解析

验证： 字节码文件是否遵守了《Java 虚拟机规范》中的约束
- 文件格式验证，
	- 比如文件是否以 `0xCAFEBABE` 开头，
	- 主次版本号是否满足当前 Java 虚拟机版本要求
- 元信息验证（字节码语义检查），
	- 例如类必须有父类 (super 不能为空)
	- 是否继承了不允许继承的类
- 字节码验证（程序语义检查），
	- 比如方法内的指令执行到一半强行跳转到其他方法中去
	- 函数的参数类型是否正确
	- 对象的类型转换是否合理
- 符号引用验证（类的正确性检查）
	- 例如是否访问了其他类中 private 的方法等

> 在生产环境的实施阶段就可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

准备：为**静态变量** (static) 分配内存并设置初始值
- **Final** 修饰的**基本数据类型**的**静态变量**，会进行赋值
- JDK 7 及之后类变量则会随着 Class 对象一起存放在 Java 堆中

解析：将常量池中的符号引用替换为直接引用。

3）初始化阶段

> 这一步 JVM 才开始真正执行类中定义的 Java 程序代码 (字节码)

执行类构造器 `<clinit>()` 方法 
- 即字节码文件中 clinit 部分的字节码指令。Javac 编译器自动生成的
- 执行**静态代码块**中的代码，并为**静态变量**赋值

导致类的初始化的几种方式 (主动使用一个类)：
- 访问一个类的静态变量或者静态方法，
	- 注意：变量是 final 修饰的并且等号右边是常量不会触发初始化。
	- 字节码指令：
		- `getstatic` 访问类的静态变量
		- `putstatic` 给类的静态变量赋值
		- `invokestatic` 调用类的静态方法
- New 一个该类的对象时。
	- 字节码指令：`new`
- 调用 `Class.forName(String className)`
	- `java.lang.reflect` 包下的反射调用
- 执行 Main 方法的当前类
- 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

>补充： 
> - `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
> - **「来自[issue745open in new window](https://github.com/Snailclimb/JavaGuide/issues/745 "issue745")」** 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

%%  %%
## 静态代码块、静态变量、普通代码块和构造方法执行顺序？

> #PDD暑期Java后端   原题是类在初始化过程中，它的静态变量，静态方法块，成员变量和构造函数的执行步骤？。面试者肯定是记错了。

- 静态方法块、静态变量（根据 Java 编写的顺序）
- 普通代码块
- 构造函数

# ---------- 类加载器

类加载器（ClassLoader）是 Java 虚拟机**提供给应用程序**去实现**获取类和接口字节码数据**的技术。

## 类加载器类型

 #PDD_Java后端研发 

JDK8
- 虚拟机底层实现 c++：
	- 启动类加载器 BootStrapClassLoader：
		- 加载 java 中**最核心**的类。
		- 没有父级
		- 默认加载  `JDK安装目录/jre/lib` 下的类文件
			- 比如 `rt.jar`，`tools.jar``resources.jar` 等 jar 包和类。
		- VM 参数扩展： `-Xbootclasspath/a:jar包目录/jar包名` 
- Java 实现：
	- 都是继承自 URLClassLoader 的静态内部类
	- 扩展类加载器 ExtensionClassLoader：
		- 允许扩展 Java 中比较通用的类
		- 默认加载 `JDK安装目录/jre/lib/ext` 下的类文件。
		- VM 参数扩展： `-Djava.ext.dirs=jar包目录[分隔符]用户jar包目录` 
	- 应用程序类加载器 AppClassLoader：
		- 加载**当前应用 classpath 下**的所有 jar 包和类（面向用户）

JDK9 引入了模块系统
- 继承关系从 URLClassLoader 变成了 **BuiltinClassLoader**，实现了从模块中加载字节码文件。
- 扩展类加载器 被替换成了 **平台类加载器（Platform Class Loader）**

## 双亲委派机制

#PDD_Java后端研发 

各种类加载器之间的层次（协作）关系被称为类加载器的 双亲委派模型（Parents Delegation Model）

除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。通过成员变量 Parent 实现。

工作过程：
- 如果一个类加载器收到了类加载的请求，**自底向上检查**父类加载器是否加载过
	- 如果已经加载过，就直接返回 **Class 对象**，结束
- 所有父类都加载过，**自顶向下加载**
	- 当所有父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

## 为什么要有双亲委派？

 #PDD_Java后端研发  

> 双亲委派模型的好处？解决了什么问题？

解决**一个类到底由谁加载**的问题。定义了三种类加载器间的配合协作来完成类加载

好处：
- 保证类加载的安全性：
	- 避免恶意代码替换 JDK 中的核心类库，比如`Java.Lang.String`，确保核心类库的完整性和安全性
- 避免同一个类被重复加载
	- JVM 区分不同类的方式不仅仅根据全限定类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。打破了双亲委派就可以加载相同全限定类名的不同类

## 破坏双亲委派的方法 (3)

- 自定义类加载器
	- 继承 ClassLoader，重写 loadClass 方法，将双亲委派机制的代码去除
	- 不想破坏双亲委派机制，重写 findClass 方法
- 利用线程上下文类加载器加载类，
	- SPI 机制打破了，例如 JDBC、JNBI
	- `Java.lang.Thread` 中的 `getContextClassLoader()` 和 `setContextClassLoader(ClassLoader cl)` 分别用来获取和设置线程的上下文类加载器
- 历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载
	- #todo

## SPI 为什么打破双亲委派机制？

 #PDD_Java后端研发 

Service Provider Interface, 服务提供者接口。

> 通俗得说，JDK 提供接口，供应商提供服务。编程人员编码时面向接口编程，然后 JDK 能够自动找到合适的实现

> SPI 工作原理：
>  1. 在 ClassPath 路径下的 **META-INF/services** 文件夹中，以**接口的全限定名**来命名文件名，对应的文件里面写该 **接口的实现**。
> 2. 使用 **ServiceLoader.load()** 加载实现类

> #《深入理解Java虚拟机》 
> 
> **线程上下文类加载器**去加载所需的 SPI 服务代码，这是一种“**父类加载器去请求子类加载器**”完成类加载的行为，这种行为实际上是**打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则**，
> 
> 但也是无可奈何的事情。**Java 中涉及 SPI 的加载基本上都采用这种方式来完成**，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。

**个人更倾向于没有打破！**

#Boer 父类加载器去请求（委派）子类加载器，这个说法不够准确，例如 JDBC 中 DriverManager 加载驱动，启动类加载器加载 DriverManager 类，然后 **DriverManager 的初始化阶段（静态代码块）** 触发了驱动类的加载，类的加载依然遵循双亲委派机制（应用程序类加载器还是要向上再向下）。启动类加载器没有直接地委派子类加载器

> 举个例子，DriverManager 使用 SPI 机制，最终加载 jar 包中对应的驱动类
> - **启动类加载器**加载 DriverManager。
> - 在初始化 DriverManager 时，通过 SPI 机制加载 jar 包中的 mysql 驱动。
> 	-  `ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);`
> - SPI 中利用了**线程上下文类加载器**（应用程序类加载器）去加载类并创建对象

%%  %%
# ---------- JVM 内存区域

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。HotSpot 虚拟机才有永久代的概念

## JVM 内存结构

#PDD_Java后端研发 #B站Java后端 #B站Java后端实习

> #PDD服务端研发 Jvm 运行时数据区的内容，共用/独占分别有哪些？

JVM 运行时数据区（JVM管理的内存）分为五个部分

 线程不共享（伴随着线程的创建而创建，线程的销毁而销毁）
- 程序计数器
	- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
	- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当**线程被切换回来**的时候能够知道该线程上次运行到哪儿了
	- 【内存溢出】唯一一个**不会出现** `OutOfMemoryError` 的内存区域
- Java 虚拟机栈
	- 管理方法调用中的基本数据，每一个方法的调用使用一个**栈帧**（Stack Frame）来保存
	- 栈帧：[栈帧作用？](#栈帧作用？)
	- 【内存溢出】
		- 栈的内存大小不允许动态扩展，那么当线程请求栈的**深度**超过当前 Java 虚拟机栈的最大深度的时候，**抛出 `StackOverflowError` 错误**
		- 栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则**抛出 `OutOfMemoryError` 异常**
	- 【VM 参数】 `-Xss`
- 本地方法栈
	- 存储的是 **native 本地方法的栈帧**。
	- 在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了**同一个栈空间**。
	- 【内存溢出】同 Java 虚拟机栈

线程共享（垃圾回收）
- 方法区
	- JVM 运行时数据区域的一块逻辑区域
	- 包含三部分：
		- 类的元信息（InstanceKlass 对象）
		- 运行时常量池
			- Class文件中的常量池表（Constant Pool Table），用于存放编译期生成的各种**字面量与符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。
			- 符号引用翻译出来的**直接引用**也存储在运行时常量池中
			- 运行期间也可以将新的常量放入池中
				- 例如 String 类的 `intern()` 方法
			- 【内存溢出】`OutOfMemoryError`
		- 字符串常量池
			- 存储代码中定义的**常量字符串内容**。
			- JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。
			- JDK1.7 之前，存放在永久代。**JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。**
	- 组成：和虚拟机的具体实现有关，见 [java8 和 java7 内存模型差异？](#java8%20和%20java7%20内存模型差异？)
	- 【内存溢出】
		- 元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`
	- 【VM 参数】
		- Jdk7 及之前的版本，将方法区放在堆中的永久代空间，堆的大小由 JVM 参数来控制。
		- Jdk8 及之后的版本，`-XX:MaxMetaspaceSize=值` 对元空间大小进行限制
- 堆
	- 存放对象实例
	- 组成：和虚拟机的具体实现有关，见 [java8 和 java7 内存模型差异？](#java8%20和%20java7%20内存模型差异？)
	- 【内存溢出】
		- `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。
		- `java.lang.OutOfMemoryError: Java heap space`：假如在创建新的对象时，堆内存中的空间不足以存放新创建的对象, 就会引发此错误。
	- 【VM 参数】`-Xmx` （max）和 `-Xms` （total）

> JDK 1.7 为什么要将字符串常量池移动到堆中？
> 
> 主要是因为**永久代（方法区实现）的 GC 回收效率太低**，只有在**整堆收集 (Full GC)的时候才会被执行 GC**。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

%%  %%
## 栈帧作用？

#PDD_Java后端研发  

栈帧的组成：
- 局部变量表：在运行过程中存放所有的局部变量
	- **编译成字节码文件时**就可以确定局部变量表的内容
	- 保存的内容：
		- 实例方法的 this 对象
		- 方法的参数
		- 方法体中声明的局部变量
- 操作数栈：虚拟机在执行指令过程中用来**存放中间数据**的一块区域（比如临时变量）
	- 编译期即可决定最大深度
- 帧数据：
	- 动态链接：保存了“符号引用”到“运行时常量池”的内存地址的映射关系
	- 方法出口：方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向**上一个栈帧中的下一条指令的地址**
	- 异常表：存放的是代码中异常的处理信息，包含了
		- 异常捕获的生效范围
		- 异常发生后跳转到的字节码指令位置。

## java8 和 java7 内存模型差异？

#PDD_Java后端研发 

“永久代--->元空间”

永久代是 JDK 1.8 之前的方法区实现

> JDK6 开始 HotHotSpot 开发团队就计划放弃永久代，采用本地内存实现方法区

JDK7 的 HotSpot，把原本放在永久代的字符串常量池、静态变量等移出
- 堆
	- 新生代、老年代
	- 字符串常量池（具体位置不详）
	- class 对象（具体位置不详）
		- 静态变量
	- 永久代
		- 类的元信息
		- 运行时常量池

> 静态变量存储在哪里？
> - JDK 6 之前存储在方法区，即永久代
> - JDK 7 及之后，存储在堆中的 Class 对象

JDK 8，终于完全**废弃了永久代**的概念，改用与 JRockit、J9 一样在本地内存中实现的**元空间**（Metaspace）来代替，**把 JDK7 中永久代还剩余的内容（主要是类型信息）全部移到元空间中**。
- 堆
	- 新生代、老年代
	- class 对象（具体位置不详）
		- 静态变量
	- 字符串常量池（具体位置不详）
- 元空间（本地内存）
	- 类的元信息
	- 运行时常量池

> 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?
> 
> 1）整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。
> 
> 元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` （永久代大小）控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。
> 
> 2）在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。

%% --- %%
## 堆和栈有什么区别？

#PDD暑期Java后端

|  | 存储内容 | 功能 | 存取速度 | 线程共享 | 需要垃圾回收 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 栈 | 主要存放基本类型的变量和对象的引用变量。 | 执行程序 | 快 | 否 | 否 |
| 堆 | 主要存放创建的对象实例 | 存放对象 | 动态分配内存，较慢 | 是 | 是 |

> 栈帧中的局部变量表（数组）大小、操作数栈的深度在编译时就确定了。

%%  %%
# ---------- 垃圾回收

## 哪些对象可以作为 GC root 的根节点（1）

#PDD_Java后端研发 

说法太多， #todo

> #JavaGuide 
> - 虚拟机栈(栈帧中的局部变量表)中引用的对象
> - 本地方法栈(Native 方法)中引用的对象
> - 方法区中类静态属性引用的对象
> - 方法区中常量引用的对象
> - 所有被同步锁持有的对象
> - JNI（Java Native Interface）引用的对象

%% --- %%
## 强引用和软引用

#PDD_Java后端研发  

强引用：强引用对象不会被垃圾回收器回收，JVM 抛出 OutOfMemoryError 错误也不会被回收

软引用：**当程序内存不足时**，垃圾回收器会将软引用对象回收。
- 常用于实现缓存
- JDK 1.2 版之后提供了 **`java.lang.ref.SoftReference`** 来实现软引用。
	- 将对象使用软引用包装起来，`new SoftReference<对象类型>(对象)`
	- 继承 SoftReference 类，构造器传入包含的对象和引用队列
- `SoftReference` 对象本身的回收，队列机制：
	- 软引用创建时，通过构造器传入引用队列
	- 软引用中**包含的对象被回收时**，该软引用对象会被**放入引用队列** `ReferenceQueue`
	- 遍历引用队列，将 SoftReference 的强引用删除

## 常见的垃圾回收算法都有哪些（1）

> #得物Java实习 #PDD_Java后端研发 

1）“标记-清除”算法：“标记阶段”标记不需要回收的对象，“回收阶段”从内存中删除没有被标记的对象
- 优点：实现简单
- 缺点：
	- 标记和清除两个过程效率都不高
	- 大量不连续的内存碎片：
		- 大对象没有连续的内存分配，触发 gc
		- 空闲链表，分配速度慢

2）“复制”算法：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另一块上面，再把已使用过的那块内存空间一次清理掉
- 优点：
	- 多数对象都是可回收的情况
	- 没有内存碎片
- 缺点：
	- 多数对象都是存活的，复制开销大
		- 不适合永久代
	- 内存利用率低
- 适合“年轻代”，不需要按照 1:1 的比例划分内存空间

3）“标记-整理”算法：标记阶段和“标记-清除”一致，清除阶段让存活对象移动到内存空间的一端，然后直接清理掉边界以外的内存、
- 优点：
	- 在“标记-清除”的基础上解决了内存碎片，内存效率也高
- 缺点：
	- 整理效率不高
- 适合“老年代”这种垃圾回收频率不是很高的场景

4）“分代收集”算法：根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代。新生代的对象存活率低，老年代的对象存活率高，可以根据各个年代的特点选择合适的垃圾收集算法。

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种
- 部分收集 (Partial GC)：
	- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；
	- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。
		- 需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
	- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
- 整堆收集 (Full GC)：收集整个 Java 堆和方法区

## 哪些场景会保存到老年代 ？

#PDD服务端研发 #PDD_Java后端研发  

> 相似问法：
> - 新生代对象什么时候进入老年代？
> - 新生代的对象达到老年代的条件？
> - 哪些场景会保存到老年代 ？为什么达到15年龄就要升级？

大对象直接进入老年代

> 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

- 旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本（避免大对象在 Eden 区及两个 Survivor 区之间来回复制）
- 大对象直接进入老年代的行为是由虚拟机**动态决定**的
	- HotSpot 虚拟机提供了 #VM参数 `-XX:PretenureSizeThreshold` （只对 Serial 和 ParNew 两款新生代收集器有效），指定大于该设置值的对象直接在老年代分配
	- #todo G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
	- #todo Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。

年龄达到阈值（默认值和具体垃圾回收器有关）
- 对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1。
- 每经过一次 minor gc 存活，年龄+1
- 对象年龄达到阈值，晋升到老年代。
	- #VM参数 `-XX:MaxTenuringThreshold=<age>` 设置年龄阈值。

空间分配担保
- 确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间
- JDK 6 之后，只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。



## 常用垃圾回收器 (2)



## CMS 垃圾回收器的优缺点、执行步骤

> 小红书后端暑期实习

> CMS。PDD Java 后端


## G1 垃圾回收器介绍

> 美团到店

G 1 有哪些特点？(1)

## G 1 和 CMS 的主要区别是什么

> 小红书后端暑期实习、PDD Java 后端

