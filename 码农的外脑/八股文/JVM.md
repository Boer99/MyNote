
你在做项目过程中，有没有遇到哪些不使用类加载器的（？？？[滴滴一面二面面经 Java后端_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/983772?type=0&order=7&pos=4&page=1&source_id=discuss_center_0_nctrack&channel=1009&ncTraceId=38730988c36848d1a1f097f071d1fc11.271.16594426100403233&gio_id=6E37BDC2FA182C9B5BCED98C56AAF69F-1659442610771)）

# ---------- 未知

## 内存 gc 怎么排查，有哪些工具，怎么优化的？

> PDD Java 后端研发

## 内存泄漏，如何排查？

> PDD 服务端研发

## jvm 分析工具

> PDD Java 后端研发

## 创建对象的过程

> B 站 Java 后端

## 对象的生命周期

> B 站 Java 后端

？

## 初始化的链接有什么作用？

> PDD 暑期 Java 后端

这个题没看懂？链接和连接应该是一个意思

# ---------- 类加载机制

> 类的生命周期：
> - 加载
> - 连接（验证--->准备--->解析）
> - 初始化
> - 使用
> - 卸载

## 类加载的机制

> B 站 Java 后端
> 
> 类是怎么加载的？PDD 暑期 Java后端

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制

主要分为三步：加载-->连接-->初始化

1）加载阶段

主要完成三件事：
- **类加载器**根据**类的全限定名**通过不同的渠道以**二进制流**的方式获取字节码信息
- 两种表述
	- 将字节流所代表的静态存储结构转换为**方法区的运行时数据结构**。
	- 将字节码中的信息保存到**方法区**中，生成一个 **InstanceKlass 对象**，保存类的所有信息
- 在堆中生成一个代表该类的 `java.Lang.Class` 对象，作为**方法区**这些数据的**访问入口**。
	- 作用是在 Java 代码中去获取**类的信息** 以及存储**静态字段**的数据 (JDK 8 及之后)

> 渠道包括
> - 本地文件：磁盘上的字节码文件
> - 动态代理生成：程序运行时使用动态代理生成
> - 通过网络传输的类：早期的 Applet 技术使用

2）连接阶段

分为验证、准备和解析

验证： 字节码文件是否遵守了《Java 虚拟机规范》中的约束
- 文件格式验证，
	- 比如文件是否以 `0xCAFEBABE` 开头，
	- 主次版本号是否满足当前 Java 虚拟机版本要求
- 元信息验证（字节码语义检查），
	- 例如类必须有父类 (super 不能为空)
	- 是否继承了不允许继承的类
- 字节码验证（程序语义检查），
	- 比如方法内的指令执行到一半强行跳转到其他方法中去
	- 函数的参数类型是否正确
	- 对象的类型转换是否合理
- 符号引用验证（类的正确性检查）
	- 例如是否访问了其他类中 private 的方法等

> 在生产环境的实施阶段就可以考虑使用 `-Xverify:none` 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

准备：为**静态变量** (static) 分配内存并设置初始值
- **Final** 修饰的**基本数据类型**的**静态变量**，会进行赋值
- JDK 7 及之后类变量则会随着 Class 对象一起存放在 Java 堆中

解析：将常量池中的符号引用替换为直接引用。

3）初始化阶段

> 这一步 JVM 才开始真正执行类中定义的 Java 程序代码 (字节码)

执行类构造器 `<clinit>()` 方法 
- 即字节码文件中 clinit 部分的字节码指令。Javac 编译器自动生成的
- 执行**静态代码块**中的代码，并为**静态变量**赋值

导致类的初始化的几种方式 (主动使用一个类)：
- 访问一个类的静态变量或者静态方法，
	- 注意：变量是 final 修饰的并且等号右边是常量不会触发初始化。
	- 字节码指令：
		- `getstatic` 访问类的静态变量
		- `putstatic` 给类的静态变量赋值
		- `invokestatic` 调用类的静态方法
- New 一个该类的对象时。
	- 字节码指令：`new`
- 调用 `Class.forName(String className)`
	- `java.lang.reflect` 包下的反射调用
- 执行 Main 方法的当前类
- 初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。

>补充： 
> - `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 `findStaticVarHandle` 来初始化要调用的类。
> - **「来自[issue745open in new window](https://github.com/Snailclimb/JavaGuide/issues/745 "issue745")」** 当一个接口中定义了 JDK8 新加入的默认方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

%%  %%
## 静态代码块、静态变量、普通代码块和构造方法执行顺序？

> #PDD暑期Java后端   原题是类在初始化过程中，它的静态变量，静态方法块，成员变量和构造函数的执行步骤？。面试者肯定是记错了。

- 静态方法块、静态变量（根据 Java 编写的顺序）
- 普通代码块
- 构造函数

# ---------- 类加载器

类加载器（ClassLoader）是 Java 虚拟机**提供给应用程序**去实现**获取类和接口字节码数据**的技术。

## 类加载器类型

 #PDD_Java后端研发 

JDK8
- 虚拟机底层实现 c++：
	- 启动类加载器 BootStrapClassLoader：
		- 加载 java 中**最核心**的类。
		- 没有父级
		- 默认加载  `JDK安装目录/jre/lib` 下的类文件
			- 比如 `rt.jar`，`tools.jar``resources.jar` 等 jar 包和类。
		- VM 参数扩展： `-Xbootclasspath/a:jar包目录/jar包名` 
- Java 实现：
	- 都是继承自 URLClassLoader 的静态内部类
	- 扩展类加载器 ExtensionClassLoader：
		- 允许扩展 Java 中比较通用的类
		- 默认加载 `JDK安装目录/jre/lib/ext` 下的类文件。
		- VM 参数扩展： `-Djava.ext.dirs=jar包目录[分隔符]用户jar包目录` 
	- 应用程序类加载器 AppClassLoader：
		- 加载**当前应用 classpath 下**的所有 jar 包和类（面向用户）

JDK9 引入了模块系统
- 继承关系从 URLClassLoader 变成了 **BuiltinClassLoader**，实现了从模块中加载字节码文件。
- 扩展类加载器 被替换成了 **平台类加载器（Platform Class Loader）**

## 双亲委派机制（2）

#PDD_Java后端研发 

各种类加载器之间的层次（协作）关系被称为类加载器的 双亲委派模型（Parents Delegation Model）

除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。通过成员变量 Parent 实现。

工作过程：
- 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此
	- 自底向上的查找中，如果已经加载过，就直接返回 **Class 对象**，结束
- 当所有父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

## 为什么要有双亲委派？

 #PDD_Java后端研发  

> 双亲委派模型的好处？解决了什么问题？

解决**一个类到底由谁加载**的问题。定义了三种类加载器间的配合协作来完成类加载

好处：
- 保证类加载的安全性：
	- 避免恶意代码替换 JDK 中的核心类库，比如`Java.Lang.String`，确保核心类库的完整性和安全性
- 避免同一个类被重复加载
	- JVM 区分不同类的方式不仅仅根据全限定类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。打破了双亲委派就可以加载相同全限定类名的不同类

## 破坏双亲委派的方法 （3）



## SPI 为什么打破双亲委派机制？

 #PDD_Java后端研发 


# ---------- JVM 内存区域

## JVM 内存结构

> PDD Java 后端、B站 Java 后端

## JVM 的内存模型

> B 站 Java 后端实习

## java8 和 java7内存模型差异？

> PDD Java 后端

## 栈帧作用？

> PDD Java 后端

## Jvm 运行时数据区的内容，共用/独占分别有哪些？

> PDD 服务端研发、

## 堆和栈有什么区别？

>PDD 暑期 Java 后端

# ---------- 垃圾回收

## 强引用和软引用

> PDD Java 后端

## 常见的垃圾回收算法都有哪些（1）

> 得物 Java 实习、PDD Java 后端

## 哪些对象可以作为 GC root 的根节点（1）

> PDD Java 后端


## 新生代的对象达到老年代的条件

> 新生代对象什么时候进入老年代？
> 
> PDD 服务端研发

## 哪些场景会保存到老年代 ？为什么达到15年龄就要升级？

> PDD Java 后端研发

- 大对象
- 新生代gc，存活对象达到晋升年龄
- 触发新生代担保机制，新生代回收后survivor放不下，直接放到老年代

## 常用垃圾回收器 (2)



## CMS 垃圾回收器的优缺点、执行步骤

> 小红书后端暑期实习

> CMS。PDD Java 后端


## G1 垃圾回收器介绍

> 美团到店

G 1 有哪些特点？(1)

## G 1 和 CMS 的主要区别是什么

> 小红书后端暑期实习、PDD Java 后端

