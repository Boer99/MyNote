
你在做项目过程中，有没有遇到哪些不使用类加载器的（？？？[滴滴一面二面面经 Java后端_笔经面经_牛客网 (nowcoder.com)](https://www.nowcoder.com/discuss/983772?type=0&order=7&pos=4&page=1&source_id=discuss_center_0_nctrack&channel=1009&ncTraceId=38730988c36848d1a1f097f071d1fc11.271.16594426100403233&gio_id=6E37BDC2FA182C9B5BCED98C56AAF69F-1659442610771)）

# ---------- 未知

## 内存 gc 怎么排查，有哪些工具，怎么优化的？

> PDD Java 后端研发

## 内存泄漏，如何排查？

> PDD 服务端研发

## jvm 分析工具

> PDD Java 后端研发

## 创建对象的过程

> B 站 Java 后端

## 对象的生命周期

> B 站 Java 后端

？

## 初始化的链接有什么作用？

> PDD 暑期 Java 后端

这个题没看懂？链接和连接应该是一个意思

# ---------- 类加载机制

> 类的生命周期：
> - 加载
> - 连接（验证--->准备--->解析）
> - 初始化
> - 使用
> - 卸载

## 类加载机制 #repeat

> #B站Java后端
> 
> 类是怎么加载的？ #PDD暑期Java后端

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制

主要分为三步：加载-->连接-->初始化

1）加载阶段

主要完成三件事：

- **类加载器**根据类的**全限定名**通过不同的渠道以**二进制流**的方式获取字节码信息
- 两种表述
	- 将字节流所代表的静态存储结构转换为**方法区的运行时数据结构**。
	- 将字节码中的信息保存到**方法区**中，生成一个 **InstanceKlass 对象**，保存类的所有信息
- 在堆中生成一个代表该类的 `java.Lang.Class` 对象，作为**方法区**这些数据的**访问入口**
	- 作用是在 Java 代码中去获取 **类的信息** 以及 存储**静态字段**的数据 (JDK 8 及之后)

> 渠道包括
> - 本地文件：磁盘上的字节码文件
> - 动态代理生成：程序运行时使用动态代理生成
> - 通过网络传输的类：早期的 Applet 技术使用

2）连接阶段

分为验证、准备和解析

验证： 字节码文件是否遵守了《Java 虚拟机规范》中的约束
- *文件格式验证*，
	- 比如文件是否以 `0xCAFEBABE` **开头**，
	- **主次版本号**是否满足当前 Java 虚拟机版本要求
- *元信息验证*（字节码语义检查），
	- 例如类是否有**父类** (除了 object 以外，super 不能为空)
	- 是否**继承**了不允许继承的类（final）
- *字节码验证*（程序语义检查），
	- 比如方法内的指令执行到一半**强行跳转**到其他方法中去
	- 函数的**参数**类型是否正确
	- 对象的**类型转换**是否合理
- *符号引用验证*（类的正确性检查）
	- 该类要使用的其他类、方法、字段**是否存在**、是否拥有正确的**访问权限**（是否访问了其他类中 private 的方法等）

> 在生产环境的实施阶段就可以考虑使用 `-Xverify:none` 参数来**关闭**大部分的类验证措施，以缩短虚拟机类加载的时间。

准备：为**静态变量** (static) 分配内存并设置**初始值**
- **Final** 修饰的**基本数据类型**的**静态变量**，会进行赋值

> JDK 7 及之后类变量则会随着 Class 对象一起存放在 Java 堆中

解析：将常量池中的符号引用替换为直接引用。

3）初始化阶段

> 这一步 JVM 才开始真正执行类中定义的 Java 程序代码 (字节码)

执行类构造器 `<clinit>()` 方法 
- 即字节码文件中 clinit 部分的字节码指令。Javac 编译器自动生成的
- 执行**静态代码块**中的代码，并为**静态变量**赋值

## 导致类的初始化的几种方式 #repeat 

> 主动使用一个类才会初始化类

- 访问一个类的**静态**成员
	- 字节码指令：
		- `getstatic` 访问类的静态变量
		- `putstatic` 给类的静态变量赋值
		- `invokestatic` 调用类的静态方法

> 注意：变量是 final 修饰的并且等号右边是常量不会触发初始化。

- **New** 一个该类的对象时。
	- 字节码指令：`new`
- 调用 `Class.forName(String className)`
	- `java.lang.reflect` 包下的**反射调用**
- 执行 **Main** 方法的当前类
- 初始化一个类，如果其**父类**还未初始化，则先触发该父类的初始化。
- 当一个**接口**中定义了 JDK8 新加入的**默认**方法（被 default 关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

>补充： 
> - `MethodHandle` 和 `VarHandle` 可以看作是轻量级的反射调用机制，而要想使用这 2 个调用，就必须先使用 `findStaticVarHandle` 来初始化要调用的类。

%%  %%
## 静态代码块、静态变量、普通代码块和构造方法执行顺序？ #repeat 

> #PDD暑期Java后端   原题是类在初始化过程中，它的静态变量，静态方法块，成员变量和构造函数的执行步骤？。面试者肯定是记错了。

- 静态方法块、静态变量（根据 Java 编写的顺序）
- 普通代码块
- 构造函数

# ---------- 类加载器

## 什么是类加载器？ #repeat 

类加载器（ClassLoader）是 Java 虚拟机**提供给应用程序**去实现**获取类和接口字节码数据**的技术。

## 类加载器类型 #repeat 

 #PDD_Java后端研发 

JDK8
- 虚拟机底层实现 c++：
	- *启动类加载器 BootStrapClassLoader*：
		- 加载 java 中**最核心**的类。
		- 没有父级
		- 默认加载  `JDK安装目录/jre/lib` 下的类文件
			- 比如 `rt.jar`，`tools.jar`，`resources.jar` 等 jar 包和类。
		- VM 参数扩展： `-Xbootclasspath/a:jar包目录/jar包名` 
- Java 实现：
	- 都是继承自 URLClassLoader 的静态内部类
	- *扩展类加载器 ExtensionClassLoader*：
		- 允许扩展 Java 中比较**通用**的类
		- 默认加载 `JDK安装目录/jre/lib/ext` 下的类文件。
		- VM 参数扩展： `-Djava.ext.dirs=jar包目录[分隔符]用户jar包目录` 
	- *应用程序类加载器 AppClassLoader*：
		- 加载**当前应用 classpath 下**的所有 jar 包和类（面向用户）

> `rt.jar`（runtime）是 JDK 8 非常核心的 jar 包 （包括 String，Thread 等）

JDK9 引入了模块系统
- 继承关系从 URLClassLoader 变成了 **BuiltinClassLoader**，实现了从模块中加载字节码文件。
- 扩展类加载器 被替换成了 **平台类加载器（Platform Class Loader）**

## 双亲委派机制

#PDD_Java后端研发 

> 各种类加载器之间的 **层次（协作）** 关系被称为类加载器的 双亲委派模型（Parents Delegation Model）

除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。通过成员变量 Parent 实现。

工作过程：

- 如果一个类加载器收到了类加载的请求，**自底向上检查**父类加载器是否加载过
	- 如果已经加载过，就直接返回 **Class 对象**，结束
- 所有父类都没加载过，**自顶向下加载**
	- 当所有父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。

## 为什么要有双亲委派？ #repeat 

 #PDD_Java后端研发  

> 双亲委派模型的好处？解决了什么问题？

解决**一个类到底由谁加载**的问题。定义了三种类加载器间的配合协作来完成类加载

好处：

- *保证类加载的安全性*：
	- 避免恶意代码替换 JDK 中的核心类库，比如`Java.Lang.String`，确保核心类库的完整性和安全性
- *避免同一个类被重复加载*
	- JVM 区分不同类的方式不仅仅根据全限定类名，相同的类文件被不同的类加载器加载产生的是两个不同的类。打破了双亲委派就可以加载相同全限定类名的不同类

## 破坏双亲委派的方法 (3) #repeat 

- *自定义类加载器*
	- **继承** ClassLoader，**重写** loadClass 方法，将双亲委派机制的代码去除
	- 不想破坏双亲委派机制，重写 findClass 方法
- *利用线程上下文类加载器加载类*，
	- SPI 机制打破了，例如 JDBC、JNBI
	- `Java.lang.Thread` 中的 `getContextClassLoader()` 和 `setContextClassLoader(ClassLoader cl)` 分别用来获取和设置线程的上下文类加载器
- 历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载
	- #todo

## SPI 为什么打破双亲委派机制？ #repeat 

 #PDD_Java后端研发 

Service Provider Interface, 服务提供者接口。

> 通俗得说，JDK 提供接口，供应商提供服务。编程人员编码时面向接口编程，然后 JDK 能够自动找到合适的实现

> SPI 工作原理：
>  1. 在 ClassPath 路径下的 **META-INF/services** 文件夹中，以**接口的全限定名**来命名文件名，对应的文件里面写该 **接口的实现**。
> 2. 使用 **ServiceLoader.load()** 加载实现类

> #《深入理解Java虚拟机》 
> 
> **线程上下文类加载器**去加载所需的 SPI 服务代码，这是一种“**父类加载器去请求子类加载器**”完成类加载的行为，这种行为实际上是**打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则**，
> 
> 但也是无可奈何的事情。**Java 中涉及 SPI 的加载基本上都采用这种方式来完成**，例如 JNDI、JDBC、JCE、JAXB 和 JBI 等。

**个人更倾向于没有打破！**

#Boer 父类加载器去请求（委派）子类加载器，这个说法不够准确，例如 JDBC 中 DriverManager 加载驱动，启动类加载器加载 DriverManager 类，然后 **DriverManager 的初始化阶段（静态代码块）** 触发了驱动类的加载，类的加载依然遵循双亲委派机制（应用程序类加载器还是要向上再向下）。启动类加载器没有直接地委派子类加载器

> 举个例子，DriverManager 使用 SPI 机制，最终加载 jar 包中对应的驱动类
> - **启动类加载器**加载 DriverManager。
> - 在初始化 DriverManager 时，通过 SPI 机制加载 jar 包中的 mysql 驱动。
> 	-  `ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);`
> - SPI 中利用了**线程上下文类加载器**（应用程序类加载器）去加载类并创建对象

%%  %%
# ---------- JVM 内存区域

> 如果没有特殊说明，都是针对的是 HotSpot 虚拟机。HotSpot 虚拟机才有永久代的概念

## JVM 内存结构 #repeat

#PDD_Java后端研发 #B站Java后端 #B站Java后端实习

> #PDD服务端研发 Jvm 运行时数据区的内容，共用/独占分别有哪些？

JVM 运行时数据区（JVM管理的内存）分为五个部分

 线程不共享（伴随着线程的创建而创建，线程的销毁而销毁）
- *程序计数器*
	- 字节码**解释器**通过改变程序计数器来依次读取指令，从而实现代码的**流程控制**，如：顺序执行、选择、循环、异常处理。
	- 在多线程的情况下，程序计数器用于记录**当前线程**执行的位置，从而当**线程被切换回来**的时候能够知道该线程上次运行到哪儿了
- *Java 虚拟机栈*
	- 管理方法调用中的基本数据，每一个方法的调用使用一个**栈帧**（Stack Frame）来保存
	- 栈帧：[栈帧作用？](#栈帧作用？)
	- 【VM 参数】 `-Xss`
- *本地方法栈*
	- 存储的是 **native 本地方法的栈帧**
	- 在 Hotspot 虚拟机中，Java 虚拟机栈和本地方法栈实现上使用了**同一个栈空间**。

线程共享（垃圾回收）
- *方法区*：JVM 运行时数据区域的一块逻辑区域，包含三部分：
	- *类的元信息*（InstanceKlass 对象）：包括
		- 基本信息
		- 常量池：存放**编译期**生成的各种**字面量与符号引用**
		- 字段
		- 方法
		- 虚方法表：实现多态的基础
	- *运行时常量池*，包括
		- Class 文件中的“常量池表”在**类加载后**存放到运行时常量池中
		- “符号引用”翻译出来的“**直接引用**”
		- 运行期间产生的**新的常量**
			- 例如 String 类的 `intern()` 方法
	- *字符串常量池*
		- 存储代码中定义的**常量字符串内容**
		- JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了**避免字符串的重复创建**。
	- 【VM 参数】
		- Jdk7 及之前的版本，将方法区放在堆中的永久代空间，堆的大小由 JVM 参数来控制。
		- Jdk8 及之后的版本，`-XX:MaxMetaspaceSize=值` 对元空间大小进行限制

> JDK1.7 之前，“字符串常量池”存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移到了**堆**中

- *堆*
	- 存放对象实例
	- 【VM 参数】`-Xmx` （max）和 `-Xms` （total）

> 这里堆和栈都是抽象模型，具体的组成和虚拟机的具体实现有关，见 [java8 和 java7 内存模型差异？](#java8%20和%20java7%20内存模型差异？)

## JDK 1.7 为什么要将字符串常量池移动到堆中？ #repeat

主要是因为**永久代（方法区实现）的 GC 回收效率太低**，只有在**整堆收集 (Full GC)的时候才会被执行 GC**。

Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。

## 栈帧作用？ #repeat

#PDD_Java后端研发  

栈帧的组成：
- *局部变量表*：在运行过程中存放方法所有的局部变量，包括
	- 实例方法的 this 对象
	- 方法的参数
	- 方法体中声明的局部变量

> **编译**成字节码文件时就可以确定“局部变量表”的内容

- *操作数栈*：虚拟机在执行指令过程中用来**存放中间数据**的一块区域（比如临时变量）

> **编译**期即可决定“操作数栈”最大深度

- *帧数据*：
	- *动态链接*：保存了“符号引用”到“运行时常量池”的内存地址的**映射关系**
	- *方法出口*：方法在正确或者异常结束时，当前栈帧会被**弹出**，同时程序计数器应该指向**上一个栈帧中的下一条指令的地址**
	- *异常表*：存放的是代码中异常的处理信息，包含了
		- 异常捕获的生效**范围**
		- 异常发生后**跳转**到的字节码指令位置。

## 哪些区域会发生内存溢出 #repeat

线程不共享
- *程序计数器*：唯一一个**不会出现** `OutOfMemoryError` 的内存区域
- *Java 虚拟机栈*
	- 如果栈的内存大小**不允许**动态扩展，当线程请求栈的**深度**超过当前 Java 虚拟机栈的最大深度的时候，抛出 `StackOverflowError` 错误
	- 如果栈的内存大小**可以**动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出 `OutOfMemoryError` 异常
- *本地方法栈*：同 Java 虚拟机栈

线程共享
- *方法区*：元空间溢出时会得到 `java.lang.OutOfMemoryError: MetaSpace`
- *堆*：		
	- `java.lang.OutOfMemoryError: Java heap space`：假如在创建新的对象时，堆内存中的空间不足以存放新创建的对象, 就会引发此错误。
	- `java.lang.OutOfMemoryError: GC Overhead Limit Exceeded`：当 JVM 花太多时间执行 gc 并且只能回收很少的堆空间时，就会发生此错误

## java8 和 java7 内存结构差异？ #repeat

#PDD_Java后端研发 

“永久代（PermGen） ---> 元空间（MetaSpace）”

永久代是 JDK 1.8 之前的方法区实现

> JDK6 开始 HotSpot 开发团队就计划放弃永久代，采用本地内存实现方法区

JDK 7 的 HotSpot，把原本放在永久代的**字符串常量池**、**静态变量**等移出

- 堆
	- 新生代、老年代
	- 字符串常量池（具体位置不详）
	- class 对象（具体位置不详）
		- 静态变量
	- 永久代
		- 类的元信息
		- 运行时常量池

> 静态变量存储在哪里？
> 
> - JDK 6 之前存储在方法区，即永久代
> - JDK 7 及之后，存储在堆中的 Class 对象

JDK 8 完全**废弃了永久代**的概念，改用与 JRockit、J9 一样在本地内存中实现的**元空间**（Metaspace）来代替

- 堆
	- 新生代、老年代
	- class 对象（具体位置不详）
		- 静态变量
	- 字符串常量池（具体位置不详）
- 元空间（本地内存）
	- 类的元信息
	- 运行时常量池

### 为什么要将永久代替换为元空间呢? #repeat

1）永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是**本地内存**，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

元空间里面存放的是类的元数据，==能加载的类就更多了==

> 2）在 JDK8，合并 HotSpot 和 JRockit 的代码时，JRockit 从来没有一个叫永久代的东西，合并之后就没有必要额外的设置这么一个永久代的地方了。

## 堆和栈有什么区别？ #repeat

#PDD暑期Java后端

|  | 存储内容 | 功能 | 存取速度 | 线程共享 | 需要垃圾回收 |
| ---- | ---- | ---- | ---- | ---- | ---- |
| 栈 | 主要存放基本类型的变量和对象的引用变量。 | 执行程序 | 快 | 否 | 否 |
| 堆 | 主要存放创建的对象实例 | 存放对象 | 动态分配内存，较慢 | 是 | 是 |

> 栈帧中的局部变量表（数组）大小、操作数栈的深度在编译时就确定了。

# ---------- 垃圾回收

## 如何判断一个类是无用的类？ #repeat 

**方法区**主要回收的是无用的类

判定一个类可以被**卸载**。需要同时满足下面三个条件：

- 该类所有的对象都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 `ClassLoader` 已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

##  死亡对象判断方法 #repeat

*引用计数法*：引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

- 优点：实现简单
- 缺点：
    - 存在**循环引用**问题（当A引用B，B同时引用A时会出现对象无法回收的问题）

*可达性分析算法*：如果从某个对象到 **GC Root** 对象是可达的，对象就不可被回收

### 哪些对象可以作为 GC root (1) #repeat

#PDD_Java后端研发 

- 虚拟机栈(栈帧中的局部变量表)中引用的对象
	- 参数、局部变量、临时变量
- 本地方法栈(Native 方法)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
	- 字符串常量池里的引用
- 所有被同步锁持有的对象

> 两栈两区一锁

### 如何判断一个常量是废弃常量？

假如在字符串常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池了。



## 强软弱虚 #todo

> 强引用和软引用 #PDD_Java后端研发  

强引用：强引用对象不会被垃圾回收器回收，JVM 抛出 OutOfMemoryError 错误也不会被回收

软引用：**当程序内存不足时**，垃圾回收器会将软引用对象回收。

- 常用于实现缓存
- JDK 1.2 版之后提供了 **`java.lang.ref.SoftReference`** 来实现软引用。
	- 将对象使用软引用包装起来，`new SoftReference<对象类型>(对象)`
	- 继承 SoftReference 类，构造器传入包含的对象和引用队列
- `SoftReference` 对象本身的回收，队列机制：
	- 软引用创建时，通过构造器传入引用队列
	- 软引用中**包含的对象被回收时**，该软引用对象会被**放入引用队列** `ReferenceQueue`
	- 遍历引用队列，将 SoftReference 的强引用删除

弱引用：**不管内存够不够**都会直接被回收

- WeakReference 类来实现弱引用
- 主要在 **ThreadLocal** 中使用
- 本身也是通过**引用队列**回收

虚引用：**不能**通过虚引用对象获取到包含的对象。

- 唯一的用途：当对象被垃圾回收器回收时可以接收到对应的通知（跟踪对象被垃圾回收的活动）
- 必须和引用队列（ReferenceQueue）联合使用

## 常见的垃圾回收算法都有哪些（1） #repeat 

> #得物Java实习 #PDD_Java后端研发 

1）*“标记-清除”算法*：“标记阶段”标记不需要回收的对象，“回收阶段”从内存中删除没有被标记的对象
- 缺点：
	- 效率问题：标记和清除两个过程效率都不高
	- 空间问题：大量不连续的**内存碎片**
		- 大对象没有连续的内存分配，触发 gc
		- 空闲链表，分配速度慢

2）*“复制”算法*：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还==存活着的对象复制==到另一块上面，再把已使用过的那块内存空间一次清理掉
- 优点：没有内存碎片
- 缺点：
	- 多数对象都是存活的，复制开销大
		- 不适合永久代
	- 内存利用率低
-适合“年轻代”这种 **gc 频率很高**的场景，不需要按照 1:1 的比例划分内存空间

3）*“标记-整理”算法*：标记阶段和“标记-清除”一致，清除阶段让==存活对象移动到内存空间的一端==，然后直接清理掉边界以外的内存、
- 优点：
	- 在“标记-清除”的基础上解决了内存碎片
	- 内存效率也高
- 缺点：
	- 整理效率不高
- 适合“老年代”这种 **gc 频率不是很高**的场景

4）“*分代收集”算法*：根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代（存活率低）和老年代（存活率高）。可以根据各个年代的特点选择合适的垃圾收集算法。

针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种
- *部分收集* (Partial GC)：
	- *新生代收集*（Minor GC / Young GC）：只对新生代进行垃圾收集；
	- *老年代收集*（Major GC / Old GC）：只对老年代进行垃圾收集。
		- 需要注意的是 Major GC 在有的语境中也用于指代整堆收集；
	- *混合收集*（Mixed GC）：对整个新生代和**部分**老年代进行垃圾收集。
- *整堆收集* (Full GC)：收集整个 Java **堆**和**方法区**

## 哪些场景会保存到老年代 ？ #repeat 

#PDD服务端研发 #PDD_Java后端研发  

> 相似问法：
> - 新生代对象什么时候进入老年代？
> - 新生代的对象达到老年代的条件？
> - 哪些场景会保存到老年代 ？为什么达到15年龄就要升级？

大对象直接进入老年代

> 大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。

- 旨在避免将大对象放入新生代，从而减少新生代的垃圾回收频率和成本（避免大对象在 Eden 区及两个 Survivor 区之间来回复制）

> 大对象直接进入老年代的行为是由虚拟机**动态决定**的
> 
> - HotSpot 虚拟机提供了 #VM参数 `-XX:PretenureSizeThreshold` （只对 Serial 和 ParNew 两款新生代收集器有效），指定大于该设置值的对象直接在老年代分配
> - #todo G1 垃圾回收器会根据 `-XX:G1HeapRegionSize` 参数设置的堆区域大小和 `-XX:G1MixedGCLiveThresholdPercent` 参数设置的阈值，来决定哪些对象会直接进入老年代。
> - #todo Parallel Scavenge 垃圾回收器中，默认情况下，并没有一个固定的阈值(`XX:ThresholdTolerance`是动态调整的)来决定何时直接在老年代分配大对象。而是由虚拟机根据当前的堆内存情况和历史数据动态决定。

年龄达到阈值（默认值和具体垃圾回收器有关）
- 对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1。
- 每经过一次 minor gc 存活，年龄+1
- 对象年龄达到阈值，晋升到老年代。
	- #VM参数 `-XX:MaxTenuringThreshold=<age>` 设置年龄阈值。

## 常用垃圾回收器 (2) #repeat

> 其他问法
> - CMS 垃圾回收器的优缺点、执行步骤 #小红书后端暑期实习 #PDD_Java后端研发 
> - G1 垃圾回收器介绍 #美团到店

> 注意：
> 
> 1）整理思路按照 JDK 9 之后还保留的“年轻代”+“老年代”组合
> 
> 2）不论哪种算法都会有 一段时间 STW

1）Serial 和 SerialOld

- 单线程串行回收（只有一条垃圾回收线程，且回收时 STW）
- “复制”+“标记-整理”
- *优点*：**单 CPU** 处理器下吞吐量非常出色（没有线程交互开销）
- *缺点*：**多 CPU** 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于**长时间的等待**
- *适用场景*：Java 编写的**客户端程序**或者**硬件配置有限**的场景

---

2）ParNew 和 CMS（JDK9 开始就提示未来会被废弃，被 G1替代）

ParNew 就是 Serial 的多线程版本，**多线程并行**回收年轻代（用户线程 STW）
- “复制”算法

![400](assets/Pasted%20image%2020240125151027.png)

CMS

- *特点*：**并发**收集、低停顿
- “标记-清除”
- *执行步骤*：
	- 初始标记（STW）：用极短的时间标记出 **GC Roots 能直接关联到的对象**。
	- 并发标记：标记所有的对象
	- 重新标记（STW）：修正“并发标记”阶段变动的对象
	- 并发清理：由于==不需要移动存活对象==，gc 线程可以与用户线程并发执行。
- *优点*：暂停时间短（两次标记），用户体验好
- *缺点*：
	- **内存碎片**，Full GC 时进行碎片的整理
		- #VM参数  `-XX:CMSFullGCsBeforeCompaction=<N>` （默认0）调整 N 次 Full GC 之后再整理。
	- 无法处理在“并发清理”过程中产生的 “**浮动垃圾**”
	- 对处理器资源非常敏感。
		- 并发设计程序通病，处理器核心数<=4 个，CMS 对用户程序的影响就可能变得很大
- *适用场景*：大型的互联网系统中**用户请求数据量大、频率高的场景**比如订单接口、商品接口等

![500](assets/Pasted%20image%2020240125161108.png)

> 并发清理：清理的对象肯定不能被用户线程访问，但是存活对象不收影响

---

3）Parallel Scavenge 和 Parallel Old

- **JDK8 默认**的垃圾回收器，**多线程并行**回收
- *特点 / 年轻代回收和 ParNew的不同之处*：
	- 关注的是系统的“**吞吐量**”
	- 自动调整堆内存大小。
- “复制”+“标记-整理”
- *优点*：
	- 吞吐量高，而且手动可控
		- #VM参数 `-XX:GCTimeRatio=<n>` 设置吞吐量为 n
		- #VM参数`-XX:MaxGCPauseMillis=<n>` 设置“最大暂停时间”
	- 为了高吞吐量，虚拟机会动态调整堆的参数
		- #VM参数`-XX:+UseAdaptiveSizePolicy` 让垃圾回收器根据“吞吐量”和“最大暂停时间”==自动调整内存大小==
- *缺点*：不能保证**单次的停顿时间**
- *适用场景*：**后台任务**，不需要与用户交互，并且**容易产生大量的对象**。比如：大数据的处理，大文件导出

![](assets/Pasted%20image%2020240202023447.png)

---

4）G1

- JDK9 之后默认
- *特点*：
	- 使用 Region **划分内存空间**并作为**单次回收的最小单元**
		- Humongous Region 存储大对象（容量超过 Region 一半的对象）。作为老年代的一部分
		- #VM参数 `-XX:G1HeapRegionSize=<size>[unit]` 手动指定 Region size，必须是 2 的指数幂，取值范围从 1M 到 32M。
	- *可预测的停顿*：这是 G1 相对于 CMS 的一个大优势，支持指定一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间大概率不超过 N 毫秒。
		- #VM参数 `-XX:MaxGCPauseMillis=<n>`（默认 200） 设置**每次**垃圾回收时的“最大暂停时间”毫秒数（Parallel 就有）
		- 每次垃圾回收会记录 Region 回收的**平均耗时**，根据配置的“最大暂停时间”计算出本次回收最多回收多少个 Region
	- *具有优先级的区域回收方式*：优先回收价值收益最大的 Region
		- G1 会跟踪各个 Region 里面的垃圾堆积的“价值”大小，价值即**回收所获得的空间大小**以及**回收所需时间**的经验值，然后在后台维护一个**优先级列表**
- *回收算法*：局部“标记-复制”（region 和 region 之间），总体“标记-整理”
- *优点*：
	- 延迟可控
	- 无内存碎片
	- 并发标记的 SATB 算法效率高（ #todo扩展 不懂就不说了）
- *缺点*：
	- 要耗费大约相当于 Java 堆容量 10%至 20%的额外内存来维持收集器工作
	- JDK 8 之前还不够成熟
- *适用场景*：面向服务器，配备多颗处理器及大容量内存的机器

G1的垃圾回收方式
- Young GC：
	- *触发时机*：G1 判断年轻代区不足（max 默认 60%，年轻代占堆的 60%）
	- 执行流程：
		- 标记出 **Eden 和 Survivor** 区域中的存活对象，
		- **选择某些 Region**（可预测停顿） 将存活对象**复制**到一个新的 Survivor 区中（年龄+1），**清空**这些区域。
		- 后续 Young GC 时与之前相同，只不过 Survivor 区中存活对象会被搬运到另一个 Survivor 区。
		- 当某个存活对象的年龄到达**阈值**（默认 15），将被放入老年代
- Mixed GC 
	- *触发时机*：总堆占有率达到阈值（可设置，默认 45%）
	- *执行流程*：
		- *初始标记*：标记 GC Roots 能直接关联到的对象，**STW**
		- *并发标记*：将第一步中标记的对象引用的对象，标记为存活
		- *最终标记*：标记一些引用改变、漏标的对象，**STW**
		- *筛选回收*：根据各个 Region 的回收价值和成本，以及用户所期望的停顿时间，选择 Region 回收，**STW**
	- *回收区域*：所有年轻代、部分老年代、大对象区（老年代）
- Full GC
	- *触发时机*：没有足够的空 Region 存放转移的对象
	- 标记-整理算法

5）ZGC

#todo扩展

## G1 和 CMS 的主要区别是什么？ #repeat

#小红书后端暑期实习 #PDD_Java后端研发 

优势：
- G1 可以可以指定每次 gc“最大停顿时间”
- 创新性设计：
	- 分 Region 的内存布局
	- 按收益动态确定回收集等
	- Humongous Region 存储大对象
- 无内存碎片：与 CMS 的“标记-清除”算法不同，G1 局部“标记-复制”、总体“标记-整理”

劣势：
- G1 无论是为了**垃圾收集产生的内存占用**（Footprint） 还是程序运行时的**额外执行负载**（Overload）都要比 CMS 要高。

在小内存应用上 CMS 的表现大概率仍然要会优于 G1，而在大内存应用上 G1 则大多能发挥其优势

#todo完善

# ---------- 内存泄露

怎么看堆区内存泄漏，栈溢出呢 #携程

