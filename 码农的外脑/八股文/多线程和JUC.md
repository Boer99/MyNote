# ---------- 多线程基础
## 进程和线程

“进程”是**程序的一次执行过程**，是系统运行程序的基本单位，因此进程是动态的。
- 系统运行一个程序即是一个进程从创建，运行到消亡的过程。
- 在 Java 中，启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称**主线程**。

线程与进程相似，操作系统进行调度的基本单元。线程也被称为“**轻量级进程**”

线程与进程不同的是，
- 一个进程在其执行的过程中可以产生多个线程。
- 是一个比进程更小的**执行单位**
- 线程执行开销小，但不利于资源的管理和保护；而进程正相反。
	- 系统在**产生一个线程**，或是在**各个线程之间作切换工作**时，负担要比进程小得多，
- 同类的多个线程**共享**进程的“堆”和“方法区”资源，但每个线程有自己的“程序计数器”、“虚拟机栈”和“本地方法栈”。
- 各进程是**独立**的，同一进程中的线程极有可能会**相互影响**

> 【拓展】
> 
> 程序计数器为什么是线程私有的?
> - 线程切换后能恢复到正确的执行位置
> 
> 虚拟机栈和本地方法栈为什么是线程私有的?
> - 保证线程中的局部变量不被别的线程访问到


Java 程序天生就是多线程程序

> JMX 查看一个普通的 Java 程序有哪些线程
> 
> ```java
> public class MultiThread {
> 	public static void main(String[] args) {
> 		// 获取 Java 线程管理 MXBean
> 	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
> 		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
> 		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
> 		// 遍历线程信息，仅打印线程 ID 和线程名称信息
> 		for (ThreadInfo threadInfo : threadInfos) {
> 			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
> 		}
> 	}
> }
> ```
> 
> 上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：
> 
> ```
> [5] Attach Listener //添加事件
> [4] Signal Dispatcher // 分发处理给 JVM 信号的线程
> [3] Finalizer //调用对象 finalize 方法的线程
> [2] Reference Handler //清除 reference 线程
> [1] main //main 线程,程序入口
> ```
> 
> 从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行

%%  %%
## Java 线程和 os 里的线程的区别是什么？(2)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB)

**现在的 Java 线程的本质其实就是操作系统的线程。**

JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种**用户级线程**（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。

在 JDK 1.2 及以后，Java 线程改为**基于“原生线程”（Native Threads）实现**，也就是说 JVM 直接使用**操作系统原生的内核级线程**（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

> 【提示】
> 
> 绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核）
> 
> 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

在 **Windows** 和 **Linux** 等主流操作系统中，Java 线程采用的是 **“一对一”的线程模型**，也就是一个 Java 线程对应一个系统内核线程。

> **Solaris** 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持**多对多**和**一对一**。具体可以参考 R 大的回答: [JVM 中的线程模型是用户级的么？open in new window](https://www.zhihu.com/question/23096638/answer/29617153)。

> 虚拟线程在 **JDK 21** 顺利转正，关于虚拟线程、平台线程（也就是我们上面提到的 Java 线程）和内核线程三者的关系可以参考：[Java 20 新特性概览](/java/new-features/java20.html)。

## 并发 和 并行

#字节_23_秋招_Java  

并发：
- 是在**同一实体**上的多个事件,
- 是在同一台处理器上的**同一时间段**内处理多个任务，
- 同一时刻，其实是只有一个事件在发生。

并行：
- 是在**不同实体**上的多个事件，
- 是在多台处理器上“**同时**”处理多个任务，
- 同一时刻，大家都真的在做事情，你做你的，我做我的

## 同步 和 异步

- 同步：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- 异步：调用在发出之后，不用等待返回结果，该调用直接返回。

## 真正使用时，Java 里的线程和进程是如何调度？(1)


## Java 线程的生命周期(1)



## 线程的状态？线程状态的转换？

#B站SRE_Java后端 

> 其他问法：
> - 有实战监控过吗？(1)

>进程有哪些状态？有一个问过，忘了哪个了


## 多线程的底层实现原理(1)


## 线程创建方式(1)





## sleep 和 wait 区别?

#PDD_23_秋招_后端



## java怎么处理多线程并发的问题？

#PDD_暑期实习_后端 


## 同步与互斥，互斥和同步在时间上有要求吗？

> 貌似是操作系统

#PDD_服务端研发

互斥和同步在时间上有要求吗（我回答前者没有，后者有）

操作系统内核对象实现同步与互斥（复盘搜了一下：互斥锁、信号量、事件对象、条件变量、命名管道）

死锁的条件（互斥条件、请求保持条件、不可抢占条件、循环等待条件）



# ---------- 多线程业务和场景

## 平时怎么用多线程？遇到的多线程问题怎么解决？(1)

## 3个线程交替打印1-100伪代码，则么让main线程等待这三个线程执行完再执行？(1)


# ---------- 线程池

## 线程池创建方法

#得物_训练营_Java

## 线程池的常见配置?

#B站Java后端23_秋招 

## 假如现在有 15 个任务 5个核心线程 最大线程是10 工作队列是5 请问执行顺序是怎样的？

#B站Java后端23_秋招 

## 线程池有哪些（核心）参数？

#PDD_23_秋招_基础电商_后端 #PDD_23_秋招_后端 #字节_国际电商_23_秋招_Java

> 核心线程数、最大线程数、最大线程数过期时间、阻塞队列、线程工厂、拒绝策略
> 
> 线程池大小如何设置(2)
> 
> 拒绝策略 #顺丰_22_秋招_Java 

## 怎么 保证/确定（核心）线程数的？

#PDD_23_秋招_后端

> 核心线程数不够会怎么处理？(1)

## 如果针对业务场景设计线程池参数应该根据哪些？(1)



## 线程池工作流程？

#得物_训练营_Java #字节_国际电商_23_秋招_Java

> 线程池没有新任务进来，线程池会如何变化？ #得物_训练营_Java 

## 什么时候用到线程池？

#得物_训练营_Java 

> 怎么用线程池，应用场景(1)
> 
> 线程池在项目中是做什么的？(1)
> 
> 你平常用哪个线程池，和别的有什么区别？ #字节_国际电商_23_秋招_Java

## 在线程池中多个线程的结果是如何去合并的，说出两种解决方式(1)


## 线程池是怎么实现线程的保活和停止管理的？(1)

答：不是很理解面试官的意思，沉默了几分钟说了一下shutdown()、shutdownNow()以及awaitTermination()三种方法的使用，面试官没有反驳，点了点头，估计瞎猫碰上死耗子了

## 线程池设置2个核心线程数，4个最大线程数，什么时候用核心线程数，什么时候用最大线程数？(1)


## 线程池是使用的自己实现的线程池吗？(1)


## 线程池中提交任务想要得到运行结果怎么办，其原理是什么(1)


## schedule 线程池原理(1)


## fixed, single, cache 线程池原理(1)


## 自定义线程池需要重写什么(1)


## 线程池核心部分和原理(1)


## 线程池新增任务的执行流程是怎么样的(1)


# ---------- 多线程集合
## java 中线程安全的类有哪些？(1) 

> map、set、list中哪些是线程安全的？(1)
> 
> HashTable为什么线程安全 #小红书_实习_后端

## List、Map 要使用线程安全要怎么办？

#得物_后端

## ConcurrentHashMap 原理(1)

#PDD_服务端研发

> ConcurrentHashMap1.7 和 1.8线程安全怎么做的？ #小红书_实习_后端
> 
> HashMap 和 ConcurrentHashMap 的对比和区别 #顺丰_23_秋招_Java 
> 
> ConcurrentHashMap 是通过什么手段保证（怎么实现）线程安全的？ #顺丰_23_秋招_Java  #字节_飞书_24_实习_Java #字节_商业化_23_秋招_Java 
> 
> 底层结构？ #字节_飞书_24_实习_Java 

## ConcurrentHashMap 和 HashTable 有什么区别？

#得物_后端



# ---------- 线程通信
## 线程通信的方式有哪些？

#字节_24_实习_Java 

> 大概的原理？(2)





# ---------- JUC

## 介绍下 synchronized 关键字

#得物_实习_Java

> - synchronized怎么去使用，有哪几种用法？ #PDD_暑期实习_后端 
> - JDK1.8里的 sychronized 锁是锁的哪里？ #小红书_实习_后端 
> - synchronized 加在普通方法上和静态方法上有什么区别？ #PDD_暑期实习_后端 #字节_23_秋招_Java 
> - 加在 final 修饰的方法上 #字节_23_秋招_Java 
> - syn 锁对象和锁类 #PDD_暑期实习_后端 
> - 底层原理？ #字节_23_秋招_Java 
> - synchronized 是如何用字节码表达的？虚拟机是怎么支持它的？ #小红书_23_秋招_后端
> - 为什么 Sychronized 效率高？ #小红书_23_秋招_后端
> - synchronized 关联的 monitor 信息存储在哪？ #得物_实习_Java
> - synchronized 上锁解锁流程 #字节_商业化_23_秋招_Java 
> - synchronized 为什么设计为可重入锁？ #字节_商业化_23_秋招_Java 

  
## java里有哪几种上锁方式，了解他们的区别吗？

#pdd_暑期实习_后端 

## 死锁

> 什么是死锁？ #小红书_23_秋招_后端 #字节_商业化_24_Java 
> 
> 死锁的必要（产生）条件 #顺丰_22_秋招_Java #字节_商业化_24_Java  #字节_国际电商_23_秋招_Java 构造一个场景 #字节_国际电商_23_秋招_Java 
> 
> 代码模拟死锁，要百分之百会出现死锁（while+yield），而不是偶现 #小红书_23_秋招_后端
> 
> 怎么解决死锁？ #字节_国际电商_23_秋招_Java 
> 
> 如何预防（避免）死锁的发生？(2) #顺丰_22_秋招_Java  #字节_国际电商_23_秋招_Java 
> 
> 发生死锁怎么排查？(2)
> 
> 多线程的同步互斥的方法？答了信号量，问具体怎么实现，答 pv 操作，给了具体的场景，问变量如何初始化(等同于口述代码)

  
## 乐观锁

> 两个用户修改数据，怎么防止另一个用户负载上一个用户的修改？ #PDD_23_秋招_基础电商_后端 
> - 加上版本号，或者把原来的状态放到条件里。
> 
> 乐观锁实现方式（版本号、CAS） #顺丰_23_秋招_Java 
> 
> 乐观锁与悲观锁 #顺丰_22_秋招_Java  #字节_飞书_24_实习_Java 

## 公平锁 和 非公平锁

#PDD_23_秋招_后端 #小红书_23_秋招_后端

## lock 底层原理(1)

#得物_训练营_Java 

> Lock底层实现？

  
## ReentrantLock

> 可重入锁是什么，可重入的底层是如何实现的？ #得物_训练营_Java 
> 
> reentrantlock原理 #得物_训练营_Java 
> 
> synchronized 和 ReentrantLock 区别？ #PDD_服务端研发 #小红书_23_秋招_后端
> 
> Sychronized 和 ReetrantLock 哪个性能好些？ #小红书_23_秋招_后端

  
## Future 获得结果怎么处理？

#B站SRE_Java后端 

## CountDownlaunch 使用场景和原理

#得物_训练营_Java 

## 介绍一下 java 内存模型 JMM

#得物_实习_Java #顺丰_23_秋招_Java #字节_24_实习_Java 

> 共享变量的副本是存储在jvm哪里的？ #得物_实习_Java

  
## 说一下 volatile 关键字

#B站Java后端23_秋招 #得物_实习_Java

> 类似问题：
> 
> volatile可以保证线程安全吗？ #B站Java后端23_秋招 

  
## CAS

> 操作系统层面，CAS 操作是怎么做的？ #B站cdn_服务端开发
> 
> 原理？ #PDD_23_秋招_后端
> 
> CAS底层怎么实现？ #字节_飞书_24_实习_Java
> 
> ABA如何解决？ #PDD_23_秋招_后端  #顺丰_22_秋招_Java 
> 
> CAS 的优缺点是什么？ #PDD_服务端研发 #PDD_23_秋招_基础电商_后端
> 
> 超卖的 cas，cas 的逻辑是什么? #PDD_服务端研发
> 
> cas 和普通的锁的区别，什么时候用 cas 什么时候用到锁 #PDD_服务端研发
> 
> 项目里的乐观锁怎么实现的？ #字节_飞书_24_实习_Java



## 说一下 ThreadLocal

#B站Java后端23_秋招 #B站后端日常实习 

> 其他问法：
> 
> - ThreadLocal 是什么, 怎么使用的？ #PDD_服务端研发
> - 可能会有哪些问题？ #PDD_服务端研发 #PDD_23_秋招_基础电商_后端 
> - 怎么避免内存泄漏？ #PDD_服务端研发
> - 底层怎么优化的？ #PDD_服务端研发
> - key是弱引用，可以为null，那么value呢？ #PDD_服务端研发
> - 用 ThreadLocal 有什么好处？ #PDD_服务端研发
> - 主线程的 ThreadLocal 如何向子线程的 ThreadLocal 传递数据？(1)
> - 如何实现多个线程修改同一个变量，互不影响？ #PDD_23_秋招_基础电商_后端 

  
## synchronized的锁优化(1)

> 锁优化机制 #PDD_23_秋招_后端 

- 锁的升级
- 偏向锁
- 轻量级锁
- 自旋锁

## AQS 原理

#PDD_23_秋招_后端 

(讲了讲 clh 锁，拿 reentrantlock 举了个例子)(1)
 

## JUC 工具类用过哪些？

#B站SRE_Java后端  #字节_飞书_24_实习_Java 



# ---------- 未知
## 多线程事务失效(1)

## Spring多线程支持(1)

## 救急线程是什么时候过期的？

## 协程和线程区别，对应关系

#pdd_暑期实习_后端