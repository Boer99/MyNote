# 多线程基础
## 进程、线程区别 (2+)

> 进程

进程是==程序的一次执行过程==，是==系统运行程序的基本单位==，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。

在 Java 中，当我们==启动 main 函数时其实就是启动了一个 JVM 的进程==，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。

> 线程

线程与进程相似，但==线程是一个比进程更小的执行单位==。一个进程在其执行的过程中可以产生多个线程。

与进程不同的是，同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为**轻量级进程**。

> Java 程序天生就是多线程程序

我们可以通过 JMX 来看看一个普通的 Java 程序有哪些线程，代码如下。

```java
public class MultiThread {
	public static void main(String[] args) {
		// 获取 Java 线程管理 MXBean
	ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
		// 遍历线程信息，仅打印线程 ID 和线程名称信息
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
		}
	}
}
```

上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：

```
[5] Attach Listener //添加事件
[4] Signal Dispatcher // 分发处理给 JVM 信号的线程
[3] Finalizer //调用对象 finalize 方法的线程
[2] Reference Handler //清除 reference 线程
[1] main //main 线程,程序入口
```

从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行

## Java 线程和 os 里的线程的区别是什么？(2)

[Java并发常见面试题总结（上） | JavaGuide](https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html#java-%E7%BA%BF%E7%A8%8B%E5%92%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB)

JDK 1.2 之前，Java 线程是基于绿色线程（Green Threads）实现的，这是一种用户级线程（用户线程），也就是说 JVM 自己模拟了多线程的运行，而不依赖于操作系统。

> 【提示】
> 
> 绿色线程和原生线程比起来在使用时有一些限制（比如绿色线程不能直接使用操作系统提供的功能如异步 I/O、只能在一个内核线程上运行无法利用多核）
> 
> 用户线程创建和切换成本低，但不可以利用多核。内核态线程，创建和切换成本高，可以利用多核。

==在 JDK 1.2 及以后，Java 线程改为基于原生线程（Native Threads）实现==，也就是说 JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。

一句话概括 Java 线程和操作系统线程的关系：==现在的 Java 线程的本质其实就是操作系统的线程。==

>【提示】

在 **Windows** 和 **Linux** 等主流操作系统中，Java 线程采用的是**一对一**的线程模型，也就是一个 Java 线程对应一个系统内核线程。**Solaris** 系统是一个特例（Solaris 系统本身就支持多对多的线程模型），HotSpot VM 在 Solaris 上支持**多对多**和**一对一**。具体可以参考 R 大的回答: [JVM 中的线程模型是用户级的么？open in new window](https://www.zhihu.com/question/23096638/answer/29617153)。

虚拟线程在 **JDK 21** 顺利转正，关于虚拟线程、平台线程（也就是我们上面提到的 Java 线程）和内核线程三者的关系可以参考：[Java 20 新特性概览](/java/new-features/java20.html)。

## 真正使用时，Java里的线程和进程是如何调度？()

## Java 线程的生命周期(1)

## 线程和进程有哪些状态，线程状态及其切换？(2+)有实战监控过吗(1)

> 进程状态只有一个问过

## 多线程的底层实现原理(1)
## 线程创建方式(1)


# 多线程业务和场景

## 平时怎么用多线程？遇到的多线程问题怎么解决？(1)

## 3个线程交替打印1-100伪代码，则么让main线程等待这三个线程执行完再执行？(1)


# 线程池
## 多线程是怎么保证核心线程数的(1)
## 自定义线程池的核心参数有哪些(2+)线程池大小如何设置(2)怎么用线程池，应用场景(1)线程池在项目中是做什么的？(1)如果针对业务场景设计线程池参数应该根据哪些？(1)

## 在线程池中多个线程的结果是如何去合并的，说出两种解决方式(1)

## 线程池是怎么实现线程的保活和停止管理的？(1)

答：不是很理解面试官的意思，沉默了几分钟说了一下shutdown()、shutdownNow()以及awaitTermination()三种方法的使用，面试官没有反驳，点了点头，估计瞎猫碰上死耗子了

## 线程池设置2个核心线程数，4个最大线程数，什么时候用核心线程数，什么时候用最大线程数？(1)

## 核心线程数不够会怎么处理？(1)

## 线程池是使用的自己实现的线程池吗？(1)

## 线程池中提交任务想要得到运行结果怎么办，其原理是什么(1)

## schedule线程池原理(1)

## fixed,single,cache线程池原理(1)

## 自定义线程池需要重写什么(1)

## 线程池核心部分和原理(1)

## 线程池新增任务的执行流程是怎么样的(1)


# 线程同步
## synchronized 关键字了解吗，synchronized 加在普通方法上和静态方法上有什么区别？(1)

## syn锁对象和锁类 (1)

## 如何预防(避免)死锁的发生？(2)

## 发生死锁怎么排查？(2)

## 多线程的同步互斥的方法？答了信号量，问具体怎么实现，答pv操作，给了具体的场景，问变量如何初始化(等同于口述代码)


# 多线程集合
## java中线程安全的类有哪些？(1)map、set、list中哪些是线程安全的？(1)

## ConcurrentHashMap原理(1)


# 线程通信
## 线程通信的方式有哪些，大概的原理？(2)


# 多线程未知
## 多线程事务失效(1)

## Spring多线程支持(1)

## 救急线程是什么时候过期的？

## 协程，和线程区别(2+)


# JUC
## lock底层实现(1)

## aqs原理(讲了讲clh锁，拿reentrantlock举了个例子)(1)

## CAS的缺点是什么？(1)

## synchronized的锁优化(1)

- 锁的升级
- 偏向锁
- 轻量级锁
- 自旋锁
## ThreadLocal是什么, 怎么使用的, 主线程的ThreadLocal如何向子线程的ThreadLocal传递数据(1)

