# ---------- SQL 语句

## DQL 执行顺序

![](assets/Pasted%20image%2020240325003959.png)

```SQL
FROM 表名列表

WHERE 条件列表

GROUP BY 分组字段列表

HAVING 分组后条件列表

SELECT 字段列表

ORDER BY 排序字段列表

LIMIT 分页参数
```

## 面试题

### 求每个学科 score 最高的学生

查出每科最高分或者最低分

```sql
SELECT subject,max(score) FROM student1 GROUP BY subject
```

想要知道每科最高分是谁，加上 name 不就能得到这个数据了吗？没那么简单，下面的语句执行会报错。

```sql
SELECT subject,max(score),name FROM student1 GROUP BY subject
```

GROUP BY 能用在想要**分组的列名**前，或者结合**聚合函数**出现。name 是个单独的列名，不符合前述条件，所以这么查是不对的。

最高分和最低分

```sql
SELECT "最高分",student1.*  
FROM student1,(SELECT MAX(score) AS score,subject FROM student1 GROUP BY subject) b  
WHERE student1.`score` = b.score  
AND student1.`subject` = b.subject 

UNION

SELECT "最低分",student1.*  
FROM student1,(SELECT MIN(score) AS score,subject FROM student1 GROUP BY subject) b  
WHERE student1.`score` = b.score  
AND student1.`subject` = b.subject
```

### 计算学生所有课程的成绩总和并进行排名

```sql
SELECT name,SUM(score)
from stuscore
GROUP BY `name`
ORDER BY SUM(score) ASC
```

### 有一个表，里面有用户名和用户分数，怎么找第一名，找第二名，第一名有重复怎么找第二名

不考虑重复的情况，找第一名和第二名：

```sql
SELECT username, score
FROM user_scores
ORDER BY score DESC
LIMIT 2;
```

第一名有重复的情况

```sql
SELECT username, score
FROM user_scores
WHERE score < (SELECT MAX(score) FROM user_scores)
ORDER BY score DESC
LIMIT 1;
```

# ---------- 基本概念

## 什么是关系型数据库？ #repeat

RDB，Relational Database 是一种==建立在关系模型的基础上==的数据库。**关系模型**表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）

- RDB 中，我们的数据都被存放在了各种**表**中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）
- 大部分 RDB 都使用 **SQL** 来操作数据库中的数据。
- 大部分 RDB 都支持事务的四大特性(**ACID**)

常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……

## 什么是 SQL？

**结构化查询语言**(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。

几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。

SQL 可以帮助我们：

- 新建数据库、数据表、字段；
- 在数据库中增加，删除，修改，查询数据；
- 新建视图、函数、存储过程；
- 对数据库中的数据进行简单的数据分析；
- 搭配 Hive，Spark SQL 做大数据；
- 搭配 SQLFlow 做机器学习；
- …

## 什么是 MySQL？ #repeat 

MySQL 是**一种关系型数据库**，主要用于**持久化存储**我们的系统中的一些数据比如用户信息。

> 由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL 的默认端口号是 3306

优点（流行的原因）：

- 成熟稳定，功能完善。
- 开源免费。
- 文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。
- 开箱即用，操作简单，维护成本低。
- 兼容性好，支持常见的操作系统，支持多种开发语言。
- 社区活跃，生态完善。
- 事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。
- 支持分库分表、读写分离、高可用。

## MySQL 性能慢的原因(1)

#todo

# ---------- MySQL 字段类型 #repeat

- *数值类型*：
	- **整型**（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）
	- **浮点型**（FLOAT 和 DOUBLE）
	- **定点型**（DECIMAL）
- *字符串类型*：
	- **CHAR**（最常用）
	- **VARCHAR**（最常用）
	- TINYTEXT、
	- **TEXT**、
	- MEDIUMTEXT、
	- LONGTEXT、
	- TINYBLOB、
	- **BLOB**（二进制大对象）
	- MEDIUMBLOB 
	- LONGBLOB
- *日期时间类型*：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等

## 整数类型的 UNSIGNED 属性有什么用？ #repeat

MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示==不允许负值的无符号整数==。使用 UNSIGNED 属性可以==将正整数的上限提高一倍==，因为它不需要存储负数值。

> 例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 INT 类型的值范围是 -2,147,483,648 ~ 2,147,483,647。

对于==从 0 开始递增的 ID 列==，使用 UNSIGNED 属性可以非常适合，因为不允许负值并且可以拥有更大的上限范围，提供了更多的 ID 值可用。

## CHAR 和 VARCHAR 的区别？ #repeat

CHAR 是**定长**字符串，VARCHAR 是**变长**字符串

> CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。

适用场景：

- CHAR 更适合存储==长度较短或者长度都差不多==的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。
- VARCHAR 类型适合存储==长度不确定或者差异较大==的字符串，例如用户昵称、文章标题等。

CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。

## VARCHAR(100) 和 VARCHAR(10)的区别是什么？ #repeat

VARCHAR(100) 和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。

虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符范围不同，但==二者存储相同的字符串，所占用磁盘的存储空间其实是一样的==，这也是很多人容易误解的一点。

不过，==VARCHAR(100) 会消耗更多的内存==。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100) 是按照 100 这个长度来进行的，也就会消耗更多内存

## DECIMAL 和 FLOAT/DOUBLE 的区别是什么？ #repeat

DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储**精确**的小数值，FLOAT/DOUBLE 只能存储**近似**的小数值

DECIMAL 用于存储具有精度要求的小数，例如与**货币相关**的数据，可以避免浮点数带来的精度损失。

在 Java 中，MySQL 的 DECIMAL 类型对应的是 Java 类 `java.math.BigDecimal`

## 为什么不推荐使用 TEXT 和 BLOB？

#todo完善 

TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储**更长的字符串**，即长文本数据，例如博客内容

BLOB 类型主要用于存储**二进制大对象**，例如图片、音视频等文件

在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则**基本不常用**。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。

数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：

- 不能有默认值
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）
- 检索效率较低
- 不能直接创建索引，需要指定前缀长度
- 可能会消耗大量的网络和 IO 带宽
- 可能导致表上的 DML 操作变慢
- … 

## DATETIME 和 TIMESTAMP 的区别是什么？

区别：

- DATETIME 类型没有时区信息，TIMESTAMP 和**时区**有关。
- TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间 `-->` ==Timestamp 表示的时间范围更小==

> - DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
> - Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

## NULL 和 '' 的区别是什么？ #repeat

`NULL` 跟 `''` (空字符串)是两个完全不一样的值，区别如下：

- `NULL` 代表一个不确定的值，就算是两个 `NULL`，它俩也**不一定相等**
	- `SELECT NULL=NULL` 的结果为 false
	- 但是在我们使用 `DISTINCT`, `GROUP BY`, `ORDER BY` 时, `NULL` 又被认为是相等的
- `''` 的长度是 0，是**不占用空间**的，而 `NULL` 是需要**占用空间**的
- `NULL` 会影响**聚合函数**的结果。
	- 例如，`SUM`、`AVG`、`MIN`、`MAX` 等聚合函数会**忽略** `NULL` 值。 
	- `COUNT` 的处理方式取决于参数的类型。
		- 如果参数是 `*` (`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；
		- 如果参数是某个字段名(`COUNT(列名)`)，则会**忽略** `NULL` 值，只统计非空值的个数。
- 查询 `NULL` 值时，必须使用 `IS NULL` 或 `IS NOT NULL` 来判断，而不能使用 =、!=、 <、> 之类的比较运算符。而 `''` 是可以使用这些比较运算符的。

> 为什么 MySQL 不建议使用 `NULL` 作为列默认值？

## Boolean 类型如何表示？

MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。

TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true

# ---------- MySQL 基础架构

#todo

> 一个 SQL 语句在 MySQL 中的执行流程

# ---------- 存储引擎

## MySQL 支持哪些存储引擎？默认使用哪个？

默认的存储引擎是 InnoDB（5.5版本之后）。并且只有 InnoDB 支持事务

InnoDB、MyISAM、Memory

## MySQL 存储引擎架构了解吗？ #repeat

MySQL 存储引擎采用的是 **插件式架构** ，支持多种存储引擎，可以==为不同的数据库表设置不同的存储引擎==以适应不同场景的需要。

- 总结：存储引擎是基于表的，而不是数据库

> 并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。

## MyISAM 和 InnoDB 有什么区别？ #repeat

> MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。
> 
> 虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。
> 
> MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。

锁机制

- MyISAM 只有表级锁，
- InnoDB 支持行级锁和表级锁，默认为行级锁，并发写的时候性能更好

InnoDB 提供事务支持，

- 具有**提交和回滚**事务的能力。
- 实现了 SQL 标准定义了四个**隔离级别**，
- 默认使用的 REPEATABLE-READ（可重读）隔离级别可以解决幻读（基于 MVCC 和 Next-Key Lock）

InnoDB 支持外键

> 外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！

InnoDB 支持数据库异常崩溃后的安全恢复

- 数据库在异常崩溃后，重新启动时会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 `redo log`

索引支持：

- 都不支持 hash 索引，都支持 B+Tree 索引 和 全文索引

B+Tree 索引实现不一样

- MyISAM 中索引文件和数据文件是**分离**的
- InnoDB 中数据文件本身就是索引文件，即其==表数据文件本身就是按 B+Tree 组织的一个索引结构==，树的叶节点 data 域保存了完整的数据记录

InnoDB 的性能比 MyISAM 更强大

- 不管是在读写混合模式下还是只读模式下，==随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长==
- MyISAM 因为==读写不能并发==，它的处理能力跟核数没关系。


![600](assets/image-20220425222351141.png)

## MyISAM 和 InnoDB 如何选择？ 

在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是不需要事务支持、崩溃恢复、对并发性要求不高

> 《MySQL 高性能》上面有一句话这样写到:
> 
> 不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了**聚簇索引**，或者需要访问的数据都可以放入内存的应用。

# ---------- 索引

## 索引(2+) #repeat

索引是一种**有序**的数据结构，用于快速查询和检索数据的数据结构

优点：

- 提高数据**检索**的效率，降低数据库的 **IO 成本**（次数）
- 通过索引列对数据进行**排序**，降低数据排序的成本，降低 **CPU 的消耗**
- 通过创建**唯一性**索引，可以保证数据库表中每一行数据的唯一性。

缺点：

- 索引需要占用存储空间的（不是个问题，磁盘的空间很大）
- 降低更新表的速度，以为索引也需要动态的修改

## 索引底层数据结构 #repeat

### hash 索引

哈希索引就是采用一定的 hash 算法，将**键值**换算成新的 hash 值，映射到对应的槽位上，然后存储在 **hash 表**中

**链地址法**解决哈希冲突

特点：

- 只能用于对等比较（`=，in`）
- 不支持范围查询（`between，>，< ，...`）、排序
- 查询效率高，无哈希冲突一次检索即可

 > #todo扩展 InnoDB 中具有自适应 hash 功能

### B+Tree

> B+ 树数据结构
> 
> 介绍 B+树、插入删除 #携程 
> 
> 为什么树的高度越高会导致磁盘 IO 越多？ #携程
> 
> B+树更扁 有什么好处？

### B+树和 b 树区别：

结构上的区别：

- B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树所有的数据都出现在叶子节点，非叶子节点仅仅起到索引数据作用
- B+树的叶子节点形成一个单向链表

优势：

- 在 B 树中进行**范围查询**时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。
- MySQL 索引数据结构在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，**利于排序**

B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

### 为什么用 B+树？

> 为什么B+树？(2+)，继续问底层
> 
> B+ 树和红黑树 的区别
> 
> 为什么不适用红黑树存储索引？ #携程

为什么不选 BST？

- 顺序插入时，会形成一个链表，查询性能大大降低

为什么不选 AVL？

- 需要频繁地进行旋转操作来保持平衡，有较大的计算开销进而降低了数据库写操作的性能
- 每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO

为什么不选 RB 树？

- 红黑树是二叉树，在大数据量的情况下，层级较深，检索速度慢

> 性能瓶颈取决于磁盘 io 的次数

## 索引类型划分

按照底层数据结构划分：

- B+Tree 索引
- Hash 索引（innodb不支持）
- R-Tree 索引（innodb不支持）
- Full-text：全文索引，对文本的内容进行分词、搜索。

> R-Tree 索引一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替
> 
> Full-text 目前只有 `CHAR`、`VARCHAR` ，`TEXT` 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。

按照底层存储方式划分：

- 聚簇索引（聚集索引）
- 非聚簇索引（非聚集索引）

按照字段特性划分：

- 主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个
- 普通索引：仅加速查询
- 唯一索引：加速查询 + 列值唯一（可以有 NULL）
- 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
- 全文索引：对文本的内容进行分词、搜索（`CHAR`、`VARCHAR` ，`TEXT`）

## 聚簇索引 & 非聚集索引(2+)

> 和二级索引的区别？

聚簇索引：即索引结构和数据**一起存放**的索引，InnoDB 中的主键索引就属于聚簇索引。

- 主键索引 ≈ 聚簇索引
- 主键索引叶子节点保存了行数据

非聚簇索引：索引结构和数据**分开存放**的索引。二级索引就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

- 二级索引 ≈ 非聚集索引
- 二级索引叶子结点保存了主键

## 覆盖索引(1) #repeat

需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而==无需回表查询==

## 索引下推 #repeat

#todo完善

Index Condition Pushdown，简称 ICP，是 MySQL 5.6 版本中提供的一项索引优化功能，它允许存储引擎在索引遍历过程中，==执行部分 WHERE 字句的判断条件==，直接过滤掉不满足条件的记录，从而减少回表次数，提高查询效率

索引下推的**下推**其实就是指将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理。

[MySQL索引详解 | JavaGuide](https://javaguide.cn/database/mysql/mysql-index.html#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8)

## 如何确定字段是否走索引？(1)

使用 `EXPLAIN` 命令来分析 SQL 的 **执行计划** ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式

- possible_keys	可能用到的索引
- key	实际用到的索引

## 索引失效(1) #repeat

### 最左前缀匹配原则（联合索引） #repeat

> 联合索引数据结构实现方式，如何查询 #携程

最左前缀匹配原则指的是在使用联合索引时，MySQL 会根据**索引中的字段顺序**，从左到右依次匹配查询条件中的字段。并且如果跳过联合索引的某一列，索引将会**部分失效**（这一列开始后面的字段索引失效）

- 最左匹配原则会一直向右匹配，直到遇到**范围查询**（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配

- 条件（**where**）编写的先后顺序任意（order by、group by 之类的就不行）

在使用联合索引时，可以将**区分度高**的字段放在最左边，这也可以过滤更多数据。

### `>、<` 的范围查询（联合索引）

联合索引中，某个索引字段出现范围查询（`> , <`），其右侧的列索引失效

> 在业务允许的情况下，**尽可能的使用**类似于 `>=` 或 `<=` 这类的范围查询

### 索引列运算、函数、类型转换

在索引列上进行**运算**操作，索引将失效

```sql
explain select * from tb_user where substring(phone,10,2) = '15'; -- 失效
```

字符串类型字段使用时，**不加引号**，数据库存在隐式类型转换，索引将失效

### 头部模糊查询 

以 % 开头的 LIKE 查询

### or 连接条件

or 连接的条件，左右两侧字段**都有**索引时，索引才会生效

### 数据分布影响 

如果 MySQL 评估走全表扫描比索引更快，则不使用索引

## 正确使用索引 #repeat

> 什么数量级的表需要加索引？(1)
> 
> 数据量很大的表加字段有什么要注意的？(1)
> 
> 增加索引后，性能开销主要在哪些环节(1)

### 选择合适的字段

- 数据量大、**查询**频繁的字段
	- 被频繁更新的字段应该慎重建立索引（维护成本高）
- 尽量选择**区分度高**的字段
	- 尽量建立唯一索引，区分度越高，使用索引的效率越高
- 尽量**不为 NULL** 的字段 #todo完善 
	- 对于不存储 NULL 值字段，要在创建表时使用 NOT NULL 约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询
- 条件 where、排序 order by、分组 group by 
- 频繁被用于**连接**的字段：提高多表连接查询的效率

### 限制每张表上的索引数量

> 是不是索引越多，性能越好(1)

索引并不是越多越好，建议单张表索引**不超过 5 个**

- 索引会降低插入和更新的效率
- 有些情况下会降低查询效率

MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果==同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间==，同样会降低查询性能 #todo完善 

### 联合索引>单列索引

可以**覆盖索引**，节省存储空间

> #JavaGuide 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升

### 前缀索引

仅限于字符串类型的字段，只将字符串的一部分前缀，建立索引

字段的长度较长，建立前缀索引较普通索引会占用更小的空间

### 注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引

# ---------- 事务

数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。

## 四大特性(1) #repeat

- **原子性**（`Atomicity`）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
- **一致性**（`Consistency`）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
- **隔离性**（`Isolation`）：数据库系统提供的隔离机制，保证事务在不收外部并发操作影响的独立环境下运行
- **持久性**（`Durability`）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

![AID->C|300](https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png)

## 并发事务问题

- _脏读_（Dirty read）: 一个事务读到另外一个事务还没有提交的数据

- _丢失修改_（Lost to modify）: 一个事务中修改了某个数据后，第二个事务也修改了这个数据这样第一个事务内的修改结果就被丢失（脏写）

- _不可重复读_（Unrepeatable read）: 一个事务先后读取同一条记录，但两次读取的数据不同（中间被其他事务 修改 或 删除 了？）

- _幻读_（Phantom read）: 一个事务按照条件查询数据时，没有对应的数据行，随后在插入（查询？）数据时，又发现这行数据已经存在（多了几行），好像出现了“幻影”

### 不可重复读和幻读有什么区别？ #repeat

- 不可重复读的重点是内容修改或者记录减少
- 幻读的重点在于记录新增

幻读其实可以看作是不可重复读的一种**特殊情况**，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样

举个例子：执行 `delete` 和 `update` 操作的时候，可以直接对记录加锁，保证事务安全。而执行 `insert` 操作的时候，由于==记录锁（Record Lock）只能锁住已经存在的记录==，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 `insert` 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。

## 并发事务的控制方式有哪些？

#todo 

MVCC 和锁

## 隔离级别(2+)

> 读已提交、可重复读、区别 (2)
> 
> 可重复读级别是怎么实现的(1)
> 
> InnoDB 默认隔离级别(1)

- READ-UNCOMMITTED ：允许读取并发事务尚未提交的数据
- READ-COMMITTED：允许读取并发事务已经提交的数据
- REPEATABLE-READ ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改
- SERIALIZABLE：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰

|隔离级别|脏读|不可重复读|幻读|
|---|---|---|---|
|READ-UNCOMMITTED|√|√|√|
|READ-COMMITTED|×|√|√|
|REPEATABLE-READ|×|×|√|
|SERIALIZABLE|×|×|×|

InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）

## 事务隔离级别怎么实现的？ #repeat

#todo

基于锁和 MVCC 机制共同实现的

SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在**当前读**情况下需要使用**加锁**读来保证不会出现幻读。

## 幻读问题是怎么解决的

#todo 

# ---------- 锁

MySQL 中的锁，按照锁的粒度分，分为以下三类：全局锁、表锁、行锁

## 表级锁和行级锁了解吗？有什么区别？ #repeat

> 能否对非索引字段加锁（1）

行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高

表级锁和行级锁对比：

- *表级锁*： 锁定粒度大，是针对**非索引字段**加的锁，对当前操作的整张表加锁，
	- 实现简单，资源消耗也比较少，加锁快，
	- 不会出现死锁。
	- 不过，==触发锁冲突的概率最高==，高并发下效率极低。

> 执行 `UPDATE`、`DELETE` 语句时，如果 `WHERE` 条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁

- *行级锁*： MySQL 中锁定粒度**最小**的一种锁，是 针对**索引字段**加的锁 ，只针对当前操作的行记录进行加锁。 
	- 能大大减少数据库操作的冲突，并发度高，
	- 但加锁的开销也最大，加锁慢，
	- 会出现死锁。
	- 行级锁和存储引擎有关，是在**存储引擎层面**实现的

## InnoDB 有哪几类行锁？ #repeat

- *记录锁*（Record Lock）：单个行记录上的锁。
	- 在 **RC、RR** 隔离级别下都支持
- *间隙锁*（Gap Lock）：锁定记录间隙，不包括记录本身。
	- 在 RR 隔离级别下都支持
- *临键锁*（Next-Key Lock）：Record Lock+Gap Lock，同时锁住数据，并锁住数据**前面**的间隙 Gap
	- 在 RR 隔离级别下都支持

## 行锁加锁规则 #repeat

默认情况下，InnoDB 在 RR 事务隔离级别运行，加锁规则：

- 前提：InnoDB 的行锁是针对于索引加的锁，不通过索引条件检索数据，升级为**表锁**
- 加锁的基本单位：**临键锁**
- 索引上的等值查询（**唯一**索引）
    - 对**已存在**的记录加锁时，优化为**记录锁** `X,REC_NOT_GAP`
    - 对**不存在**的记录加锁时，优化为**间隙锁** `X,GAP`
- 索引上的等值查询（**非唯一**普通索引），向右遍历时最后一个值不满足查询需求时，临键锁 优化为**间隙锁** `X`
- 索引上的范围查询（唯一索引），会访问到不满足条件的第一个值为止 #todo完善

## 共享锁和排他锁 #repeat 

表级锁和行级锁都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：

- *共享锁*（读锁）：事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）
- *排他锁*（写锁/独占锁）：事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）

|     | S 锁 | X 锁 |
| --- | --- | --- |
| S 锁 | 兼容  | 互斥  |
| X 锁 | 互斥  | 互斥  |

SQL 语句执行时加的行锁：

![600](assets/Pasted%20image%2020240326005339.png)

由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。

```sql
# 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
SELECT ... LOCK IN SHARE MODE;
# 共享锁 可以在 MySQL 8.0 中使用
SELECT ... FOR SHARE;
# 排他锁
SELECT ... FOR UPDATE;
```

## 意向锁

> 事务 在增加表级锁的时候，先判断一下是不是有事务增加过行级锁。但是，事务 B 总不能遍历表中数据逐条判断是否有加锁吧

意向锁是由数据引擎**自己维护**（全自动）的，在为**数据行**加共享/排他锁之前，InooDB 会先获取数据表的对应意向锁

目的：快速判断是否可以对某个表使用表锁

意向锁是**表级锁**，共有两种：

- *意向共享锁*（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加 S 锁，加 S 锁前必须先取得该表的 IS 锁
- *意向排他锁*（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加 X 锁，加 S 锁之前必须先取得该表的 IX 锁

意向锁之间是互相兼容的

意向锁只和（表级）S 锁兼容

|         | IS 锁 | IX 锁 |
| ------- | ---- | ---- |
| S 锁（表级） | 兼容   | 互斥   |
| X 锁（表级） | 互斥   | 互斥   |

## 当前读和快照读有什么区别？

#todo


# ---------- SQL 优化 #repeat

### 多条数据插入

每次插入都要提交事务

```java
insert into tb_test values(1,'tom');
insert into tb_test values(2,'cat');
insert into tb_test values(3,'jerry');
```

1）批量插入

```sql


Insert into tb_test values(1,'Tom'),(2,'Cat'),(3,'Jerry');
```

2）手动控制事务

### 避免使用 `SELECT *`

- 无用字段增加**网络带宽资源**消耗、**磁盘 IO** 开销
	- 尤其是大字段（如 varchar、`SELECT *` blob、text）

- `SELECT *` **无法覆盖索引**
	- 基于 MySQL 优化器的“覆盖索引”策略又是 速度极快，效率极高，业界极为推荐的查询优化方式)

- `SELECT<字段列表>` 可减少**表结构变更**带来的影响

### order by 优化

MySQL 的排序，有两种方式：

- _Using filesort_：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sortbuffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序
- _Using index_：通过==有序索引顺序扫描直接返回有序数据==，不需要额外排序，操作效率高

Using index 的性能高，在优化排序操作时**尽量要优化为 Using index**

- 覆盖索引，联合索引遵循最左前缀匹配法则

### 分页优化

在数据量比较大时，如果进行 limit 分页查询，在查询时，越往后，分页查询效率越低

- 例如执行 `limit 2000000, 10` ，此时需要 MySQL 排序前 2000010 记录，扫描到 2000010行数据，返回 2000000 - 2000010 的记录，其他记录丢弃，查询排序的代价非常大

> 想办法不让他把前 2000000 万数据读出来

优化思路：**覆盖索引（查出 id）+子查询**

```sql
EXPLAIN SELECT * FROM tb_sku ORDER BY id LIMIT 5000000, 10; -- 时间: 16.925s

EXPLAIN SELECT
	t.* 
FROM
	tb_sku t,
	( SELECT id FROM tb_sku ORDER BY id LIMIT 5000000, 10 ) a 
WHERE
	t.id = a.id; -- 时间: 11.467s
```

### count 优化

`count()` 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是NULL，累计值就加 1，否则不加，最后返回累计值

![600](assets/Pasted%20image%2020240324165918.png)

按照效率排序的话，`count(字段) < count(主键 id) < count(1) ≈ count(*)`，所以尽量使用 `count(*)`

### 多表 join

#todo完善 

> 阿里巴巴《Java 开发手册》：
> 
> 【强制】超过三个表禁止 join。
> 
> - 需要 join 的字段，数据类型保持绝对一致；
> - 多表关联查询时，保证被关联的字段需要有**索引**。

- 联表查询最多**三张表**
- 做为连接的字段要有**索引**
- 避免的方法：单表查询后在**内存**中自己做关联。对数据库做单表查询，再根据查询结果进行二次查询，以此类推最后再进行关联

### 不要使用外键与级联

#todo 

### 选择合适的字段类型

#todo 

### 尽量用 UNION ALL 代替 UNION

#todo 

### 日志分析

- Show Profile 分析 SQL 执行性能 #todo 

- 慢查询日志：记录 MySQL 在执行命令中，响应时间超过预设阈值的 SQL 语句



# ---------- 日志

## 慢查询

> 如何分析慢SQL

# ---------- 集群

## mysql 主从同步延迟太大如何处理？

#携程


# ---------- 未知

Mysql的 redo、undo log 作用，补充了 bin log 、replay log

数据库的死锁怎么引起的

数据库层面对于乐观锁和悲观锁是怎么应用的

如果不考虑索引的维护成本，还有哪些操作的性能开销会增大

mysql 给表添加新的列，底层如何做的？如果此时线上有读写，会出现什么情况？你有什么解决思路？

如何找到对应版本的数据(mvcc) #携程 

怎么做或者设计事务管理？