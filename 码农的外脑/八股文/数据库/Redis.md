
# ---------- 基本概念

redis 是一个基于 C 语言开发的、开源、基于内存的键值型 **NoSQL 数据库**（BSD 许可）

> Remote Dictionary Server，远程词典服务器

## redis 为什么快？(1)

Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：

- 基于**内存**，内存的访问速度是磁盘的上千倍；
- 基于 Reactor 模式设计开发了一套高效的**事件处理模型**，
	- 主要是 单线程事件循环 和 IO 多路复用
- 内置了多种优化过后的**数据类型/结构**实现

![|600](assets/Pasted%20image%2020240314002538.png)

## 为什么用 redis 做缓存？(2)

> 说一下 Redis 和 Memcached 的区别和共同点

- *丰富的数据类型*：（支持更复杂的应用场景）不仅支持简单的 k/v 类型数据，还提供 list，set，zset，hash 等数据结构的存储
- *持久化*
	- 灾难恢复机制
	- 内存用完后，可以将不用的数据放到磁盘上
- *原生集群*
- *单线程*：单线程的多路 IO 复用模型（Redis 6.0 针对网络数据的读写引入了多线程）
- *支持发布订阅模型、Lua 脚本、事务*等功能（Memcached 不支持）
- *支持更多语言客户端*
- *过期策略*：同时使用了惰性删除与定期删除

> Memcached 
> - 只支持最简单的 k/v 数据类型。
> - 把数据全部存在内存之中，内存用完后直接报异常
> - 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
> - Memcached 是多线程，非阻塞 IO 复用的网络模型；
> - Memcached 过期数据的删除策略只用了惰性删除

## redis 适用场景(2+)

> 为什么要用 Redis/缓存？
> 
> 用本地缓存可不可以 #todo
> 
> 什么时候使用 Redis，什么情况不适用 #todo

1）高性能

> 用户第一次访问数据库中的某些数据的话，这个过程是比较慢

高频数据并且不会经常改变的数据放入缓存，用户下一次访问速度快（还可以缓存预热）

2）高并发

> 一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。
> 
> QPS（Query Per Second）：服务器每秒可以执行的查询次数；

缓存能够承受的请求数量是**远远大于**直接访问数据库，所以我们可以考虑把数据库中的部分数据转移到缓存中去，进而提高了系统整体的并发


## Redis Module

#todo 

# ---------- 数据结构

## redis 常用数据结构(2+)

> 项目里怎么用的(2)

- String
	- 细分 string、int、float
	- 可存 json
- Hash
	- 特点：对 field 做 CRUD，json 字符串 不行
- List
	- 特点：有序、可重复、链表
	- 可模拟栈、队列、阻塞队列
- Set
	- 特点：无序、不重复、查找快、支持交并差集
- SortedSet
	- 特点：可排序的 Set

## bitmap 了解吗？有什么使用场景？

> bitmap原理

## Hyperloglog

## sorted set 底层是什么数据结构(1)

> 跳表查询的复杂度是多少(1)

# ---------- 缓存

缓存就是数据交换的缓冲区(称作 cache)，是存储数据的临时地方，一般读写性能较高

## 缓存读写策略

### Cache Aside Pattern

> 旁路缓存模式

服务端需要同时维系 db 和 cache，并且是以 db 的结果为准

- 使用比较多，
- 适合场景：读请求比较多

具体步骤：

- 写操作：
	- 先更新 db
	- 然后删除 cache 
- 读操作:
	- 从 cache 中读数据，
		- 读取到就直接返回
		- 读取不到的话，就从 db 中获取
	- 写操作

问题：

- 删除 or 更新 缓存?
	- ❌更新缓存：每次更新数据库都更新缓存，**无效写操作较多**
	- ✔️删除缓存：更新数据库时让缓存失效，查询时再更新缓存

- 如何保证缓存与数据库的操作的 同时成功或失败?
	- 单体系统：将缓存和数据库操作放在一个事务里
	- 分布式系统：TCC 等分布式事务方案

- 先操作 缓存 or 数据库?
	- 都可能发生“线程安全”问题，导致缓存和数据库**不一致**的问题
	- 先删缓存，后更新数据库：发生的**概率高**
	- 先更新数据库，后删缓存：发生的概率很低，因为**缓存的速度高于数据库很多**

缺陷：

- **首次**请求数据一定不在 cache 的问题
	- 解决办法：可以将热点数据可以提前放入 cache 中（缓存预热）

- 写操作比较频繁 会导致 cache 被频繁被删除，影响**缓存命中率**
	- 数据库和缓存*强一致场景*：
		- 更新 db 的时候同样更新 cache，
		- **锁/分布式锁** 保证更新 cache 的时不存在线程安全问题
	- 可以*短暂地允许不一致*的场景：
		- 更新 db 的时候同样更新 cache，
		- 给缓存加一个**比较短的过期时间**，即使数据不一致影响也比较小

### Read/Write Through Pattern

> 读写穿透模式

服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据写入 db，从而减轻了应用程序的职责

> 这种缓存读写策略非常少见。抛去性能方面的影响，大概率是因为 **Redis 并没有提供 cache 将数据写入 db 的功能**。

具体操作：

- 写（Write Through）：
	- 先查 cache，
		- 不存在，直接更新 db
		- 存在，则先更新 cache，然后 cache 服务自己更新 db（**同步更新** cache 和 db）
- 读(Read Through)：
	- 从 cache 中读取数据，
		- 读取到就直接返回
		- 读取不到，cache 从 db 加载，写入到 cache 后返回响应

![|500](assets/Pasted%20image%2020240315110241.png)

缺点：首次请求数据一定不在 cache 的问题

### Write Behind Pattern

> 异步缓存写入

cache 服务来负责 cache 和 db 的读写

具体操作：

- Write Behind：只更新缓存，不直接更新 db，而是改为**异步**批量的方式来更新 db

## 缓存穿透(2)

> 布隆过滤器怎么实现(1) #todo

客户端请求的数据在**缓存和数据库中都不存在**，这样缓存永远不生效，请求都会打到数据库里

方案一：缓存空值（无效 key）

> 缓存空值以后，第二次就能从缓存里获取空值，直接返回不存在

- 优点：简单

- 缺点：
	- 额外的内存消耗（大量恶意攻击，缓存大量无效 key）
		- 解决：设置较短的 TTL
	- 短期的数据不一致
		- 解决：真正插入的时候覆盖

方案二：布隆过滤器

- 优点：内存占用少，没有多余 key
- 缺点：
	- 实现复杂
	- 存在误判可能


## 缓存击穿(2) 

> 类似问题：
> 
> - 给数据库加互斥锁，如果有些就是请求因为一直抢不到锁，出现饿死情况怎么解决(1)

一个**被高并发访问**并且缓存重建业务较复杂（**重建时间较长**）的 key 突然失效了（过期），无数的请求会瞬间给数据库带来巨大的压力

> 也叫热点 Key 问题
> 
> 举个例子：秒杀过程中，缓存中的某个秒杀商品的数据突然过期，导致瞬时大量对该商品的请求直接落到数据库上

解决方案：

- 被动预防
	- 设置合理的 TTL
		- 热点 key 永不过期 或者 TTL 比较长
		- 秒杀场景下的数据在秒杀结束之前不过期
	- 热点数据缓存预热
- 主动解决
	- 互斥锁、互斥锁+逻辑过期
		- 互斥锁保证**只有一个请求会落到数据库上**

> 常见的缓存预热方式有两种：
> 
> 1. 使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中
> 2. 使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存

1）*互斥锁*：

缓存未命中，先获取互斥锁，查询 db 重建缓存数据后，再释放互斥锁。抢锁失败的线程循环查询缓存，知道缓存中间成功获取数据。

- 优点：
	- **保证一致性**
- 缺点：
	- 线程要等待，性能受影响
	- 有死锁风险

2）*互斥锁+逻辑过期*

> key 是永久的，由后端添加一个 expire 字段（LocalDateTime 实现）表示过期时间；
> 
> LocalDateTime提供了
> - `now.plusSeconds(TTL)` 设置逻辑过期时间
> - `expireTime.isAfter(now)` 判断是否过期

发现逻辑过期后，获取锁成功的线程，另开一个线程异步重建缓存（不会等待了），获取锁失败的线程直接返回过期数据

- 优点：
	- 线程无需等待，**性能较好**
- 缺点
	- 不保证一致性
	- 有额外的内存开销

## 缓存雪崩(2)

在同一时段大量的缓存 key 同时失效 或者 Redis 服务宕机 导致大量请求到达数据库

针对 Redis 服务不可用的情况：

- 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用
- 限流，避免同时处理大量的请求
- 降级（缓存全崩完了）
- 多级缓存
	- 例如：jvm 本地缓存+Redis 缓存（浏览器缓存、nginx 缓存）

针对缓存失效的情况：

- 设置不同的 TTL
	- 例如：给不同 key 的 TTL 添加随机值
- 热点 key，缓存预热

# ---------- 分布式锁

满足 分布式系统 或 集群模式 下 多进程可见并且互斥的锁

特性：

- 多进程可见
- 互斥
- 高可用
- 高性能
- 安全性：服务挂了锁没释放、死锁

## 如何实现分布式锁(2+)

> 底层实现（基于什么命令）(2)
> 
> redis 并发锁内部实现，分段锁好处 #todo

1）获取锁

- 利用 `SETNX` 的互斥性，`SET lock v EX time NX`

对应 RedisTemplate 的方法 `Boolean setIfAbsent(K key, V value, long timeout, TimeUnit unit)`

2）释放锁

- 手动释放，`DEL lock`
- 超时释放，获取锁时添加超时时间（服务宕机）

## 可重入锁怎么实现(1)


## 超时续约

> 看门狗机制是怎么实现的 #滴滴 





# ---------- 内存管理

## Redis 是如何判断数据是否过期的呢？


## redis 的过期策略有哪些(1)


## 过期数据的删除策略(1)

常用的过期数据的删除策略

- *惰性删除*：取出 key 的时候才进行过期检查
	- 对 CPU 更友好
	- 但是可能会造成太多过期 key 没有被删除
- *定期删除*：每隔一段时间抽取一批 key， 删除过期 key
	- 对内存更友好
	- Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响

Redis 采用的是 【定期删除 + 惰性/懒汉式删除】 

仅仅通过给 key 设置 TTL，还是可能漏掉很多过期 key，导致大量过期 key 堆积在内存里，然后就 Out of memory 了

> 怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。

## 内存淘汰策略(2)

#todo





# ---------- 消息队列(2)





# ---------- 集群

## 分片(1)

## 主从复制过程(1)

## 哨兵选主过程(1)

## redis集群，批量获取key会有什么问题

> 如果保证了相同业务场景的key都写入了一个主节点，这是再使用mget，会不会有什么问题
> 
> 解决集群中批量获取的问题，应该怎么做？


# ---------- 持久化(1)

## 持久化方法(2+)


# ---------- 未知

## CAP 理论

## redis 怎么优化内存占用的？

> redis数据结构是怎么优化内存空间使用的



## 网络模型

