
# ---------- 基本概念

redis 是一个基于 C 语言开发的、开源、基于内存的键值型 **NoSQL 数据库**（BSD 许可）

> Remote Dictionary Server，远程词典服务器

## redis 为什么快？(1)

Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：

- 基于**内存**，内存的访问速度是磁盘的上千倍；
- 基于 Reactor 模式设计开发了一套高效的**事件处理模型**，
	- 主要是 单线程事件循环 和 IO 多路复用
- 内置了多种优化过后的**数据类型/结构**实现

![|600](assets/Pasted%20image%2020240314002538.png)

## 为什么用 redis 做缓存？(2)

> 说一下 Redis 和 Memcached 的区别和共同点

- *丰富的数据类型*：（支持更复杂的应用场景）不仅支持简单的 k/v 类型数据，还提供 list，set，zset，hash 等数据结构的存储
- *持久化*
	- 灾难恢复机制
	- 内存用完后，可以将不用的数据放到磁盘上
- *原生集群*
- *单线程*：单线程的多路 IO 复用模型（Redis 6.0 针对网络数据的读写引入了多线程）
- *支持发布订阅模型、Lua 脚本、事务*等功能（Memcached 不支持）
- *支持更多语言客户端*
- *过期策略*：同时使用了惰性删除与定期删除

> Memcached 
> - 只支持最简单的 k/v 数据类型。
> - 把数据全部存在内存之中，内存用完后直接报异常
> - 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据
> - Memcached 是多线程，非阻塞 IO 复用的网络模型；
> - Memcached 过期数据的删除策略只用了惰性删除

## redis 适用场景(2+)

> 为什么要用 Redis/缓存？
> 
> 用本地缓存可不可以 #todo
> 
> 什么时候使用 Redis，什么情况不适用 #todo

1）高性能

> 用户第一次访问数据库中的某些数据的话，这个过程是比较慢

高频数据并且不会经常改变的数据放入缓存，用户下一次访问速度快（还可以缓存预热）

2）高并发

> 一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。
> 
> QPS（Query Per Second）：服务器每秒可以执行的查询次数；

缓存能够承受的请求数量是**远远大于**直接访问数据库，所以我们可以考虑把数据库中的部分数据转移到缓存中去，进而提高了系统整体的并发


## Redis Module

#todo 

# ---------- 数据结构

## redis 常用数据结构(2+)

> 项目里怎么用的(2)

- String
	- 细分 string、int、float
	- 可存 json
- Hash
	- 特点：对 field 做 CRUD，json 字符串 不行
- List
	- 特点：有序、可重复、链表
	- 可模拟栈、队列、阻塞队列
- Set
	- 特点：无序、不重复、查找快、支持交并差集
- SortedSet
	- 特点：可排序的 Set

## bitmap 了解吗？有什么使用场景？

> bitmap原理

Bitmap 存储的是**连续的二进制数字（0 和 1）**，只需要一个 bit 位来表示某个元素对应的值或者状态，Bitmap 本身会极大的节省储存空间

可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 **offset**（偏移量）

Redis 中是利用 **string** 类型数据结构实现 BitMap，因此最大上限是 512MB，转换为 bit 则是 **2^32**个 bit 位

## Hyperloglog

Hyperloglog (HLL) 是从 Loglog 算法派生的概率算法，用于确定**非常大的集合的基数**（元素个数），且**不需要存储元素本身的全部**，所以 HLL 不能像集合那样，返回输入的各个元素。

- Redis 中的 HLL 是基于 **string** 结构实现的
- 单个 HLL 的内存永远**小于 16kb**，内存占用低的令人发指！
- 作为代价，**其测量结果是概率性的**，有小于 0.81%的误差。不过对于 UV 统计来说，这完全可以忽略。

## sorted set 底层是什么数据结构(1)

> 跳表查询的复杂度是多少(1)
> 
> 讲一讲跳表 #携程



# ---------- 缓存

缓存就是数据交换的缓冲区(称作 cache)，是存储数据的临时地方，一般读写性能较高

## 缓存读写策略

### Cache Aside Pattern

> 旁路缓存模式

服务端需要同时维系 db 和 cache，并且是以 db 的结果为准

- 使用比较多，
- 适合场景：读请求比较多

具体步骤：

- 写操作：
	- 先更新 db
	- 然后删除 cache 
- 读操作:
	- 从 cache 中读数据，
		- 读取到就直接返回
		- 读取不到的话，就从 db 中获取
	- 写操作

问题：

- 删除 or 更新 缓存?
	- ❌更新缓存：每次更新数据库都更新缓存，**无效写操作较多**
	- ✔️删除缓存：更新数据库时让缓存失效，查询时再更新缓存

- 如何保证缓存与数据库的操作的 同时成功或失败?
	- 单体系统：将缓存和数据库操作放在一个事务里
	- 分布式系统：TCC 等分布式事务方案

- 先操作 缓存 or 数据库?
	- 都可能发生“线程安全”问题，导致缓存和数据库**不一致**的问题
	- 先删缓存，后更新数据库：发生的**概率高**
	- 先更新数据库，后删缓存：发生的概率很低，因为**缓存的速度高于数据库很多**

缺陷：

- **首次**请求数据一定不在 cache 的问题
	- 解决办法：可以将热点数据可以提前放入 cache 中（缓存预热）

- 写操作比较频繁 会导致 cache 被频繁被删除，影响**缓存命中率**
	- 数据库和缓存*强一致场景*：
		- 更新 db 的时候同样更新 cache，
		- **锁/分布式锁** 保证更新 cache 的时不存在线程安全问题
	- 可以*短暂地允许不一致*的场景：
		- 更新 db 的时候同样更新 cache，
		- 给缓存加一个**比较短的过期时间**，即使数据不一致影响也比较小

### Read/Write Through Pattern

> 读写穿透模式

服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据写入 db，从而减轻了应用程序的职责

> 这种缓存读写策略非常少见。抛去性能方面的影响，大概率是因为 **Redis 并没有提供 cache 将数据写入 db 的功能**。

具体操作：

- 写（Write Through）：
	- 先查 cache，
		- 不存在，直接更新 db
		- 存在，则先更新 cache，然后 cache 服务自己更新 db（**同步更新** cache 和 db）
- 读(Read Through)：
	- 从 cache 中读取数据，
		- 读取到就直接返回
		- 读取不到，cache 从 db 加载，写入到 cache 后返回响应

![|500](assets/Pasted%20image%2020240315110241.png)

缺点：首次请求数据一定不在 cache 的问题

### Write Behind Pattern

> 异步缓存写入

cache 服务来负责 cache 和 db 的读写

具体操作：

- Write Behind：只更新缓存，不直接更新 db，而是改为**异步**批量的方式来更新 db

## 缓存穿透(2)

> 布隆过滤器怎么实现(1) #todo

客户端请求的数据在**缓存和数据库中都不存在**，这样缓存永远不生效，请求都会打到数据库里

方案一：缓存空值（无效 key）

> 缓存空值以后，第二次就能从缓存里获取空值，直接返回不存在

- 优点：简单

- 缺点：
	- 额外的内存消耗（大量恶意攻击，缓存大量无效 key）
		- 解决：设置较短的 TTL
	- 短期的数据不一致
		- 解决：真正插入的时候覆盖

方案二：布隆过滤器

- 优点：内存占用少，没有多余 key
- 缺点：
	- 实现复杂
	- 存在误判可能

## 缓存击穿(2) 

> 类似问题：
> 
> - 给数据库加互斥锁，如果有些就是请求因为一直抢不到锁，出现饿死情况怎么解决(1)

一个**被高并发访问**并且缓存重建业务较复杂（**重建时间较长**）的 key 突然失效了（过期），无数的请求会瞬间给数据库带来巨大的压力

> 也叫热点 Key 问题
> 
> 举个例子：秒杀过程中，缓存中的某个秒杀商品的数据突然过期，导致瞬时大量对该商品的请求直接落到数据库上

解决方案：

- 被动预防
	- 设置合理的 TTL
		- 热点 key 永不过期 或者 TTL 比较长
		- 秒杀场景下的数据在秒杀结束之前不过期
	- 热点数据缓存预热
- 主动解决
	- 互斥锁、互斥锁+逻辑过期
		- 互斥锁保证**只有一个请求会落到数据库上**

> 常见的缓存预热方式有两种：
> 
> 1. 使用定时任务，比如 xxl-job，来定时触发缓存预热的逻辑，将数据库中的热点数据查询出来并存入缓存中
> 2. 使用消息队列，比如 Kafka，来异步地进行缓存预热，将数据库中的热点数据的主键或者 ID 发送到消息队列中，然后由缓存服务消费消息队列中的数据，根据主键或者 ID 查询数据库并更新缓存

1）*互斥锁*：

缓存未命中，先获取互斥锁，查询 db 重建缓存数据后，再释放互斥锁。抢锁失败的线程循环查询缓存，知道缓存中间成功获取数据。

- 优点：
	- **保证一致性**
- 缺点：
	- 线程要等待，性能受影响
	- 有死锁风险

2）*互斥锁+逻辑过期*

> key 是永久的，由后端添加一个 expire 字段（LocalDateTime 实现）表示过期时间；
> 
> LocalDateTime提供了
> - `now.plusSeconds(TTL)` 设置逻辑过期时间
> - `expireTime.isAfter(now)` 判断是否过期

发现逻辑过期后，获取锁成功的线程，另开一个线程异步重建缓存（不会等待了），然后返回过期数据，获取锁失败的线程直接返回过期数据

- 优点：
	- 线程无需等待，**性能较好**
- 缺点
	- 不保证一致性
	- 有额外的内存开销

## 缓存雪崩(2)

在同一时段大量的缓存 key 同时失效 或者 Redis 服务宕机 导致大量请求到达数据库

针对 Redis 服务不可用的情况：

- 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用
- 限流，避免同时处理大量的请求
- 降级（缓存全崩完了）
- 多级缓存
	- 例如：jvm 本地缓存+Redis 缓存（浏览器缓存、nginx 缓存）

针对缓存失效的情况：

- 设置不同的 TTL
	- 例如：给不同 key 的 TTL 添加随机值
- 热点 key，缓存预热

# ---------- 分布式锁

满足 分布式系统 或 集群模式 下 多进程可见并且互斥的锁

特性：

- 多进程可见
- 互斥
- 高可用
- 高性能
- 安全性：服务挂了锁没释放、死锁

## 如何实现分布式锁(2+)

> 底层实现（基于什么命令）(2)
> 
> redis 并发锁内部实现，分段锁好处 #todo

1）获取锁

- 利用 `SETNX` 的互斥性，`SET lock v EX time NX`

对应 RedisTemplate 的方法 `Boolean setIfAbsent(K key, V value, long timeout, TimeUnit unit)`

2）释放锁

- 手动释放，`DEL lock`
- 超时释放，获取锁时添加超时时间（服务宕机）

## 可重入锁怎么实现(1)


## 超时续约

> 看门狗机制是怎么实现的 #滴滴 

## Redisson

> Redisson的底层机制了解吗? 与redis实现分布式锁有什么区别？解决了哪些问题？ #携程


## lua

> Lua 脚本的作用？ #携程
> 
> lua 为什么能保证原子性？ #腾讯



# ---------- 内存管理

## Redis 是如何判断数据是否过期的呢？


## redis 的过期策略有哪些(1)


## 过期数据的删除策略(1)

常用的过期数据的删除策略

- *惰性删除*：取出 key 的时候才进行过期检查
	- 对 CPU 更友好
	- 但是可能会造成太多过期 key 没有被删除
- *定期删除*：每隔一段时间抽取一批 key， 删除过期 key
	- 对内存更友好
	- Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响

Redis 采用的是 【定期删除 + 惰性/懒汉式删除】 

仅仅通过给 key 设置 TTL，还是可能漏掉很多过期 key，导致大量过期 key 堆积在内存里，然后就 Out of memory 了

> 怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。

## 内存淘汰策略(2)

#todo


# ---------- 消息队列(2)


# ---------- 持久化(1)

使用缓存的时候，经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。

大部分原因是为了之后

- **重用数据**（比如重启机器、机器故障之后恢复数据），
- 或者是为了做**数据同步**（比如 Redis 集群的主从节点通过 RDB 文件同步数据）

## 持久化方法(2+)

Redis 支持三种持久化方式

- 快照（snapshotting，RDB）
- 只追加文件（append-only file, AOF）
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)

### RDB

全称 *Redis Database Backup file* (Redis 数据备份文件)，也被叫做 Redis 数据快照，简单来说就是**把内存中的所有数据都记录到磁盘中**

- Redis **默认**采用的持久化方式

两种执行 RDB 的方式

- `save` 命令：由 Redis 主进程来执行 RDB，同步保存操作，会阻塞所有命令（**阻塞主线程**）
- `bgsave` 命令：**fork 子进程** 执行 RDB，避免主进程收到影响（**异步**持久化）

> 阻塞“主线程”，Redis 启动之后主要是通过单线程的方式完成主要的工作。也可以说是阻塞“主进程”

RDB 方式 `bgsave` 的基本流程?

- fork 主进程得到一个子进程，**共享内存空间**
	- 当主进程执行读操作时，访问共享内存
	- 当主进程执行写操作时，则会**拷贝**一份数据，执行写操作
- 文件用新 RDB 文件替换旧的 RDB 文件

![](assets/image%20(50).png)

RDB 会在什么时候执行？

- **默认**是服务停止时
- 手动配置 RDB 触发机制
	- save 60 1000：代表 60 秒内至少执行 1000 次修改则触发 RDB

RDB 的缺点?

- RDB **执行间隔时间长**（短了可能第一次 RDB 还没结束，就开始第二次 RDB 了），两次 RDB 之间写入数据有丢失的风险
- fork 子进程、压缩、写出 RDB 文件都**比较耗时**

### AOF

全称为 *Append 0nly File* (追加文件)。Redis 处理的每一个**写命令都会记录在 AOF 文件**，可以看做是命令日志文件

- 实时性好
- 6.0 以后默认

AOF 的命令记录的频率配置

- `appendfsync always`：每执行一次写命令，立即记录到AOF文件
- `appendfsync everysec`（默认）：写命令执行完先放入 AOF 缓冲区，然后表示每隔 1 秒将缓冲区数据写到 AOF 文件
- `appendfsync no`：写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘

![](assets/image%20(51).png)

文件重写（例如 String 类型，对同一个 key 的多次写操作，只有最后一次才有意义）

- `bgrewriteaof` 命令执行文件重写
- 触发阈值时
	- `auto-aof-rewrite-percentage 100`：aof 文件比上次文件，增长超过多少 100% 则触发重写
	- `auto-aof-rewrite-min-size 64mb`：aof 文件触发重写的最小体积为 64m

### RDB AOF 对比

文件大小：

- RDB 文件存储的内容是**经过压缩的二进制数据**， 保存着某个时间点的数据集，文件很小
- AOF 文件存储的是每一次写命令，通常会比 RDB 文件大很多。

数据恢复速度：

- RDB 文件直接解析还原数据即可，很快
- AOF 则需要依次执行每个写命令，速度非常慢

数据完整性：

- RDB 生成 RDB 文件的过程是比较繁重的，没有办法实时或者秒级持久化数据，两次备份之间会丢失
- AOF 支持**秒级数据丢失**，完整性高

版本兼容：

- RDB 文件是以特定的二进制格式保存的，在 Redis 版本演进中有多个版本的 RDB，所以存在**老版本的 Redis 服务不兼容新版本的 RDB 格式**的问题。

系统资源占用：

- RDB 高，大量 CPU 和内存消耗
	- 例如，BGSAVE 生成 RDB 文件 不会阻塞主线程，但会对机器的 CPU 和内存资源产生影响
- AOF 低，主要是磁盘 IO 资源
	- **重写期间**会占用大量 CPU 和内存资源：重写期间到达的所有写入命令都会**写入磁盘两次**。（Redis 7.0 版本之前）

> AOF 文件重写期间，Redis 还会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会**将重写缓冲区中的所有内容追加到新 AOF 文件的末尾**，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。

综上：

- Redis 保存的数据**丢失一些也没什么影响**的话，可以选择使用 RDB。
- **不建议单独使用 AOF**，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。
- 如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。

# ---------- 集群

## 主从复制

如何保证 Redis 服务高可用? 最简单的一种办法就是==基于 主从复制 搭建一个 Redis 集群==，master（主节点）要负责处理写请求，slave（从节点）主要负责处理读请求

### 什么是主从复制？

简单来说，主从复制 就是==将一台 Redis 主节点的数据复制到其他的 Redis 从节点中==，尽**最大可能**保证 Redis 主节点和从节点的数据是一致的。

- 主从复制这种方案不仅保障了 Redis 服务的高可用，还实现了**读写分离**，提高了系统的并发量，尤其是读并发量。
- Redis Sentinel 以及 Redis Cluster 都**依赖**于主从复制

在指定从节点执行 replicaof 命令开启主从关系

```properties
replicaof <masterip> <masterport>

# 7002和7003执行
replicaof 192.168.111.154 7001
```

### 主从复制下从节点会主动删除过期数据吗?

#todo

### 主从复制过程(1)

- *全量同步*：master 将完整内存数据生成 RDB，发送 RDB 到 slave。后续命令则记录在 `repl_baklog`，逐个发送给 slave
- *增量同步*：slave 提交自己的 offset 到 master，master 获取 repl baklog 中从 offset 之后的命令给 slave

每一个 master 都有唯一的 replid，slave 则会**继承** master 节点的 replid（第一次 master 会把 replid 给 slave）

流程

- slave 节点执行 `replicaof`，请求数据同步，把 replid 和 offset 传给 master
- master 节点判断 replid，
	- replid 不一致，说明是第一次同步数据，**全量同步**
		- master 将完整内存数据生成 RDB（bgsave），发送 RDB 到 slave
		- slave 清空本地数据，加载 master 的 RDB
		- master 将 RDB 期间的命令记录在 `repl baklog`，并持续将 log 中的命令发送给 slave
		- slave 执行接收到的命令，保持与 master 之间的同步
	- replid 一致，master 查看 slave 传来的 offset，master 的同步进度必须比 slave 更快并且两者的同步进度必须在规定范围，
		- 未超过 `repl backlog` 的大小（能在 `repl_baklog` 中能找到 offset 时），**增量同步**
		- 否则，**全量同步**操作

### 为什么主从全量复制使用 RDB 而不是 AOF?

- RDB 文件更节省带宽，传输速度快
- 恢复大数据集的时候，RDB 速度更快
- AOF 需要选择合适的刷盘策略，如果刷盘策略选择不当的话，会影响 Redis 的正常运行。并且，根据所使用的刷盘策略，AOF 的速度可能会慢于 RDB。

## 哨兵

### 什么是哨兵，有什么用？

Sentinel 只是 Redis 的一种**运行模式**，

- 不提供读写服务，
- 默认运行在 26379 端口上，
- 依赖于 Redis 工作

Redis Sentinel 实现 Redis 集群高可用，只是在主从复制实现集群的**基础**上，多了一个 Sentinel 角色来帮助我们

- _监控_：Sentinel 会不断检查 redis 节点状态
- _自动故障恢复_（故障转移）：如果 master 故障，Sentinel 会将一个 slave 提升为 master。当故障实例恢复后也以新的 master 为主
- _通知_：Sentinel 充当 Redis 客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给 Redis 的客户端

### 如何检测节点是否下线

Sentinel 基于**心跳机制**监测服务状态，每隔 1 秒向集群的每个实例发送 **ping 命令**：

- _主观下线_：sentinel 发现某实例未在规定时间（down-after-milliseconds）响应，则认为该实例主观下线
- _客观下线_：若**超过指定数量**（quorum）的 sentinel 都认为该实例主观下线，则该实例客观下线（quorum 最好超过总数量一半）

如果被认定为主观下线的是 slave 的话， sentinel不会做什么事情

如果是 master 被认定为主观下线，所有 sentinel 节点要以每秒一次的频率确认 master 的确下线了，当法定数量的 sentine 节点认定 master 已经下线， master 才被判定为 客观下线

### 哨兵选主过程(1)

sentinel 如何在 slave 中选择一个新的 master？

- *筛选出在线的 slave*：判断 slave 节点与 master 节点断开时间长短，如果超过指定值(`down-after-milliseconds*10`)则会排除该 slave 节点
- *slave-prority 优先级*：slave 节点的 slave-priority 越小优先级越高（特殊值 0 表示永不参与选举）
- *复制进度 offset*：如果 slave-prority 一样，则判断 slave 节点的 offset 值，越大说明数据越新，优先级越高
- *runid*：最后判断 slave 节点的运行 id 大小，越小优先级越高

当选中了其中一个 slave 为新的 master 后，**故障转移的步骤**如下：

- sentinel 给**备选 slave** 节点发送 `slaveof no one` 命令，让该节点成为 master
- sentinel 给所有**其它 slave** 发送 `slaveof <masterip> <masterport>` 命令，让这些 slave 成为新 master 的从节点，开始从新的 master 上同步数据。
- 最后，sentinel 将**故障节点**标记为 slave（强行修改配置文件），当故障节点恢复后会自动成为新的 master 的 slave 节点

### sentinel 可以防止脑裂吗？

#todo

## 分片(1)

#todo



## redis 集群，批量获取 key 会有什么问题

> 如果保证了相同业务场景的key都写入了一个主节点，这是再使用mget，会不会有什么问题
> 
> 解决集群中批量获取的问题，应该怎么做？


# ---------- 未知

## CAP 理论

## redis 怎么优化内存占用的？

> redis数据结构是怎么优化内存空间使用的

## 网络模型

