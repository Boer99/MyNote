# ---------- 简历写法

## 通用

- #todo 用户登录：使用 Redis 实现分布式登录 Session，解决集群间登录态同步
- #todo 使用 Knife4j+ Swagger 自动生成**后端接口文档**，并通过编写 ApiOperation 等注解补充接口注释，避免了人工编写维护文档的麻烦。
- #todo 

## 伙伴匹配

基于 Vue3+SpringBoot2 的移动端网站，实现了用户管理、按标签检索用户、推荐相似用户、组队功能

- #todo 使用 Easy Excel 读取收集来的基础用户信息，并通过**自定义线程池 + CompletableFuture** 并发编程提高批量导入数据库的性能。
	- 实测导入 100w 行的时间从 xx 秒缩短至 xx 秒
- #todo 使用 Redis **缓存**首页高频访问的用户信息列表，将接口响应时长从 xx 秒缩短至 xx 秒。且通过自定义 **Redis 序列化器**来解决数据乱码、空间浪费的问题。
- #todo 使用 Spring Scheduler 定时任务来实现**缓存预热**，解决首次访问系统的用户主页加载过慢的问题。并通过**分布式锁**保证多机部署时定时任务不会重复执行
- #todo 使用 Redisson 分布式锁解决同一用户**重复加入**队伍、**入队人数超限**的问题，保证了接口幂等性。
- #todo 使用**编辑距离算法**实现了根据标签匹配最相似用户的功能，并通过**优先队列**来减少 TOP N 运算过程中的内存占用

> - 前端使用 Vant UI 组件库，并封装了全局通用的 Layout 组件，使主页、搜索页、组队页布局一致、并减少重复代码。
> - 基于 Vue Router 全局路由守卫实现了根据不同页面来动态切换导航栏标题，并通过在全局路由配置文件扩展 title 字段来减少无意义的 if else 代码。


## 商铺点评

项目介绍：  
基于 Spring Boot + Redis 的店铺点评 APP，实现了找店铺 => 写点评 => 看热评 => 点赞关注 => 关注 Feed 流的完整业务流程。  
  
主要工作：  
- #todo 使用 Hash 代替 String 来存储用户信息，节约了 xx% 的内存并便于单字段的修改。（需要自己实际测试对比数据，节省内存的原因是不用保存序列化对象信息或者 JSON 的一些额外字符串）  
- 店铺查询：使用 Redis 对高频访问店铺进行缓存，降低 DB 压力同时提升 90% 的数据查询性能。  
- #todo 为方便其他业务后续使用缓存，使用泛型 + 函数式编程实现了**通用缓存**访问静态方法，并解决了**缓存雪崩、缓存穿透**等问题。  
- 使用常量类全局管理 Redis Key 前缀、TTL 等，保证了键空间的业务隔离，减少冲突。
- 在系统用户量不大的前提下，基于推模式实现**关注 Feed 流**，保证了新点评消息的及时可达，并减少用户访问的等待时间。
- 优惠券**秒杀**：使用 Redis + Lua 脚本实现库存预检，并通过 Stream 队列实现订单的异步创建，解决了超卖问题、实现一人一单。实现相比传统数据库，秒杀性能提高了 xx%。（需要自己实际测试对比数据）

Redis的数据结构运用
- 使用 Redis 的 【Geo + Hash】 数据结构分类存储附近商户，并使用 Geo Search 命令实现高性能商户查询及**按距离排序**。  
- 使用 Redis 【Set】 数据结构**存储用户点赞**信息，并基于 【ZSet】 实现 TopN **点赞排行**，实测相对于 DB 查询性能提升 xx%。（需要自己实际测试对比数据）  
- 使用 Redis 【Set】 数据结构实现**用户关注**、**共同关注**功能（交集），实测相对于 DB 查询性能提升 xx%。（需要自己实际测试对比数据）  
- 使用 Redis 【BitMap】 实现用户**连续签到统计**功能，相对于传统关系库存储，节约 xx% 的内存并提升 xx% 的查询性能。（需要自己实际测试对比数据）

# ---------- 通用

## Knife4j 和 Swagger 自动生成后端接口文档

拦截器拦截 Knife4j 页面

- 配置拦截规则，排除路径

线上环境屏蔽

- 在配置类上加 `@Profile()` 注解，使其只在部分环境生效

# ---------- 商铺点评

## 为什么选择使用 Redis 实现分布式 Session？

代替 Tomcat 本地的 Session 存储

- 本地 Session 好处是不需要返回登录凭证（SessionId 存在 Cookie 里，客户端请求会携带 SessionId）
- 但是集群下多台 tomcat 不共享 session 存储空间
- Redis 存储 Session 能够在**分布式多机场景**下保证获取登录用户信息的一致性

简单实现：

- 只需要引入 Redis 和 **spring-session-data-redis** 依赖，然后在配置文件中指定 Redis 的地址和 session 的 store-type 为 redis，即可自动生效，不用自己额外编码。

## 验证码登录、注册、认证流程

> 核心：两个键值对，**手机号+验证码**，**token+用户信息**

发送验证码（模拟）

- 客户端提交手机号（校验）
- 生成验证码
- 存入 redis：key= `phone:手机号`，value=验证码
	- 设置 TTL
- 验证码发给手机

验证码登录、注册

- 客户端提交 手机号、验证码、用户信息
- redis 验证
- 数据库查询手机号
	- 不存在，创建新用户
- 存入 redis：key= `token:随机值`，value=用户信息
	- 用户信息脱敏（手机号、昵称、头像地址）
- token 返回给客户端

校验登录状态

- token 刷新拦截器（所有路径）
	- 请求头携带 token
		- 没 token，**放行**
	- redis 取出用户信息
		- 没有（假 token，过期），**放行**
		- 有，保存到 ThreadLocal，刷新  TTL
	- 放行

- 登录校验拦截器（排除 首页、登录页等）
	- ThreadLocal
		- 有用户信息，放行
		- 没有，拦截，登录去

使用 Hash 代替 json 字符串 存储用户信息

- Redis 的 Hash 结构，能够对用户每个属性独立 CRUD，而不是更新和返回整个 JSON 字符串，性能会更高

> 例如，获取用户的昵称（就 4 个字符串），但是用户的简介有 100 KB 的大小。如果用 Hash 结构，可以只获取昵称，网络传输的内容大小就很小；而如果用 String 结构整体存储，网络传输数据时会把所有的用户信息都返回出来，增加传输开销。  

## 秒杀业务怎么实现的

### 超卖问题怎么解决(1)

超卖：多个线程并行查询 stock=1，以为库存充足，都去 stock-=1，stock 变成了负数

CAS 法解决：库存充足，扣减库存的时候判断 stock>0 才能扣减

> #todo 利用了 mysql 的锁？

```java
// 判断库存是否充足
if (voucher.getStock() < 1) {
    return Result.fail("库存不足");
}
// 扣减库存
boolean success = seckillVoucherService.update()
        .setSql("stock=stock-1")
        .eq("voucher_id", voucherId)
        // 乐观锁，大于0
        .gt("stock",0).update(); 
if (!success) {
    return Result.fail("库存不足");
}
```

### 一人一单问题怎么解决

问题描述：**同一个用户多个线程都未创建过订单**，并行执行判断订单是否存在，结果是都不存在，出现一人多单

解决方案：分布式锁

- 给每个用户加锁：用户 ID 作为 key
- value 存放当前线程标识（UUID+线程 id）防止锁误删
- lua 脚本保证 判断锁标识 和 释放锁 的原子性

### 优惠券库存扣减和创建订单 同时成功或失败？

把库存扣减和订单创建放在一个事务里

- 放在一个方法上，加上 `@Transactional`

外层调用导致事务方法导致事务失效怎么办？

- `AopContext.currentProxy()` 获取当前类代理对象，来调用事务方法

```java
IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
        return proxy.createVoucherOrder(voucherId);
```

## 缓存和数据库是怎么保证一致性的(2)

> 如果在缓存还没过期的时间内，数据库的数据就发生变更了怎么办

旁路缓存模式

- 数据库更新后删除缓存

## 探店笔记点赞

blog 点赞功能：

- 显示点赞数、是否点赞过
- 只能点赞一次，点赞/取消点赞

实现
- Redis 的 Set 集合存放是否点赞
	- kv 设计： **key=blogId，value 存储点赞过的 userId**
	- `SISMEMBER k v` 判断 userId 是否在 Set 里存在
- Blog 类添加一个 isLike 字段（只用于返回，db 表里没有）

## 你的消息队列里面存的是什么内容

> 1. 如果进队列前返回给用户成功，但是实际上库存已经不足了，这时候进消息队列了，用户实际上是抢不到票的，这个问题你怎么解决的。
