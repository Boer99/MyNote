## 什么情况下会出现数据库和缓存不一致的问题？

==出现了缓存和数据的双写==

**非并发**：缓存的操作和数据库的操作，一个成功一个失败

**写并发**：先写数据库再写缓存，或者先写缓存再写数据库

**读写并发**：假如一个读线程，在读缓存的时候没查到值，他就会去数据库中查询，但是如果自查询到结果之后，更新缓存之前，数据库被更新了，但是这个读线程是完全不知道的，那么就导致最终缓存会被重新用一个”旧值”覆盖掉

> 读写并发的概率较低，因为一般一个读操作是很快的，数据库+缓存的读操作基本在十几毫秒左右就可以完成了。而在这期间，刚好另一个线程执行了一个比较耗时的写操作的概率确实比较低。

而在这期间，刚好另一个线程执行了一个比较耗时的写操作的概率确实比较低。

[✅什么情况下会出现数据库和缓存不一致的问题？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/xr0h8h)


## 怎么保证缓存和数据库的一致性？ #美团24

[✅如何解决Redis和数据库的一致性问题？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/tmcgo0#fFIts)

典型回答：
1. 采用 Cache Aside Pattern（旁路缓存模式）
2. 先更新数据库，再删除缓存
3. 延迟双删：先删除缓存，再更新数据库，再删除一次缓存

### （一）删除缓存 而不是 更新缓存?

更新缓存的动作，相比于直接删除缓存，比较的复杂（更新时间越长越容易引发并发问题）

> 我们放到缓存中的数据，很多时候可能不只是简单的一个字符串类型的值，他还可能是一个大的 JSON 串，一个 map 类型等等。
> 
> 那就需要从缓存中查出数据，反序列化，修改字段，再序列化，再更新到缓存中

在"写写并发"的场景中，如果同时更新缓存和数据库，那么很容易会出现因为并发的问题导致数据不一致的情况

- 先写数据库，缓存可能是脏的
- 先写缓存，数据库可能是脏的

在"写写并发"的场景中，缓存中的数据都是要被清除的，所以就不会出现数据不一致的问题。

### （二）先写数据库还是先删缓存？

在“读写并发”场景下，删除缓存依旧会导致数据不一致性


| 写线程   | 读线程   |
| ----- | ----- |
| 删除缓存  |       |
|       | 缓存未命中 |
|       | 查询数据库 |
|       | 写入缓存  |
| 更新数据库 |       |


| 读线程   | 写线程   |
| ----- | ----- |
| 缓存未命中 |       |
| 查询数据库 |       |
|       | 更新数据库 |
|       | 删除缓存  |
| 写入缓存  |       |

先删缓存更容易导致数据不一致，因为==缓存的速度高于数据库很多==

> 先删缓存，更新数据库操作较慢，更新完之前，可能会有读线程重建缓存，缓存里就是脏数据

此外，删缓存和写数据库不是原子操作，==后删缓存失败了，也会导致不一致==

### （三）延迟双删

[✅为什么需要延迟双删，两次删除的原因是什么？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/uswtlzlot2lcvy10)

为了避免因为先删除缓存而导致的”读写并发问题“被放大的情况，所以引入了第二次缓存删除。


## 扩展思路

### 只读缓存



### 消息队列补偿

删除失败的缓存，作为消息打入 mq，mq 消费者进行监听，再次进行重试刷缓存

## canal

监听数据库的变化，做一个公共服务，专门来对接缓存刷新。优点业务解耦，业务太多冗余代码复杂度。