# 刷题记录

> 2023年12月18日

[二分查找](#二分查找)
[移除元素](#移除元素)

> 2023年12月19日

[有序数组的平方](#有序数组的平方)
[长度最小的子数组](#长度最小的子数组)

> 2023年12月20日

[螺旋矩阵](#螺旋矩阵)
[移除链表元素](#移除链表元素)

> 2023年12月21日

[反转链表](#反转链表)
[两两交换链表中的节点](#两两交换链表中的节点)

> 2023年12月22日

[删除链表的倒数第N个节点](#删除链表的倒数第N个节点)

> 2023年12月23日

[链表相交](#链表相交)
[环形链表 II](#环形链表%20II)

> 2023年12月24日

[有效的字母异位词](#有效的字母异位词)
[两个数组的交集](#两个数组的交集)

> 2023年12月25日

[快乐数](#快乐数)
[两数之和](#两数之和)

> 2023年12月26日

[四数相加](#四数相加)
[赎金信](#赎金信)

> 2023年12月27日

[三数之和](#三数之和)
[四数之和](#四数之和)

# 方法总结

- 双指针
	- 快慢指针
	- 双向指针
- 递归
- 哈希（空间换时间）

# 数组

## 二分查找

> 给定一个 n 个元素**有序的**（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在**返回下标**，否则返回 -1。
> 
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。
>    
>  https://leetcode.cn/problems/binary-search

**二分的前提条件：** 有序、无重复

```java
// 双向指针
public int search(int[] nums, int tg) {
	int len = nums.length;
	for (int l = 0, r = len - 1; l <= r; ){
		int mid = (l + r) / 2;
		if (nums[mid] == tg) {
			return mid;
		}
		if (nums[mid] > tg) {
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}      
	return -1;
}
```

> 时间：`O(log n)`
> 空间：`O(1)`

## 移除元素

> 给你一个数组 nums 和一个值 val，你需要 **原地** 移除所有数值等于 val 的元素，并**返回移除后数组的新长度**。
> - 不要使用额外的数组空间，你必须仅使用 **O(1) 额外空间**并原地修改输入数组。
> - 元素的顺序可以改变。你**不需要考虑数组中超出新长度后面的元素**。
> 
> 说明：
> - `0 <= nums.length <= 100` (包括空数组)
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
> 
> **示例 2：**
> 输入：`nums = [0,1,2,2,3,0,4,2]`, `val = 2`
> 输出：5, `nums = [0,1,3,0,4]`
> 解释：函数应该返回新的长度 `5`, 并且 nums 中的前五个元素
> `[0,1,3,0,4]`。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> 
> [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**特例：**`1,1,1...,1`  (一个数组里全是要删除的)

```java
public class Solution {
    public static void main(String[] args) {
        // 随机生成nums1
        int[] nums1 = new int[1000000];
        int max = 50, min = 0;
        for (int i = 0; i < nums1.length; i++) {
            // 生成随机整数，范围在[minValue, maxValue]
            nums1[i] = new Random().nextInt((max - min + 1)) + min;
        }
        for (int i : nums1) {
            System.out.print(i + " ");
        }
        System.out.println();
        // 硬拷贝nums1给nums2
        int[] nums2 = Arrays.copyOf(nums1, nums1.length);

        int val = 10;

        TestTimeConsumingUtils t1 = new TestTimeConsumingUtils();
        System.out.println("快慢双指针结果：" + removeElement(nums1, val));
        t1.printTime("快慢双指针");

        TestTimeConsumingUtils t2 = new TestTimeConsumingUtils();
        System.out.println("相向双指针结果：" + removeElement2(nums2, val));
        t2.printTime("相向双指针");
    }

    /**
     * 快慢双指针
     */
    public static int removeElement(int[] nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }

    /**
     * 相向双指针
     */
    public static int removeElement2(int[] nums, int val) {
        int len = nums.length;
        if (len == 0 || (len == 1 && nums[0] == val)) return 0;
        int l = 0;
        for (int r = len - 1; l <= r; ) {
            if (nums[l] != val) {
                l++;
                continue;
            }
            while (nums[r] == val && r > 0) {
                r--;
            }
            nums[l] = nums[r--];
        }
        return l;
    }
}

/**
 * 测试代码执行时间
 */
class TestTimeConsumingUtils {
    // 当前时间
    private long thisCurrentTimeMillis = System.currentTimeMillis();

    /**
     * @param desc 输入描述信息
     */
    public void printTime(String desc) {
        long result = System.currentTimeMillis() - thisCurrentTimeMillis;
        System.err.println(desc + "耗时：" + result);
    }
}
```

> 快慢指针
> 时间：`O(n)`
> 空间：`O(1)`
> 
> 双向指针
> 时间：`O(n)`
> 空间：`O(1)`

## 有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 nums，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
> 
> 示例：
> - 输入：`nums = [-7,-3,2,3,11]`
> - 输出：`[4,9,9,49,121]`
> 
> 说明：
> - `1 <= nums.length <= 10^4`
> - `-10^4 <= nums[i] <= 10^4`
> 
> [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

有负数，如果都是正数直接平方就好了

一直纠结O(1)的复杂度没做出来

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{-4, -1, 0, 3, 10};
        for (int i : sortedSquares(nums)) {
            System.out.print(i + " ");
        }
    }

    /**
     * 双向指针
     */
    public static int[] sortedSquares(int[] nums) {
        int len = nums.length;
        int[] res = new int[nums.length];
        int i = len - 1; // 结果数组索引
        for (int l = 0, r = len - 1; l <= r; ) {
            if (Math.pow(nums[l], 2) > Math.pow(nums[r], 2)) {
                res[i--] = (int) Math.pow(nums[l++], 2);
            } else {
                res[i--] = (int) Math.pow(nums[r--], 2);
            }
        }
        return res;
    }
}
```

>  双向指针
> 时间：`O(n)`
> 空间：`O(n)`


## 长度最小的子数组

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其**和 大于等于 s 的长度最小的 连续** 子数组，并**返回其长度**。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> - 输入：`target = 7`, `nums = [2,3,1,2,4,3]`
> - 输出：2
> - 解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。
> 
> 说明：
> - `1 <= target <= 10^9`
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^5`

滑动窗口（双指针）

实现滑动窗口，主要确定如下三点：
1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的结束位置？

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3, 4, 5};
        int tar = 11;
        System.out.println(minSubArrayLen(tar, nums));
    }

    public static int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        int res = len + 1;
        int sum = 0;
        for (int l = 0, r = 0; r <= len - 1; r++) {
            sum += nums[r];
            while (sum >= target) {
                res = Math.min(res, r - l + 1);
                sum -= nums[l++];
            }
        }
        return res == len + 1 ? 0 : res;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)`

## 螺旋矩阵

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按**顺时针顺序螺旋排列**的正方形矩阵。
> 
> 示例：
> - 输入：`n = 3`
> - 输出：`[[1,2,3],[8,9,4],[7,6,5]]`
> 
> 说明：
>  - `1 <= n <= 20`
> 
> [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

模拟过程，每次循环画完一圈

坚持**循环不变量原则**，每一圈四条边，每条边保持左闭右开

---
By Boer

```java
class Solution {  
    public static void main(String[] args) {  
        generateMatrix(3);  
    }  
  
    public static int[][] generateMatrix(int n) {  
        int[][] res = new int[n][n];  
        // n为单数需要补中心点
        res[(n - 1) / 2][(n - 1) / 2] = n * n;  
        int y = 0; // 起始位置  
        int x = 1; // 1~n^2  
        for (int i = y, j = y; n >= 0; n--, y++, i = y, j = y) {  
            while (j < n - 1) {  
                res[i][j++] = x++;  
            }  
            while (i < n - 1) {  
                res[i++][j] = x++;  
            }  
            while (j > y) {  
                res[i][j--] = x++;  
            }  
            while (i > y) {  
                res[i--][j] = x++;  
            }  
        }  
        return res;  
    }  
}
```

--- 
参考代码

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0;  // 控制循环次数
        int[][] res = new int[n][n];
        int start = 0;  // 每次循环的开始点(start, start)
        int count = 1;  // 定义填充数字
        int i, j;

        while (loop++ < n / 2) { // 判断边界后，loop从1开始
            // 模拟上侧从左到右
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }

            // 模拟右侧从上到下
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }

            // 模拟左侧从下到上
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }

        return res;
    }
}
```

> 本题模拟过程，时空复杂度不必在意 	
> 时间：`O(n^2)`
> 空间：`O(1)`

# 链表

## 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你**删除**链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
> 
> 示例：
> - 输入：`head = [1,2,6,3,4,5,6], val = 6`
> - 输出：`[1,2,3,4,5]`
>  
> 说明：
> - 列表中的节点数目在范围 `[0, 10^4]` 内 （包含空链表）
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`
>    
> [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

特例：`[val,...,val]` 一个及以上的val组成的链表

**虚拟头结点**
- ==统一==头结点和其他节点的删除操作
- 初始虚拟头结点需要存档一份，用于后续返回（特例情况下原先的头结点指向的是旧链表）

```java
class Solution {  
    public ListNode removeElements(ListNode head, int val) {  
        ListNode dummy = new ListNode(-1, head); // 前置指针  
        ListNode pre = dummy; // 前置指针存档  
        while (pre.next != null) {  
            if (pre.next.val == val) {  
                pre.next = pre.next.next;  
            } else {  
                pre = pre.next;  
            }  
        }  
        return dummy.next;  
    }  
}
```

> 时间：`O(n)`
> 空间：`O(1)`

## 设计链表

> 你可以选择使用单链表或者双链表，设计并实现自己的链表。 
> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
> 
> 实现 `MyLinkedList` 类：
> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。
> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 
> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
>  - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
>  - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
>  - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
> 
> 示例：
>  
> 说明：
>  
> [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)


```java
```

## 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表
> 
> 示例：
> - 输入：`head = [1,2,3,4,5]`
> - 输出：`[5,4,3,2,1]`
>  
> 说明：
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>    
> [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)


--- 
双指针 正向翻转

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode pre = null;  
        ListNode temp = null;  
        while (head != null) {  
            temp = head.next;  
            head.next = pre;  
            pre = head;  
            head = temp;  
        }  
        return pre;  
    }  
}
```

> 时间：`O(n)`
> 空间：`O(1)`  

--- 
递归：正向翻转
- 需要两个指针实现
- 先翻转再递归调用

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
	    // 终止条件
        if (cur == null) {
            return prev;
        }
        // 反转操作
        ListNode temp = null;
        temp = cur.next; // 先保存下一个节点
        cur.next = prev; 
        // 递归调用
        return reverse(cur, temp);
    }
}
```

> 时间：`O(n)`
> 空间：`O(n)` n层栈

--- 
递归：反向翻转
- 单指针即可实现。
- 先递归调用再翻转

```java
class Solution {
    public ListNode reverseList(ListNode head) {
	    // 终止条件
        if (head == null || head.next == null) return head; 
        // 递归调用，记录尾节点
        ListNode last = reverseList(head.next);
        // 反转操作
        head.next.next = head;
        head.next = null;
        // 每层递归都把尾节点返回
        return last;
    }
}
```

> 时间：`O(n)`
> 空间：`O(n)` n层栈

## 两两交换链表中的节点

> 给定一个链表，**两两交换**其中相邻的节点，并返回交换后的链表。
> 你必须在不修改节点内部的值的情况下完成本题（即，**只能进行节点交换**）
> 
> 示例：
> - 输入：`head = [1,2,3,4]`
> - 输出：`[2,1,4,3]`
>  
> 说明：
> - 链表中节点的数目在范围 `[0, 100]` 内
> - `0 <= Node.val <= 100`
>    
> [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

递归

```java
class Solution {  
    public ListNode swapPairs(ListNode head) {  
        // 终止条件  
        if (head == null || head.next == null) return head;  
        // 递归调用  
        head.next.next = swapPairs(head.next.next);  
        // 两两交换  
        ListNode next = head.next;  
        head.next = next.next;  
        next.next = head;  
        return next;  
    }  
}
```

> 时间：`O(n)`
> 空间：`O(n)`


## 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
> 
> 示例：
> - 输入：`head = [1,2,3,4,5], n = 2`
> - 输出：`[1,2,3,5]`
>  
> 说明：
> - 链表中结点的数目为 `sz`
> - `1 <= sz <= 30`
> - `0 <= Node.val <= 100`
> - `1 <= n <= sz`
>    
> [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

快慢指针

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1,head);
        ListNode s=dummy;
        ListNode f=dummy;
        for(int i=0;i<=n;i++){
            f=f.next;
        }
        while(f!=null){
            f=f.next;
            s=s.next;
        }
        s.next=s.next.next;
        return dummy.next;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)`

## 链表相交

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表**相交的起始节点**。如果两个链表没有交点，返回 `null` 。
> 
> 题目数据 保证 整个链式结构中不存在环。
> 
> 注意，函数返回结果后，链表必须 **保持其原始结构** 。
> 
> 示例：
> - 输入：`intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3`
> - 输出：`Intersected at '8'`
> - 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 `[4,1,8,4,5]`，链表 B 为 `[5,0,1,8,4,5]`。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点
> 
> 说明：
> - `listA` 中节点数目为 `m`
> - `listB` 中节点数目为 `n`
> - `0 <= m, n <= 3 * 104`
> - `1 <= Node.val <= 105`
> - `0 <= skipA <= m`
> - `0 <= skipB <= n`
> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`
>   
> 进阶：你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？
> 
> [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

双指针

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA=headA;
        ListNode curB=headB;
        int lenA=0, lenB=0;
        int gap; //长度差 >=0
        while(curA!=null){
            lenA++;
            curA=curA.next;
        }
        while(curB!=null){
            lenB++;
            curB=curB.next;
        }
        if(lenA>lenB){
            curA=headA;
            curB=headB;
            gap=lenA-lenB;
        }else{
            curA=headB;
            curB=headA;
            gap=lenB-lenA;
        }
        // 长的先动
        while(gap-->0){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;
            }
            curA=curA.next;
            curB=curB.next;
        }
        return null;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)`

## 环形链表 II

> 给定一个链表的头节点  `head` ，返回链表**开始入环的第一个节点**。 如果链表无环，则返回 `null`。
> 
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。
> 
> 示例：
> - 输入：`head = [3,2,0,-4], pos = 1`
> - 输出：返回索引为 1 的链表节点
> - 解释：链表中有一个环，其尾部连接到第二个节点。
>  
> 说明：
> - 链表中节点的数目在范围 `[0, 104]` 内 （包含空）
> - `-10……5 <= Node.val <= 10……5`
> - `pos` 的值为 `-1` 或者链表中的一个有效索引
>    
> [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

快慢指针。数学问题，记就完事了

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode f=head, s=head;
        while(f!=null && f.next!=null){
            f=f.next.next;
            s=s.next;
            if(f==s){
                s=head;
                while(f!=s){
                    f=f.next;
                    s=s.next;
                }
                return f;
            }
        }
        return null;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)

# 哈希表

## 有效的字母异位词

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
> 
> 注意：若 s 和 t 中**每个字符出现的次数都相同**，则称 s 和  t 互为字母异位词
> 
> 示例：
> - 输入: `s = "anagram", t= "nagaram"`
> - 输出: `true`
>  
> 说明：
> - `1 <= s.length, t.length <= 5 * 10^4`
> - `s` 和 `t` 仅包含小写字母
>    
> [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)


```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] arr=new int[26];
        for(int i=0;i<s.length();i++){
            arr[s.charAt(i)-'a']++;
        }
        for(int i=0;i<t.length();i++){
            arr[t.charAt(i)-'a']--;
        }
        for(int i:arr){
            if(i!=0) return false;
        }
        return true;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)

## 两个数组的交集

> 给定两个数组 `nums1` 和 `nums2` ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 **不考虑输出结果的顺序** 。
> 
> 示例：
> - 输入: `nums1 = [4,9,5], nums2 = [9,4,9,8,4]`
> - 输出: `[9,4] or [4,9]`
> 
> 说明：
> - `1 <= nums1.length, nums2.length <= 1000
> - `0 <= nums1[i], nums2[i] <= 1000` （都可能是空数组）
>    
> [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

--- 
双Set

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Set<Integer> res = new HashSet<>();
        for (int i : nums1) {
            set.add(i);
        }
        for (int i : nums2) {
            if (set.contains(i)) res.add(i);
        }
        return res.stream().mapToInt(x -> x).toArray();
    }
}
```

> 时间：`O(m+n)`，其中 m 和 n 分别是两个数组的长度。
> 	- 使用两个集合分别存储两个数组中的元素需要 `O(m+n)` 的时间，
> 	- 遍历较小的集合并判断元素是否在另一个集合中需要 `O(min⁡(m,n))` 的时间，
> 空间：`O(m+n)`，两个集合存储

---
数组哈希

> 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：`0<=nums1[i], nums2[i]<=1000`

使用set 不仅占用空间比数组大，而且速度要比数组慢（hash计算）。在数据量大的情况，差距是很明显的

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] hash1 = new int[1002]; // 下标 1-1001
        int[] hash2 = new int[1002];
        for (int i : nums1)
            hash1[i]++;
        for (int i : nums2)
            hash2[i]++;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < 1002; i++)
            if (hash1[i] > 0 && hash2[i] > 0) res.add(i);
        return res.stream().mapToInt(x -> x).toArray();
    }
}
```

> 时间：`O(m+n)`，其中 m 和 n 分别是两个数组的长度。
> 空间：`O(n)`，短的数组长度

## 快乐数

> 编写一个算法来判断一个数 `n` 是不是快乐数。
> 
> **「快乐数」** 定义为：
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
> 
> 如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。
> 
> 示例：
> 输入：`n = 19`
> 输出：`true`
>  
> 说明：
> - `1 <= n <= 2^31 - 1`
> 
> [202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

```java
class Solution {
    public boolean isHappy(int n) {
        int tmp=0;
        Set rec=new HashSet();
        while(n!=1 && !rec.contains(n)){
            rec.add(n);
            // 求出快乐数 tmp
            while(n!=0){
                tmp+=(n%10)*(n%10);
                n=n/10;
            }
            n=tmp;
            tmp=0;
        }
        return n==1;
    }
}
```

> 时间：`O(log n)`
> 空间：`O(log n)

## 两数之和

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。
> 
> - 你可以**假设每种输入只会对应一个答案**。但是，数组中同一个元素在答案里不能重复出现。
> - 你可以按任意顺序返回答案。
> 
> 示例：
> - 输入：`nums = [2,7,11,15], target = 9`
> - 输出：`[0,1]`
> - 解释：因为 `nums[0] + nums[1] == 9` ，返回 `[0, 1]` 。
>  
> 说明：
> - `2 <= nums.length <= 10^4`
> - `10^9 <= nums[i] <= 10^9`
> - `10^9 <= target <= 10^9`
> 
> 进阶：你可以想出一个**时间复杂度小于 `O(n^2)`** 的算法吗？
> 
> [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

--- 
by Boer（待优化）
```java
class Solution {
   public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rec = new HashMap();
        int temp;
        for (int i = 0; i < nums.length; i++) {
            rec.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            temp = target - nums[i];
            if (rec.containsKey(temp) && rec.get(temp)!=i)
                return new int[]{i, rec.get(n)};
        }
        return null;
    }
}
```

> 不用先把所有数组的元素放入map中
> map中查找的时候会重复找到自己 `rec.containsKey(temp) && rec.get(temp)!=i`
> 额外判断会浪费时间

--- 
优化后

```java
class Solution {
   public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rec = new HashMap();
        int temp;
        for (int i = 0; i < nums.length; i++) {
            temp = target - nums[i];
            if (rec.containsKey(temp))
                return new int[]{i, rec.get(temp)};
            rec.put(nums[i],i);
        }
        return null;
    }
}
```

> 时间：`O(n)` ， n 是数组中的元素数量。对于每一个元素 `x`，我们可以 `O(1)` 地寻找 `target - x`
> 空间：`O(n)` 哈希表

## 四数相加

> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算**有多少个元组 `(i, j, k, l)`** 能满足：
> 
> - `0 <= i, j, k, l < n`
> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
> 
> 示例：
> - 输入：`nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]`
> - 输出：2
> - 解释：
> 	- `(0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0`
> 	- `(1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0`
>  
> 说明：
> - `n == nums1.length`
> - `n == nums2.length`
> - `n == nums3.length`
> - `n == nums4.length`
> - `1 <= n <= 200`
> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`
> 
> [454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)

思路和两数之和是一样的

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int len=nums1.length;
        int temp=0, res=0;
        Map<Integer, Integer> map=new HashMap();
        for(int i:nums1){
            for(int j:nums2){
                temp=i+j;
                map.put(temp,map.getOrDefault(temp,0)+1);
            }
        }
        for(int i:nums3){
            for(int j:nums4){
                temp=i+j;
                res+=map.getOrDefault(0-temp,0);
            }
        }
        return res;
    }
}
```

> 时间：`O(n^2)`
> 空间：`O(n^2)`，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2

## 赎金信

> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 **`ransomNote` 能不能由 `magazine` 里面的字符构成。**
> - 如果可以，返回 `true` ；否则返回 `false` 。
> - `magazine` 中的**每个字符只能在 `ransomNote` 中使用一次。**
> 
> 示例：
> - 输入：`ransomNote = "a", magazine = "b"`
> - 输出：false
>  
> 说明：
> - `1 <= ransomNote.length, magazine.length <= 105`
> - `ransomNote` 和 `magazine` 由**小写英文字母**组成
> 
> [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)

小写字母--->数组哈希。相较于map省空间和时间（直接索引，不用计算哈希值）

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        // Map<Character,Integer> rec=new HashMap();
        int[] rec=new int[26];
        char temp;
        for(char c:magazine.toCharArray()){
            rec[c -'a']+=1;
        }
        for(char c:ransomNote.toCharArray()){
            if(rec[c -'a']==0) return false;
            rec[c -'a']-=1;
        }
        return true;
    }
}
```

> 时间：`O(n)`
> 空间：`O(1)`

## 三数之和

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且**不重复**的三元组。
> 
> 示例：
> - 输入：`nums = [-1,0,1,2,-1,-4]`
> - 输出：`[[-1,-1,2],[-1,0,1]]
> - 解释：`
> 	- `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。`
> 	- `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。`
> 	- `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。`
> 	- 不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]` 。
> 	- 注意，输出的顺序和三元组的顺序并不重要。
>  
> 说明：
> - `3 <= nums.length <= 3000`
> - `-10^5 <= nums[i] <= 10^5`
> 
> [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

双指针：将原本暴力O(n^3)的解法，降为O(n^2)的解法

```java
class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{-1, 0, 1, 2, -1, -4};
        int[] nums1 = new int[]{-2, 0, 0, 2, 2};
        int[] nums2 = new int[]{-2, 0, 3, -1, 4, 0, 3, 4, 1, 1, 1, -3, -5, 4, 0};
        System.out.println(threeSum(nums2));
    }

    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        int l, r;
        for (int i = 0; i < len - 2; i++) {
            // 剪枝：第一个元素已经大于0，没有结果
            if (nums[i] > 0) return res;
            // 元组第一个元素去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            l = i + 1;
            r = len - 1;
            while (l < r) {
                if (nums[l] + nums[r] + nums[i] == 0) {
                    List<Integer> rec = new ArrayList<>();
                    rec.add(nums[i]);
                    rec.add(nums[l]);
                    rec.add(nums[r]);
                    res.add(rec);
                    // 元组第二个元素去重
                    while (++l < r && nums[l] == nums[l - 1]) ;
                    // 元组第三个元素去重
                    while (--r > l && nums[r] == nums[r + 1]) ;
                } else if (nums[l] + nums[r] + nums[i] <= 0) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return res;
    }
}
```

> 时间：`O(n^2)`
> 空间：`O(1)`

## 四数之和

> 给你一个由 `n` 个整数组成的数组 `nums` ，和**一个目标值 `target`** 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
> - `0 <= a, b, c, d < n`
> - `a`、`b`、`c` 和 `d` **互不相同**（两个元组之间）
> - `nums[a] + nums[b] + nums[c] + nums[d] == target`
>
> 你可以按 **任意顺序** 返回答案 。
> 
> 示例：
> - 输入：`nums = [1,0,-1,0,-2,2], target = 0`
> - 输出：`[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`
>  
> 说明：
> - `1 <= nums.length <= 200`
> - `-10^9 <= nums[i] <= 10^9`
> - `-10^9 <= target <= 10^9`
> 
> [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

双指针：将原本暴力O(n^4)的解法，降为O(n^3)的解法

```java
class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{1, 0, -1, 0, -2, 2};
        int target = 0;
        int[] nums1 = new int[]{2, 2, 2, 2, 2};
        int target1 = 8;
        int[] nums2 = new int[]{0, 0, 0, 0};
        int target2 = 0;
        System.out.println(fourSum(nums2, target2));
    }

    public static List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        int l, r;
        for (int i = 0; i < len - 3; i++) {
            // 剪枝
            if (nums[i] > target && nums[i] >= 0) return res;
            // 元组第一个元素去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < len - 2; j++) {
                // 元组第二个元素去重
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                l = j + 1;
                r = len - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));
                        // 元组第二个元素去重
                        while (++l < r && nums[l] == nums[l - 1]) ;
                        // 元组第三个元素去重
                        while (--r > l && nums[r] == nums[r + 1]) ;
                    } else if (sum <= target) {
                        l++;
                    } else {
                        r--;
                    }
                }
            }
        }
        return res;
    }
}
```

> 时间：`O(n^3)`
> 空间：`O(1)`