# 刷题记录

## 23_12(24题)

> 2023年12月18日

[二分查找](#二分查找)
[移除元素](#移除元素)

> 2023年12月19日

[有序数组的平方](#有序数组的平方)
[长度最小的子数组](#长度最小的子数组)

> 2023年12月20日

[螺旋矩阵](#螺旋矩阵)
[移除链表元素](#移除链表元素)

> 2023年12月21日

[反转链表](#反转链表)
[两两交换链表中的节点](#两两交换链表中的节点)

> 2023年12月22日

[删除链表的倒数第N个节点](#删除链表的倒数第N个节点)

> 2023年12月23日

[链表相交](#链表相交)
[环形链表 II](#环形链表%20II)

> 2023年12月24日

[有效的字母异位词](#有效的字母异位词)
[两个数组的交集](#两个数组的交集)

> 2023年12月25日

[快乐数](#快乐数)
[两数之和](#两数之和)

> 2023年12月26日

[四数相加](#四数相加)
[赎金信](#赎金信)

> 2023年12月27日

[三数之和](#三数之和)
[四数之和](#四数之和)

> 2023年12月28日

[反转字符串](#反转字符串)
[反转字符串 II](#反转字符串%20II)

> 2023年12月30日

[反转字符串中的单词](#反转字符串中的单词)
[用栈实现队列](#用栈实现队列)
[用队列实现栈(1)](#用队列实现栈(1))

## 24_01(35题)

> 2024年1月3日

[找出字符串中第一个匹配项的下标](#找出字符串中第一个匹配项的下标)
[反转字符串中的单词](#反转字符串中的单词)
[删除字符串中的所有相邻重复项](#删除字符串中的所有相邻重复项)

> 2024年1月4日

[重复的子字符串(1)](#重复的子字符串(1))
[逆波兰表达式求值](#逆波兰表达式求值)

> 2024年1月5日

[二叉树的递归遍历](#二叉树的递归遍历)
[二叉树的迭代遍历](#二叉树的迭代遍历)

> 2024年1月6日

[二叉树的层序遍历(1)](#二叉树的层序遍历(1))
[二叉树的层序遍历II](#二叉树的层序遍历II)

> 2024年1月7日

[翻转二叉树](#翻转二叉树)
[对称二叉树(1)](#对称二叉树(1))

> 2024年1月8日

[二叉树的最大深度](#二叉树的最大深度)
[二叉树的最小深度](#二叉树的最小深度)

> 2024年1月9日

[完全二叉树的节点个数](#完全二叉树的节点个数)
[平衡二叉树](#平衡二叉树)

> 2024年1月10日

[二叉树的所有路径](#二叉树的所有路径)
[左叶子之和](#左叶子之和)

> 2024年1月11日

[找树左下角的值(1)](#找树左下角的值(1))
[路径总和](#路径总和)

> 2024年1月12日

[从中序与后序遍历序列构造二叉树(1)]( #从中序与后序遍历序列构造二叉树 (1))

> 2024年1月13日

[最大二叉树](#最大二叉树)
[合并二叉树(1)]( #合并二叉树 (1))

> 2024年1月14日

[二叉搜索树中的搜索](#二叉搜索树中的搜索)
[验证二叉搜索树(1)](#验证二叉搜索树(1))

> 2024 年 1 月 18 日

[二叉搜索树的最小绝对差](#二叉搜索树的最小绝对差)

> 2024 年 1 月 19 日

[二叉搜索树中的众数 (1)](#二叉搜索树中的众数%20(1))

> 2024 年 1 月 20 日

[二叉树的最近公共祖先](#二叉树的最近公共祖先)

> 2024 年 1 月 21 日

[二叉树搜索树的最近公共祖先 (1)]( #二叉树搜索树的最近公共祖先 (1))

> 2024 年 1 月 22 日

[二叉树搜索树中的插入操作](#二叉树搜索树中的插入操作)

> 2024 年 1 月 25 日

[删除二叉搜索树中的节点 (1)](#删除二叉搜索树中的节点%20(1))

> 2024 年 1 月 27 日

[修建二叉搜索树(1)](#修建二叉搜索树(1))

> 2024 年 1 月 28 日

[将有序数组转换为二叉搜索树](#将有序数组转换为二叉搜索树)

> 2024年1月29日

[把二叉搜索树转换为累加树](#把二叉搜索树转换为累加树)

> 2024年1月30日

[滑动窗口最大值](#滑动窗口最大值)

> 2024年1月31日

[补充：完全二叉树插入器 (1)](#补充：完全二叉树插入器%20(1))

## 24_02


> 2024年2月1日

[组合](#组合)

> 2024年2月2日

[组合总数 III](#组合总数%20III)

> 2024年2月3日

[电话号码的字母组合(1)](#电话号码的字母组合(1))

> 2024年2月4日

[组合总和(1)](#组合总和(1))

> 2024年2月6日

[组合总和 2(1)](#组合总和%202(1))

> 2024年2月7日

[分割回文串(1)](#分割回文串(1))

> 2024年2月13日

[复原 IP 地址](#复原%20IP%20地址)

> 2024年2月14日

[子集](#子集)

> 2024年2月15日

[子集II](#子集II)

> 2024年2月16日

[非递减子序列](#非递减子序列)

> 2024年2月19日

[全排列](#全排列)

> 2024年2月21日

[全排列II](#全排列II)

> 2024年2月26日

[分发饼干](#分发饼干)

# 方法总结

- 双指针
	- 快慢指针
	- 双向指针
- 递归（想象一颗递归树）
- 哈希（空间换时间）
- 回溯

# 数组

## 二分查找

> 给定一个 n 个元素**有序的**（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在**返回下标**，否则返回 -1。
> 
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。
>    
>  https://leetcode.cn/problems/binary-search

**二分的前提条件：** 有序、无重复

```java
// 双向指针
public int search(int[] nums, int tg) {
	int len = nums.length;
	for (int l = 0, r = len - 1; l <= r; ){
		int mid = (l + r) / 2;
		if (nums[mid] == tg) {
			return mid;
		}
		if (nums[mid] > tg) {
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}      
	return -1;
}
```

> 时间：`O(log n)`
> 
> 空间：`O(1)`

## 移除元素

> 给你一个数组 nums 和一个值 val，你需要 **原地** 移除所有数值等于 val 的元素，并**返回移除后数组的新长度**。
> - 不要使用额外的数组空间，你必须仅使用 **O(1) 额外空间**并原地修改输入数组。
> - 元素的顺序可以改变。你**不需要考虑数组中超出新长度后面的元素**。
> 
> 说明：
> - `0 <= nums.length <= 100` (包括空数组)
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
> 
> **示例 2：**
> 输入：`nums = [0,1,2,2,3,0,4,2]`, `val = 2`
> 输出：5, `nums = [0,1,3,0,4]`
> 解释：函数应该返回新的长度 `5`, 并且 nums 中的前五个元素
> `[0,1,3,0,4]`。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> 
> [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**特例：**`1,1,1...,1`  (一个数组里全是要删除的)

```java
public class Solution {
    public static void main(String[] args) {
        // 随机生成nums1
        int[] nums1 = new int[1000000];
        int max = 50, min = 0;
        for (int i = 0; i < nums1.length; i++) {
            // 生成随机整数，范围在[minValue, maxValue]
            nums1[i] = new Random().nextInt((max - min + 1)) + min;
        }
        for (int i : nums1) {
            System.out.print(i + " ");
        }
        System.out.println();
        // 硬拷贝nums1给nums2
        int[] nums2 = Arrays.copyOf(nums1, nums1.length);

        int val = 10;

        TestTimeConsumingUtils t1 = new TestTimeConsumingUtils();
        System.out.println("快慢双指针结果：" + removeElement(nums1, val));
        t1.printTime("快慢双指针");

        TestTimeConsumingUtils t2 = new TestTimeConsumingUtils();
        System.out.println("相向双指针结果：" + removeElement2(nums2, val));
        t2.printTime("相向双指针");
    }

    /**
     * 快慢双指针
     */
    public static int removeElement(int[] nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }

    /**
     * 相向双指针
     */
    public static int removeElement2(int[] nums, int val) {
        int len = nums.length;
        if (len == 0 || (len == 1 && nums[0] == val)) return 0;
        int l = 0;
        for (int r = len - 1; l <= r; ) {
            if (nums[l] != val) {
                l++;
                continue;
            }
            while (nums[r] == val && r > 0) {
                r--;
            }
            nums[l] = nums[r--];
        }
        return l;
    }
}

/**
 * 测试代码执行时间
 */
class TestTimeConsumingUtils {
    // 当前时间
    private long thisCurrentTimeMillis = System.currentTimeMillis();

    /**
     * @param desc 输入描述信息
     */
    public void printTime(String desc) {
        long result = System.currentTimeMillis() - thisCurrentTimeMillis;
        System.err.println(desc + "耗时：" + result);
    }
}
```

> 快慢指针：
> - 时间：`O(n)`
> - 空间：`O(1)`
> 
> 双向指针：
> -时间：`O(n)`
> -空间：`O(1)`

## 有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 nums，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
> 
> 示例：
> - 输入：`nums = [-7,-3,2,3,11]`
> - 输出：`[4,9,9,49,121]`
> 
> 说明：
> - `1 <= nums.length <= 10^4`
> - `-10^4 <= nums[i] <= 10^4`
> 
> [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

双向指针

有负数，如果都是正数直接平方就好了

一直纠结O(1)的复杂度没做出来

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{-4, -1, 0, 3, 10};
        for (int i : sortedSquares(nums)) {
            System.out.print(i + " ");
        }
    }

    /**
     * 双向指针
     */
    public static int[] sortedSquares(int[] nums) {
        int len = nums.length;
        int[] res = new int[nums.length];
        int i = len - 1; // 结果数组索引
        for (int l = 0, r = len - 1; l <= r; ) {
            if (Math.pow(nums[l], 2) > Math.pow(nums[r], 2)) {
                res[i--] = (int) Math.pow(nums[l++], 2);
            } else {
                res[i--] = (int) Math.pow(nums[r--], 2);
            }
        }
        return res;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)`


## 长度最小的子数组

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其**和 大于等于 s 的长度最小的 连续** 子数组，并**返回其长度**。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> - 输入：`target = 7`, `nums = [2,3,1,2,4,3]`
> - 输出：2
> - 解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。
> 
> 说明：
> - `1 <= target <= 10^9`
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^5`

滑动窗口（双指针）

实现滑动窗口，主要确定如下三点：
1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的结束位置？

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3, 4, 5};
        int tar = 11;
        System.out.println(minSubArrayLen(tar, nums));
    }

    public static int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        int res = len + 1;
        int sum = 0;
        for (int l = 0, r = 0; r <= len - 1; r++) {
            sum += nums[r];
            while (sum >= target) {
                res = Math.min(res, r - l + 1);
                sum -= nums[l++];
            }
        }
        return res == len + 1 ? 0 : res;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 螺旋矩阵

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按**顺时针顺序螺旋排列**的正方形矩阵。
> 
> 示例：
> - 输入：`n = 3`
> - 输出：`[[1,2,3],[8,9,4],[7,6,5]]`
> 
> 说明：
>  - `1 <= n <= 20`
> 
> [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

模拟过程，每次循环画完一圈

坚持**循环不变量原则**，每一圈四条边，每条边保持左闭右开

---
By Boer

```java
class Solution {  
    public static void main(String[] args) {  
        generateMatrix(3);  
    }  
  
    public static int[][] generateMatrix(int n) {  
        int[][] res = new int[n][n];  
        // n为单数需要补中心点
        res[(n - 1) / 2][(n - 1) / 2] = n * n;  
        int y = 0; // 起始位置  
        int x = 1; // 1~n^2  
        for (int i = y, j = y; n >= 0; n--, y++, i = y, j = y) {  
            while (j < n - 1) {  
                res[i][j++] = x++;  
            }  
            while (i < n - 1) {  
                res[i++][j] = x++;  
            }  
            while (j > y) {  
                res[i][j--] = x++;  
            }  
            while (i > y) {  
                res[i--][j] = x++;  
            }  
        }  
        return res;  
    }  
}
```

--- 
参考代码

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0;  // 控制循环次数
        int[][] res = new int[n][n];
        int start = 0;  // 每次循环的开始点(start, start)
        int count = 1;  // 定义填充数字
        int i, j;

        while (loop++ < n / 2) { // 判断边界后，loop从1开始
            // 模拟上侧从左到右
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }

            // 模拟右侧从上到下
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }

            // 模拟左侧从下到上
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }

        return res;
    }
}
```

> 本题模拟过程，时空复杂度不必在意 	
> 
> 时间：`O(n^2)`
> 
> 空间：`O(1)`

# 链表

## 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你**删除**链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
> 
> 示例：
> - 输入：`head = [1,2,6,3,4,5,6], val = 6`
> - 输出：`[1,2,3,4,5]`
>  
> 说明：
> - 列表中的节点数目在范围 `[0, 10^4]` 内 （包含空链表）
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`
>    
> [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

特例：`[val,...,val]` 一个及以上的val组成的链表

**虚拟头结点**
- ==统一==头结点和其他节点的删除操作
- 初始虚拟头结点需要存档一份，用于后续返回（特例情况下原先的头结点指向的是旧链表）

```java
class Solution {  
    public ListNode removeElements(ListNode head, int val) {  
        ListNode dummy = new ListNode(-1, head); // 前置指针  
        ListNode pre = dummy; // 前置指针存档  
        while (pre.next != null) {  
            if (pre.next.val == val) {  
                pre.next = pre.next.next;  
            } else {  
                pre = pre.next;  
            }  
        }  
        return dummy.next;  
    }  
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 设计链表

> 你可以选择使用单链表或者双链表，设计并实现自己的链表。 
> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
> 
> 实现 `MyLinkedList` 类：
> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。
> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 
> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
>  - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
>  - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
>  - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
> 
> 示例：
>  
> 说明：
>  
> [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)


```java
```

## 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表
> 
> 示例：
> - 输入：`head = [1,2,3,4,5]`
> - 输出：`[5,4,3,2,1]`
>  
> 说明：
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>    
> [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)


--- 
双指针 正向翻转

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode pre = null;  
        ListNode temp = null;  
        while (head != null) {  
            temp = head.next;  
            head.next = pre;  
            pre = head;  
            head = temp;  
        }  
        return pre;  
    }  
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`  

--- 
递归：正向翻转
- 需要两个指针实现
- 先翻转再递归调用

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
	    // 终止条件
        if (cur == null) {
            return prev;
        }
        // 反转操作
        ListNode temp = null;
        temp = cur.next; // 先保存下一个节点
        cur.next = prev; 
        // 递归调用
        return reverse(cur, temp);
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` n层栈

--- 
递归：反向翻转
- 单指针即可实现。
- 先递归调用再翻转

```java
class Solution {
    public ListNode reverseList(ListNode head) {
	    // 终止条件
        if (head == null || head.next == null) return head; 
        // 递归调用，记录尾节点
        ListNode last = reverseList(head.next);
        // 反转操作
        head.next.next = head;
        head.next = null;
        // 每层递归都把尾节点返回
        return last;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` n层栈

## 两两交换链表中的节点

> 给定一个链表，**两两交换**其中相邻的节点，并返回交换后的链表。
> 你必须在不修改节点内部的值的情况下完成本题（即，**只能进行节点交换**）
> 
> 示例：
> - 输入：`head = [1,2,3,4]`
> - 输出：`[2,1,4,3]`
>  
> 说明：
> - 链表中节点的数目在范围 `[0, 100]` 内
> - `0 <= Node.val <= 100`
>    
> [24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/)

递归

```java
class Solution {  
    public ListNode swapPairs(ListNode head) {  
        // 终止条件  
        if (head == null || head.next == null) return head;  
        // 递归调用  
        head.next.next = swapPairs(head.next.next);  
        // 两两交换  
        ListNode next = head.next;  
        head.next = next.next;  
        next.next = head;  
        return next;  
    }  
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)`


## 删除链表的倒数第N个节点

> 给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。
> 
> 示例：
> - 输入：`head = [1,2,3,4,5], n = 2`
> - 输出：`[1,2,3,5]`
>  
> 说明：
> - 链表中结点的数目为 `sz`
> - `1 <= sz <= 30`
> - `0 <= Node.val <= 100`
> - `1 <= n <= sz`
>    
> [19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

快慢指针

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(-1,head);
        ListNode s=dummy;
        ListNode f=dummy;
        for(int i=0;i<=n;i++){
            f=f.next;
        }
        while(f!=null){
            f=f.next;
            s=s.next;
        }
        s.next=s.next.next;
        return dummy.next;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 链表相交

> 给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表**相交的起始节点**。如果两个链表没有交点，返回 `null` 。
> 
> 题目数据 保证 整个链式结构中不存在环。
> 
> 注意，函数返回结果后，链表必须 **保持其原始结构** 。
> 
> 示例：
> - 输入：`intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3`
> - 输出：`Intersected at '8'`
> - 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 `[4,1,8,4,5]`，链表 B 为 `[5,0,1,8,4,5]`。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点
> 
> 说明：
> - `listA` 中节点数目为 `m`
> - `listB` 中节点数目为 `n`
> - `0 <= m, n <= 3 * 104`
> - `1 <= Node.val <= 105`
> - `0 <= skipA <= m`
> - `0 <= skipB <= n`
> - 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
> - 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`
>   
> 进阶：你能否设计一个时间复杂度 `O(n)` 、仅用 `O(1)` 内存的解决方案？
> 
> [面试题 02.07. 链表相交 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

双指针

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA=headA;
        ListNode curB=headB;
        int lenA=0, lenB=0;
        int gap; //长度差 >=0
        while(curA!=null){
            lenA++;
            curA=curA.next;
        }
        while(curB!=null){
            lenB++;
            curB=curB.next;
        }
        if(lenA>lenB){
            curA=headA;
            curB=headB;
            gap=lenA-lenB;
        }else{
            curA=headB;
            curB=headA;
            gap=lenB-lenA;
        }
        // 长的先动
        while(gap-->0){
            curA=curA.next;
        }
        while(curA!=null){
            if(curA==curB){
                return curA;
            }
            curA=curA.next;
            curB=curB.next;
        }
        return null;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 环形链表 II

> 给定一个链表的头节点  `head` ，返回链表**开始入环的第一个节点**。 如果链表无环，则返回 `null`。
> 
> 如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。注意：`pos` 不作为参数进行传递，仅仅是为了标识链表的实际情况。
> 
> 示例：
> - 输入：`head = [3,2,0,-4], pos = 1`
> - 输出：返回索引为 1 的链表节点
> - 解释：链表中有一个环，其尾部连接到第二个节点。
>  
> 说明：
> - 链表中节点的数目在范围 `[0, 104]` 内 （包含空）
> - `-10……5 <= Node.val <= 10……5`
> - `pos` 的值为 `-1` 或者链表中的一个有效索引
>    
> [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/)

快慢指针。数学问题，记就完事了

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode f=head, s=head;
        while(f!=null && f.next!=null){
            f=f.next.next;
            s=s.next;
            if(f==s){
                s=head;
                while(f!=s){
                    f=f.next;
                    s=s.next;
                }
                return f;
            }
        }
        return null;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)

# 哈希表

## 有效的字母异位词

> 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。
> 
> 注意：若 s 和 t 中**每个字符出现的次数都相同**，则称 s 和  t 互为字母异位词
> 
> 示例：
> - 输入: `s = "anagram", t= "nagaram"`
> - 输出: `true`
>  
> 说明：
> - `1 <= s.length, t.length <= 5 * 10^4`
> - `s` 和 `t` 仅包含小写字母
>    
> [242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/)


```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] arr=new int[26];
        for(int i=0;i<s.length();i++){
            arr[s.charAt(i)-'a']++;
        }
        for(int i=0;i<t.length();i++){
            arr[t.charAt(i)-'a']--;
        }
        for(int i:arr){
            if(i!=0) return false;
        }
        return true;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)

## 两个数组的交集

> 给定两个数组 `nums1` 和 `nums2` ，返回 它们的交集 。输出结果中的每个元素一定是 唯一 的。我们可以 **不考虑输出结果的顺序** 。
> 
> 示例：
> - 输入: `nums1 = [4,9,5], nums2 = [9,4,9,8,4]`
> - 输出: `[9,4] or [4,9]`
> 
> 说明：
> - `1 <= nums1.length, nums2.length <= 1000
> - `0 <= nums1[i], nums2[i] <= 1000` （都可能是空数组）
>    
> [349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

--- 
双Set

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Set<Integer> res = new HashSet<>();
        for (int i : nums1) {
            set.add(i);
        }
        for (int i : nums2) {
            if (set.contains(i)) res.add(i);
        }
        return res.stream().mapToInt(x -> x).toArray();
    }
}
```

> 时间：`O(m+n)`，其中 m 和 n 分别是两个数组的长度。
> 	- 使用两个集合分别存储两个数组中的元素需要 `O(m+n)` 的时间，
> 	- 遍历较小的集合并判断元素是否在另一个集合中需要 `O(min⁡(m,n))` 的时间，
> 空间：`O(m+n)`，两个集合存储

---
数组哈希

> 力扣改了 题目描述 和 后台测试数据，增添了 数值范围：`0<=nums1[i], nums2[i]<=1000`

使用set 不仅占用空间比数组大，而且速度要比数组慢（hash计算）。在数据量大的情况，差距是很明显的

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        int[] hash1 = new int[1002]; // 下标 1-1001
        int[] hash2 = new int[1002];
        for (int i : nums1)
            hash1[i]++;
        for (int i : nums2)
            hash2[i]++;
        List<Integer> res = new ArrayList<>();
        for (int i = 0; i < 1002; i++)
            if (hash1[i] > 0 && hash2[i] > 0) res.add(i);
        return res.stream().mapToInt(x -> x).toArray();
    }
}
```

> 时间：`O(m+n)`，其中 m 和 n 分别是两个数组的长度。
> 
> 空间：`O(n)`，短的数组长度

## 快乐数

> 编写一个算法来判断一个数 `n` 是不是快乐数。
> 
> **「快乐数」** 定义为：
> - 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
> - 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
> - 如果这个过程 **结果为** 1，那么这个数就是快乐数。
> 
> 如果 `n` 是 _快乐数_ 就返回 `true` ；不是，则返回 `false` 。
> 
> 示例：
> 输入：`n = 19`
> 输出：`true`
>  
> 说明：
> - `1 <= n <= 2^31 - 1`
> 
> [202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

```java
class Solution {
    public boolean isHappy(int n) {
        int tmp=0;
        Set rec=new HashSet();
        while(n!=1 && !rec.contains(n)){
            rec.add(n);
            // 求出快乐数 tmp
            while(n!=0){
                tmp+=(n%10)*(n%10);
                n=n/10;
            }
            n=tmp;
            tmp=0;
        }
        return n==1;
    }
}
```

> 时间：`O(log n)`
> 
> 空间：`O(log n)

## 两数之和

> 给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** _`target`_  的那 **两个** 整数，并返回它们的数组下标。
> 
> - 你可以**假设每种输入只会对应一个答案**。但是，数组中同一个元素在答案里不能重复出现。
> - 你可以按任意顺序返回答案。
> 
> 示例：
> - 输入：`nums = [2,7,11,15], target = 9`
> - 输出：`[0,1]`
> - 解释：因为 `nums[0] + nums[1] == 9` ，返回 `[0, 1]` 。
>  
> 说明：
> - `2 <= nums.length <= 10^4`
> - `10^9 <= nums[i] <= 10^9`
> - `10^9 <= target <= 10^9`
> 
> 进阶：你可以想出一个**时间复杂度小于 `O(n^2)`** 的算法吗？
> 
> [1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/)

--- 
by Boer（待优化）
```java
class Solution {
   public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rec = new HashMap();
        int temp;
        for (int i = 0; i < nums.length; i++) {
            rec.put(nums[i], i);
        }
        for (int i = 0; i < nums.length; i++) {
            temp = target - nums[i];
            if (rec.containsKey(temp) && rec.get(temp)!=i)
                return new int[]{i, rec.get(n)};
        }
        return null;
    }
}
```

> 不用先把所有数组的元素放入map中
> map中查找的时候会重复找到自己 `rec.containsKey(temp) && rec.get(temp)!=i`
> 额外判断会浪费时间

--- 
优化后

```java
class Solution {
   public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> rec = new HashMap();
        int temp;
        for (int i = 0; i < nums.length; i++) {
            temp = target - nums[i];
            if (rec.containsKey(temp))
                return new int[]{i, rec.get(temp)};
            rec.put(nums[i],i);
        }
        return null;
    }
}
```

> 时间：`O(n)` ， n 是数组中的元素数量。对于每一个元素 `x`，我们可以 `O(1)` 地寻找 `target - x`
> 
> 空间：`O(n)` 哈希表

## 四数相加

> 给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算**有多少个元组 `(i, j, k, l)`** 能满足：
> 
> - `0 <= i, j, k, l < n`
> - `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
> 
> 示例：
> - 输入：`nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]`
> - 输出：2
> - 解释：
> 	- `(0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0`
> 	- `(1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0`
>  
> 说明：
> - `n == nums1.length`
> - `n == nums2.length`
> - `n == nums3.length`
> - `n == nums4.length`
> - `1 <= n <= 200`
> - `-228 <= nums1[i], nums2[i], nums3[i], nums4[i] <= 228`
> 
> [454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/)

思路和两数之和是一样的

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        int len=nums1.length;
        int temp=0, res=0;
        Map<Integer, Integer> map=new HashMap();
        for(int i:nums1){
            for(int j:nums2){
                temp=i+j;
                map.put(temp,map.getOrDefault(temp,0)+1);
            }
        }
        for(int i:nums3){
            for(int j:nums4){
                temp=i+j;
                res+=map.getOrDefault(0-temp,0);
            }
        }
        return res;
    }
}
```

> 时间：`O(n^2)`
> 
> 空间：`O(n^2)`，最坏情况下A和B的值各不相同，相加产生的数字个数为 n^2

## 赎金信

> 给你两个字符串：`ransomNote` 和 `magazine` ，判断 **`ransomNote` 能不能由 `magazine` 里面的字符构成。**
> - 如果可以，返回 `true` ；否则返回 `false` 。
> - `magazine` 中的**每个字符只能在 `ransomNote` 中使用一次。**
> 
> 示例：
> - 输入：`ransomNote = "a", magazine = "b"`
> - 输出：false
>  
> 说明：
> - `1 <= ransomNote.length, magazine.length <= 105`
> - `ransomNote` 和 `magazine` 由**小写英文字母**组成
> 
> [383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/)

小写字母--->数组哈希。相较于map省空间和时间（直接索引，不用计算哈希值）

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        // Map<Character,Integer> rec=new HashMap();
        int[] rec=new int[26];
        char temp;
        for(char c:magazine.toCharArray()){
            rec[c -'a']+=1;
        }
        for(char c:ransomNote.toCharArray()){
            if(rec[c -'a']==0) return false;
            rec[c -'a']-=1;
        }
        return true;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 三数之和

> 给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且**不重复**的三元组。
> 
> 示例：
> - 输入：`nums = [-1,0,1,2,-1,-4]`
> - 输出：`[[-1,-1,2],[-1,0,1]]
> - 解释：`
> 	- `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。`
> 	- `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。`
> 	- `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。`
> 	- 不同的三元组是 `[-1,0,1]` 和 `[-1,-1,2]` 。
> 	- 注意，输出的顺序和三元组的顺序并不重要。
>  
> 说明：
> - `3 <= nums.length <= 3000`
> - `-10^5 <= nums[i] <= 10^5`
> 
> [15. 三数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/3sum/)

双指针：将原本暴力O(n^3)的解法，降为O(n^2)的解法

```java
class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{-1, 0, 1, 2, -1, -4};
        int[] nums1 = new int[]{-2, 0, 0, 2, 2};
        int[] nums2 = new int[]{-2, 0, 3, -1, 4, 0, 3, 4, 1, 1, 1, -3, -5, 4, 0};
        System.out.println(threeSum(nums2));
    }

    public static List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        int l, r;
        for (int i = 0; i < len - 2; i++) {
            // 剪枝：第一个元素已经大于0，没有结果
            if (nums[i] > 0) return res;
            // 元组第一个元素去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            l = i + 1;
            r = len - 1;
            while (l < r) {
                if (nums[l] + nums[r] + nums[i] == 0) {
                    List<Integer> rec = new ArrayList<>();
                    rec.add(nums[i]);
                    rec.add(nums[l]);
                    rec.add(nums[r]);
                    res.add(rec);
                    // 元组第二个元素去重
                    while (++l < r && nums[l] == nums[l - 1]) ;
                    // 元组第三个元素去重
                    while (--r > l && nums[r] == nums[r + 1]) ;
                } else if (nums[l] + nums[r] + nums[i] <= 0) {
                    l++;
                } else {
                    r--;
                }
            }
        }
        return res;
    }
}
```

> 时间：`O(n^2)`
> 
> 空间：`O(1)`

## 四数之和

> 给你一个由 `n` 个整数组成的数组 `nums` ，和**一个目标值 `target`** 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：
> - `0 <= a, b, c, d < n`
> - `a`、`b`、`c` 和 `d` **互不相同**（两个元组之间）
> - `nums[a] + nums[b] + nums[c] + nums[d] == target`
>
> 你可以按 **任意顺序** 返回答案 。
> 
> 示例：
> - 输入：`nums = [1,0,-1,0,-2,2], target = 0`
> - 输出：`[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]`
>  
> 说明：
> - `1 <= nums.length <= 200`
> - `-10^9 <= nums[i] <= 10^9`
> - `-10^9 <= target <= 10^9`
> 
> [18. 四数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/4sum/)

双指针：将原本暴力O(n^4)的解法，降为O(n^3)的解法

```java
class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{1, 0, -1, 0, -2, 2};
        int target = 0;
        int[] nums1 = new int[]{2, 2, 2, 2, 2};
        int target1 = 8;
        int[] nums2 = new int[]{0, 0, 0, 0};
        int target2 = 0;
        System.out.println(fourSum(nums2, target2));
    }

    public static List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> res = new ArrayList<>();
        Arrays.sort(nums);
        int len = nums.length;
        int l, r;
        for (int i = 0; i < len - 3; i++) {
            // 剪枝
            if (nums[i] > target && nums[i] >= 0) return res;
            // 元组第一个元素去重
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < len - 2; j++) {
                // 元组第二个元素去重
                if (j > i + 1 && nums[j] == nums[j - 1]) continue;
                l = j + 1;
                r = len - 1;
                while (l < r) {
                    int sum = nums[i] + nums[j] + nums[l] + nums[r];
                    if (sum == target) {
                        res.add(Arrays.asList(nums[i], nums[j], nums[l], nums[r]));
                        // 元组第二个元素去重
                        while (++l < r && nums[l] == nums[l - 1]) ;
                        // 元组第三个元素去重
                        while (--r > l && nums[r] == nums[r + 1]) ;
                    } else if (sum <= target) {
                        l++;
                    } else {
                        r--;
                    }
                }
            }
        }
        return res;
    }
}
```

> 时间：`O(n^3)`
> 
> 空间：`O(1)`

# 字符串

## 反转字符串

> 编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。
> 
> 不要给另外的数组分配额外的空间，你必须**原地**修改输入数组、使用 O(1) 的额外空间解决这一问题。
> 
> 示例：
> - 输入：`s = ["h","e","l","l","o"]`
> - 输出：`["o","l","l","e","h"]`
>  
> 说明：
> - `1 <= s.length <= 105`
> - `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符
> 
> [344. 反转字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string/)

双指针

```java
class Solution {
    public void reverseString(char[] s) {
        int len=s.length;
        int l=0;
        int r=len-1;
        char temp;
        while(l<r){
            temp=s[l];
            s[l++]=s[r];
            s[r--]=temp;
        }
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 反转字符串 II

>  给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，**每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符**。
>  - 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
> - 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。
> 
> 示例：
> - 输入：`s = "abcdefg", k = 2`
> - 输出：`"bacdfeg"`
>  
> 说明：
> - `1 <= s.length <= 10^4`
> - `s` 仅由小写英文组成
> - `1 <= k <= 10^4`
> 
> [541. 反转字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-string-ii/)

双指针

```java
class Solution {
    public String reverseStr(String s, int k) {
        char[] chs = s.toCharArray();
        int len = s.length();
        int l, r;
        char temp;
        for (int i = 0; i < len; i += 2 * k) {
            l = i;
            r = Math.min(l + k - 1, len - 1);
            while (l < r) {
                temp = chs[l];
                chs[l++] = chs[r];
                chs[r--] = temp;
            }
        }
        return new String(chs);
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 反转字符串中的单词

> 给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。
> 
> 单词 是由非空格字符组成的字符串。`s` 中使用**至少一个空格**将字符串中的 单词 分隔开。
> 
> **返回**：单词 **顺序颠倒**且 单词 之间用**单个空格连接**的结果字符串。
> 
> 注意：输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
> 
> 示例：
> - 输入：s = "`  the sky is blue`"
> - 输出："`blue is sky the`"
>  
> 说明：
> - `1 <= s.length <= 104`
> - `s` 包含英文大小写字母、数字和空格 `' '`
> - `s` 中 **至少存在一个** 单词
>   
>   进阶：如果字符串在你使用的编程语言中是一种可变数据类型，请尝试使用 `O(1)` 额外空间复杂度的 **原地 解法**。
> 
> [151. 反转字符串中的单词 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-words-in-a-string/)

**可变字符串stringbuilder**

Java中String的底层是字符数组，多余的空格是无法原地去除的，必须要另起一个数组。

stringbuilder底层也是字符数组，但会自动控制容量

```java
class Solution {
    StringBuilder sb;
    int l, r;
    char temp;

    public String reverseWords(String s) {
        // System.out.println(s);
        sb = new StringBuilder();
        l = 0;
        r = s.length() - 1;
        // ----- 消除多余空格
        // 消除头尾
        while (s.charAt(l) == ' ') l++;
        while (s.charAt(r) == ' ') r--;
        int k = 0;
        while (l <= r) {
            temp = s.charAt(l);
            // 连续空格只保留一个
            if (temp != ' ' || sb.charAt(sb.length() - 1) != ' ') {
                sb.append(temp);
            }
            l++;
        }
        // ----- 整体换
        int len = sb.length();
        l = 0;
        r = len - 1;
        reverse(l, r);
        // ----- 局部换
        for (int i = 0; i <= len - 1; i++) {
            if (sb.charAt(i) == ' ') continue;
            l = r = i;
            while (++r <= len - 1 && sb.charAt(r) != ' ') ;
            i = r--;
            reverse(l, r);
        }
        return new String(sb);
    }

    public void reverse(int l, int r) {
        while (l < r) {
            temp = sb.charAt(l);
            sb.setCharAt(l++, sb.charAt(r));
            sb.setCharAt(r--, temp);
        }
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)`

---
数组

![](assets/Pasted%20image%2020240110192718.png)

## 找出字符串中第一个匹配项的下标(KMP)(1)

> 实现C语言的 strstr() 以及 Java的 indexOf() 

> 给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串的**第一个匹配项的下标**（下标从 0 开始）。如果 `needle` 不是 `haystack` 的一部分，则返回  `-1` 。
> 
> 示例：
> - 输入：`haystack = "sadbutsad", needle = "sad"`
> - 输出：0
> - 解释：`"sad"` 在下标 0 和 6 处匹配。
> - 第一个匹配项的下标是 0 ，所以返回 0 。
>  
> 说明：
> - `1 <= haystack.length, needle.length <= 104`
> - `haystack` 和 `needle` 仅由小写英文字符组成
> 
> [28. 找出字符串中第一个匹配项的下标 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)
> 
>  [代码随想录 (programmercarl.com)](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html#%E6%80%9D%E8%B7%AF)

前缀表
- 作用：前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，**模式串应该从哪里开始重新匹配**
- 约等于 next 数组
	- next数组既可以就是前缀表，
	- 也可以是前缀表统一减一（右移一位，初始位置为-1）
- 记录下标 i 之前（包括 i ）的字符串中，最长相等前后缀

最长**相等**前后缀：
- 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串
- 后缀：不包含第一个字符的所有以最后一个字符结尾的连续子串。

![](assets/Pasted%20image%2020240102232241.png)
找到的不匹配的位置 f， 那么此时我们要看它的前一个字符的前缀表的数值是多少，因为要找前面字符串的最长相同的前缀和后缀，前缀和后缀既然相等就不用匹配了。

```java
class Solution {  
    /**  
     * 获取next数组  
     * - 双指针 (i,j)，i 永不回退  
     * - j指向前缀末尾位置，i指向后缀末尾位置  
     * - next[j]就是j位置的最长相等前后缀长度  
     *  
     * @param next 前缀表  
     * @param s    模式串  
     */  
    void getNext(int[] next, char[] s) {  
        // next[0] = 0;  
        for (int i = 1, j = 0; i <= s.length - 1; i++) {  
            // 不相等就回退。1）回退到next[j]的前一个位置 2）回退到j=0就从头开始匹配了，不用退了
            while (j > 0 && s[i] != s[j]) {  
                // j之前的子串已经匹配了，那么[0~j-1]区间的最长相等前后缀就不用再匹配了  
                j = next[j - 1];  
            }  
            if (s[i] == s[j]) {  
                // j+1就是当前的最长相等前后缀长度（j是索引，长度要+1）  
                next[i] = ++j;  
                continue;  
            }  
            // j已经回退到指向第一个元素，并且chs[i]!=chs[j]  
            next[i] = 0;  
        }  
    }  
  
    public int strStr(String pp, String ss) {  
        char[] p = pp.toCharArray();  
        char[] s = ss.toCharArray();  
        int[] next = new int[ss.length()];  
        getNext(next, s);  
        // i永不回退  
        for (int i = 0, j = 0; i < p.length; i++) {  
            while (j > 0 && p[i] != s[j]) {  
                // j之前的子串已经匹配了，那么[0~j-1]区间的最长相等前后缀就不用再匹配了  
                j = next[j - 1];  
            }  
            if (p[i] == s[j]) {  
                j++;  
            }  
            if (j == s.length) return i - j + 1;  
        }  
        return -1;  
    }  
  
    public static void main(String[] args) {  
        Solution run = new Solution();  
        int res = run.strStr("aabaabab", "abab");  
        System.out.println(res);  
    }  
}
```

> 时间：`O(m+n)` ，`O(m)`求ss， `O(n)`匹配（最多遍历一次pp）
> 
> 空间：`O(m)` next数组

## 重复的子字符串(1)

>  给定一个非空的字符串 `s` ，检查是否可以通过由它的一个子串重复**多次**构成。
> 
> 示例：
> - 输入: s = `"abab"`
> - 输出: `true`
> - 解释: 可由子串 "ab" 重复两次构成。
>  
> 说明：
> - `1 <= s.length <= 10^4`
> - `s` 仅由小写英文组成
> - `1 <= k <= 10^4`
> 
> [459. 重复的子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-substring-pattern/)

**移位匹配**

多次 “移位” 字符串，并使其与原始字符串匹配。例如：`abcabc`  移位一次：`cabcab`   移位两次：`bcabca`   移位三次：`abcabc`。

基于这个思想，可以每次移动k个字符，直到匹配移动 `length - 1` 次，但如果 s 很长的话，效率很低。

可以让 str=s+s=abcabcabcabc，str中包含了所有abcabc移动的可能，用一个大小为`s.length()`的滑动窗口遍历：bcabca，cabcab，abcabc。
- 注意窗口的位置，第一个和最后一个窗口要去掉。

```java
class Solution {
    public boolean repeatedSubstringPattern(String s) {
        String str = s + s;
        return str.substring(1, str.length() - 1).contains(s);
    }
}
```

> 使用了语言自带的字符串查找函数，因此这里不深入分析其时空复杂度

--- 

KMP 最小重复子串（没研究过推导）

```java
class Solution {
     public boolean repeatedSubstringPattern(String s) {
        char[] chs = s.toCharArray();
        int len = chs.length;
        int[] next = new int[len];
        for (int i = 1, j = 0; i < len; i++) {
            while (j > 0 && chs[i] != chs[j]) {
                j = next[j - 1];
            }
            if (chs[i] == chs[j]) {
                j++;
            }
            next[i] = j;
        }
        // 最小重复子串判断
        return next[len - 1] > 0 && len % (len - next[len - 1]) == 0;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` next数组

# 栈与队列

## 用栈实现队列

>  请你仅使用**两个栈**实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
>
> 实现 `MyQueue` 类：
> - `void push(int x)` 将元素 x 推到队列的末尾
> - `int pop()` 从队列的开头移除并返回元素
> - `int peek()` 返回队列开头的元素
> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`
> 
> 示例：
> - 输入：
> 	- `["MyQueue", "push", "push", "peek", "pop", "empty"]`
> 	- `[[], [1], [2], [], [], []]`
> - 输出：
> 	- `[null, null, null, 1, 1, false]`
> 
> 解释：
> - `MyQueue myQueue = new MyQueue();`
> - `myQueue.push(1); // queue is: [1]`
> - `myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)`
> - `myQueue.peek(); // return 1`
> - `myQueue.pop(); // return 1, queue is [2]`
> - `myQueue.empty(); // return false`
>  
> 说明：
> - `1 <= x <= 9`
> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）
> 
> [232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/)

```java
public class MyQueue {
    private Stack<Integer> inStack = new Stack<>();
    private Stack<Integer> outStack = new Stack<>();

    public MyQueue() {}

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }

    public int peek() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.isEmpty() && outStack.empty();
    }
}
```

## 用队列实现栈(1)

> 请你仅使用**两个队列**实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。
> 
> 实现 `MyStack` 类：
> - `void push(int x)` 将元素 x 压入栈顶。
> - `int pop()` 移除并返回栈顶元素。
> - `int top()` 返回栈顶元素。
> - `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。
> 
> 示例：
> - 输入：
> 	- `["MyStack", "push", "push", "top", "pop", "empty"]`
> 	- `[[], [1], [2], [], [], []]`
> - 输出：
> 	- `[null, null, null, 2, 2, false]`
> 
> 解释：
> - `MyStack myStack = new MyStack();`
> - `myStack.push(1);`
> - `myStack.push(2);`
> - `myStack.top(); // 返回 2`
> - `myStack.pop(); // 返回 2`
> - `myStack.empty(); // 返回 False`
>  
> 说明：
> - `1 <= x <= 9`
> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
> - 每次调用 `pop` 和 `top` 都保证栈不为空
> 
> 进阶：你能否仅用**一个队列**来实现栈。
> 
> [225. 用队列实现栈 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-stack-using-queues/)

思想：每进来一个元素，就把之前进来都出队，再入队到自己后面

```java
class MyStack {
    Queue<Integer> q;

    public MyStack() {
        q = new LinkedList<>(); // 双向链表
    }

    public void push(int x) {
        q.offer(x);
        int size = q.size();
        // 一个元素以上
        while (--size > 0)
            q.offer(q.poll());
    }

    public int pop() {
        return q.poll();
    }

    public int top() {
        return q.peek();
    }

    public boolean empty() {
        return q.isEmpty();
    }
}
```

## 反转字符串中的单词

> 给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
> 
> 有效字符串需满足：
> 
> 1. 左括号必须用相同类型的右括号闭合。
> 2. 左括号必须以正确的顺序闭合。
> 3. 每个右括号都有一个对应的相同类型的左括号。
> 
> 示例：
> - 输入：`s = "()[]{}"`
> - 输出：true
>  
> 说明：
> - `1 <= s.length <= 104`
> - `s` 仅由括号 `'()[]{}'` 组成
> 
> [20. 有效的括号 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-parentheses/)

注意栈空（遍历时、遍历完）的操作

```java
class Solution {  
    public boolean isValid(String s) {  
        Stack<Character> stack = new Stack<>();  
        for (int i = 0; i < s.length(); i++) {  
            if (s.charAt(i) == '(' || s.charAt(i) == '{' || s.charAt(i) == '[') {  
                stack.push(s.charAt(i));  
            }  
            if (stack.isEmpty()) return false;  
            if (s.charAt(i) == ')' && stack.pop() != '(') {  
                return false;  
            }  
            if (s.charAt(i) == '}' && stack.pop() != '{') {  
                return false;  
            }  
            if (s.charAt(i) == ']' && stack.pop() != '[') {  
                return false;  
            }  
        }  
        return stack.isEmpty();  
    }  
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 维护栈

## 删除字符串中的所有相邻重复项

> 给出由小写字母组成的字符串 `S`，重复项删除操作会选择**两个相邻且相同**的字母，并删除它们。
> 
> 在 S 上反复执行重复项删除操作，直到无法继续删除。
> 
> 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。
> 
> 示例：
> - 输入：`"abbaca"`
> - 输出：`"ca"`
> - 解释：
> 	- 例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。
>  
> 说明：
> 1. `1 <= S.length <= 20000`
> 2. `S` 仅由小写英文字母组成。
> 
> [1047. 删除字符串中的所有相邻重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/)

双端队列实现栈。（可以直接用StringBuilder作为栈）

```java
class Solution {  
    public String removeDuplicates(String s) {  
        Deque<Character> dq = new LinkedList<>();  
        dq.push(s.charAt(0));  
        for (int i = 1; i < s.length(); i++) {  
            if (dq.isEmpty()) {  
                dq.push(s.charAt(i));  
                continue;  
            }  
            if (dq.peek() != s.charAt(i)) {  
                dq.push(s.charAt(i));  
            } else {  
                dq.pop();  
            }  
        }  
        StringBuilder sb = new StringBuilder();  
        while (!dq.isEmpty()) sb.append(dq.removeLast());  
        return sb.toString();  
    }  
  
    public static void main(String[] args) {  
        Solution run = new Solution();  
        System.out.println(run.removeDuplicates("avvacgb"));  
    }  
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 维护栈

---
**快慢指针！(1)**

```java
class Solution {  
    public String removeDuplicates(String str) {  
        char[] chs = str.toCharArray();  
        int s = 0, f = 0; // s维护删除后的s  
        while (f < chs.length) {  
            chs[s] = chs[f];  
            if (s > 0 && chs[s] == chs[s - 1]) {  
                s--;  
            } else {  
                s++;  
            }  
            f++;  
        }  
        return new String(chs, 0, s);  
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(1)`

## 逆波兰表达式求值

> 给你一个字符串数组 `tokens` ，表示一个根据 [逆波兰表示法](https://baike.baidu.com/item/%E9%80%86%E6%B3%A2%E5%85%B0%E5%BC%8F/128437) 表示的算术表达式。
> 
> 请你计算该表达式。返回一个表示表达式值的整数。
> 
> **注意：**
> - 有效的算符为 `'+'`、`'-'`、`'*'` 和 `'/'` 。
> - 每个操作数（运算对象）都可以是一个整数或者另一个表达式。
> - 两个整数之间的除法总是 **向零截断** 。
> - 表达式中不含除零运算。
> - 输入是一个根据逆波兰表示法表示的算术表达式。
> - 答案及所有中间计算结果可以用 **32 位** 整数表示。
>  
> **示例 ：**
> 输入：tokens = `["2","1","+","3","*"]`
> 输出：6
> 解释：该算式转化为常见的中缀算术表达式为：`((2 + 1) * 3) = 9`
>  
> **说明：**
> - `1 <= tokens.length <= 10^4`
> - `tokens[i]` 是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），或是在范围 `[-200, 200]` 内的一个整数
> 
> [150. 逆波兰表达式求值 - 力扣（LeetCode）](https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/)

```java
public int evalRPN(String[] tokens) {  
    Stack<Integer> stack = new Stack<>();  
    for (String token : tokens) {  
        if (token.equals("+")) {  
            stack.push(stack.pop() + stack.pop());  
        } else if (token.equals("-")) {  
            stack.push(-stack.pop() + stack.pop());  
        } else if (token.equals("*")) {  
            stack.push(stack.pop() * stack.pop());  
        } else if (token.equals("/")) {  
            int temp1 = stack.pop();  
            int temp2 = stack.pop();  
            stack.push(temp2 / temp1);  
        } else {  
            stack.push(Integer.parseInt(token));  
        }  
    }  
    return stack.pop();  
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 维护栈

## 滑动窗口最大值

> 题目：[239. 滑动窗口最大值 - 力扣（LeetCode）](https://leetcode.cn/problems/sliding-window-maximum/description/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 _滑动窗口中的最大值_ 。

> 示例：
> - 输入：`nums = [1,3,-1,-3,5,3,6,7], k = 3`
> - 输出：`[3,3,5,5,6,7]`
>   
> 提示：
> - `1 <= nums.length <= 10^5`
> - `-10^4 <= nums[i] <= 10^4`
> - `1 <= k <= nums.length`

思路：
- 维护一个对头到队尾单调递减的队列
- 双端队列（队尾要出队）

```java
class Solution {
    public static int[] maxSlidingWindow(int[] nums, int k) {
        ArrayDeque<Integer> deque = new ArrayDeque<>();
        int n = nums.length;
        int[] res = new int[n - k + 1];
        int idx = 0;
        for (int i = 0; i < n; i++) {
            // 根据题意，i为nums下标，是要在[i - k + 1, i] 中选到最大值，只需要保证两点
            // 1.队列头结点需要在[i - k + 1, i]范围内，不符合则要弹出
            if (!deque.isEmpty() && deque.peek() < i - k + 1) {
                deque.poll();
            }
            // 2.既然是单调，就要保证每次放进去的数字要比末尾的都大，否则也弹出
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }

            deque.offer(i);

            // 因为单调，当i增长到符合第一个k范围的时候，每滑动一步都将队列头节点放入结果就行了
            if (i >= k - 1) {
                res[idx++] = nums[deque.peek()];
            }
        }
        return res;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(k)` 

## 补：前K个高频元素

> 给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。
>  
> **示例 1:**
> - **输入:** nums = [1,1,1,2,2,3], k = 2
> - **输出:** [1,2]
>  
> **说明：**
> - `1 <= nums.length <= 105`
> - `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
> - 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的
> 
> [347. 前 K 个高频元素 - 力扣（LeetCode）](https://leetcode.cn/problems/top-k-frequent-elements/description/)

```java

```

> 时间：`O()`
> 
> 空间：`O()` 

%%  %%
# 树

## 二叉树的递归遍历

> 二叉树的前序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[1,2,3]`
> 
> [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

```java
class Solution {
    List<Integer> res=new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root) {
        // 终止条件
        if(root == null) return res;
        // 本层操作
        res.add(root.val);
        // 递归调用
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        return res;
    }
}
```

--- 
> 二叉树的后序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[3,2,1]`
> 
> [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

```java
class Solution {
    List<Integer> res=new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        // 终止条件
        if(root == null) return res;
        // 递归调用
        postorderTraversal(root.left);
        postorderTraversal(root.right);
        // 本层操作
        res.add(root.val);
        return res;
    }
}
```

---
> 二叉树的中序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[1,3,2]`
> 
> [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

```java
class Solution {
    List<Integer> res=new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        // 终止条件
        if(root == null) return res;
        // 递归调用
        inorderTraversal(root.left);
         // 本层操作
        res.add(root.val);
        inorderTraversal(root.right);
        return res;
    }
}
```

> 递归的时间复杂度
> - 时间：`O(n)`
>-  空间：`O(log_2 n)`  递归调用栈的深度（树的深度）

<br>

## 二叉树的迭代遍历(1)

**思想：模拟递归，递归调用就是入栈**

--- 
> 二叉树的前序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[1,2,3]`
> 
> [144. 二叉树的前序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-preorder-traversal/)

每次循环：
- `cur!=null` 
	- 访问cur
	- `cur.right`入栈
	- `cur=cur.left`
- `cur==null`
	- 弹栈，`cur=stack.pop()`

```java
class Solution {
     public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Stack<TreeNode> stack = new Stack();
        TreeNode cur=root;
        while (!stack.isEmpty() || cur!=null) {
            if(cur!=null){
                res.add(cur.val);
                stack.push(cur.right);
                cur=cur.left;
            }else{
                cur=stack.pop();
            }
        }
        return res;
    }
}
```

---
> 二叉树的中序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[1,3,2]`
> 
> [94. 二叉树的中序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-inorder-traversal/description/)

每次循环：
- `cur!=null`
	- `cur`入栈
	- `cur=cur.left`
- `cur==null`
	- 弹栈，`cur=stack.pop()` 
	- 访问cur
	- `cur.right` 入栈

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res=new ArrayList<>();
        if(root==null) return res;
        Stack<TreeNode> stack=new Stack<>();
        TreeNode cur=root;
        while(!stack.isEmpty() || cur!=null){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }else{
                cur=stack.pop();
                res.add(cur.val);
                cur=cur.right;
            }
        }
        return res;
    }
}
```

--- 
> 二叉树的后序遍历
>  
> 输入：`root = [1,null,2,3]`
> 输出：`[3,2,1]`
> 
> [145. 二叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-postorder-traversal/description/)

每次循环：
- `cur!=null`
	- `cur`入栈
	- `cur=cur.left`
- `cur==null`
	- 弹栈，`cur=stack.pop()`
	- **cur已经入过栈** 或者 `cur.right==null`
		- 访问cur
		- 以cur为节点的子树就遍历完了，continue
	- **cur没有入过栈**
		- cur重新入栈，**标识重新入栈**（避免进入`cur!=null`的死循环）
		- `cur=cur.right`

标识方法：
- `Set<TreeNode> rec = new HashSet()`。不能是`Set<Integer>`，因为val会重复
- prev指向前一个节点，如果prev是右节点，说明cur已经入过栈了

Set标识。By Boer (genius).
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res=new ArrayList<>();
        if(root==null) return res;
        Set<TreeNode> rec=new HashSet(); // 标识当前节点是否已经入过stack
        Stack<TreeNode> stack=new Stack<>();
        TreeNode cur=root;
        while(!stack.isEmpty() || cur!=null){
            if(cur!=null){
                stack.push(cur);
                cur=cur.left;
            }else{
                cur=stack.pop();
                if(rec.contains(cur) || cur.right==null){
                    res.add(cur.val); 
                    cur=null;
                }else{
                    stack.push(cur);
                    rec.add(cur); // 标识已经入过stack
                    cur=cur.right;
                }    
            }
        }
        return res;
    }
}
```

prev标识
```java
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<Integer>();
        if (root == null) {
            return res;
        }

        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        TreeNode prev = null;
        while (root != null || !stack.isEmpty()) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
            if (root.right == null || root.right == prev) {
                res.add(root.val);
                prev = root;
                root = null;
            } else {
                stack.push(root);
                root = root.right;
            }
        }
        return res;
    }
}
```

> 迭代的时间复杂度
> - 时间：`O(n)`
>-  空间：`O(log_2 n)`  树的深度

## 二叉树的层序遍历(1)

> 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
> 
> 示例：
> - 输入：`root = [3,9,20,null,null,15,7]`
> - 输出：`[[3],[9,20],[15,7]]`
>  
> 说明：
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-1000 <= Node.val <= 1000`
> 
> [102. 二叉树的层序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal/description/)

广度优先搜索

```java
class Solution {
     public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            List<Integer> item = new ArrayList<>(); // 记录每一层的元素
            int levelSize = queue.size(); // 当层节点个数
            while (len > 0) {
                TreeNode node = queue.poll();
                item.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                levelSize--;
            }
            res.add(item);
        }
        return res;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 队列

#todo 参考 [删除二叉搜索树中的节点 (1)](#删除二叉搜索树中的节点%20(1))，用 list 解决

### 二叉树的层序遍历II

>给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。（即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）
> 
> 示例：
> - 输入：`root = [3,9,20,null,null,15,7]`
> - 输出：`[[15,7],[9,20],[3]]`
>  
> 说明：
> - 树中节点数目在范围 `[0, 2000]` 内
> - `-1000 <= Node.val <= 1000`
> 
> [107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

二叉树的层序遍历的基础上反转结果

```java
class Solution {
     public List<List<Integer>> levelOrderBottom(TreeNode root) {
        List<List<Integer>> list = new ArrayList<>();
        if (root == null) return list;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            List<Integer> item = new ArrayList<>(); // 记录每一层的元素
            int len = queue.size();
            while (len > 0) {
                TreeNode node = queue.poll();
                item.add(node.val);
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                len--;
            }
            list.add(item);
        }

        List<List<Integer>> res = new ArrayList<>();
        for (int i = list.size() - 1; i >= 0; i--) {
            res.add(list.get(i));
        }
        return res;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 队列

### 二叉树的右视图

> 给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
> 
> 示例：
> - 输入：`[1,2,3,null,5,null,4]`
> - 输出：`[1,3,4]`
>  
> 说明：
> - 二叉树的节点个数的范围是 `[0,100]`
> - `100 <= Node.val <= 100
> 
> [107. 二叉树的层序遍历 II - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/description/)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if (root == null) return res;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int len = queue.size();
            while (len > 0) {
                TreeNode node = queue.poll();
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
                if (--len == 0) res.add(node.val);
            }
        }
        return res;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(n)` 队列


其余相关题目 todo

## 翻转二叉树

>给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。
> 
> 示例：
> - 输入：`root = [4,2,7,1,3,6,9]`
> - 输出：`[4,7,2,9,6,3,1]`
>  
> 说明：
> - 树中节点数目范围在 `[0, 100]` 内
> - `-100 <= Node.val <= 100`
> 
> [226. 翻转二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/invert-binary-tree/description/)

递归

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        // 终止条件
        if(root==null) return root;
        // 递归调用
        root.left=invertTree(root.left);
        root.right=invertTree(root.right);
        // 操作    
        TreeNode temp=root.left;
        root.left=root.right;
        root.right=temp;
        return root;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(log_2 n)` 递归调用栈

--- 
迭代 todo

## 对称二叉树(1)

>给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
> 
> 示例：
> - 输入：`root = [1,2,2,3,4,4,3]`
> - 输出：`true`
>  
> 说明：
> - 树中节点数目范围在 `[0, 1000]` 内
> - `-100 <= Node.val <= 100`
> 
> [101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

递归

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if (root == null) return true;
        return compare(root.left, root.right);
    }

    // 同层级的两个对称节点判断返回值，需要两个参数
    // left是左半树，right是右半树
    public boolean compare(TreeNode left, TreeNode right) {
        // 终止条件
        // 1）都为null
        if (left == null && right == null) return true;
        // 2）只有一个为null
        else if (left == null || right == null) return false;
        // 3）都不为null
        else if (left.val != right.val) return false;
        
        // 当前left和right对称了。递归调用
        boolean outside = compare(left.left, right.right);
        boolean inside = compare(left.right, right.left);
        
        // 操作
        return outside && inside;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(log_2 n)` 递归调用栈

---
迭代 todo

## 二叉树的最大深度

>给定一个二叉树 `root` ，返回其最大深度。
> 
> 二叉树的 最大深度 是指从根节点到**最远叶子节点的最长路径**上的节点数。
> 
> 示例：
> - 输入：`root = [3,9,20,null,null,15,7]`
> - 输出：`3`
>  
> 说明：
> - 树中节点数目范围在 `[0, 10^4]` 内
> - `-100 <= Node.val <= 100`
> 
> [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

递归
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root==null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(log_2 n)` 递归调用栈

---
迭代 todo

## 二叉树的最小深度

> 题目 [104. 二叉树的最大深度 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/)

给定一个二叉树，找出其最小深度。

最小深度是从**根节点到最近叶子节点的最短路径**上的节点数量。

示例：
- 输入：`root = [3,9,20,null,null,15,7]`
- 输出：`2`
 
说明：
- 树中节点数目范围在 `[0, 10^4]` 内
- `-100 <= Node.val <= 100`

> 思路一：递归

本题不能简单地将[二叉树的最大深度](#二叉树的最大深度)中的`Math.max()`改成`Math.min()`，会受到叶子节点的干扰。

例：`1,null,3`。minDepth是2而不是1

1）By Boer
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        else if(root.left==null && root.right==null) return 1;
        else if(root.left==null && root.right!=null) return minDepth(root.right)+1;
        else if(root.left!=null && root.right==null) return minDepth(root.left)+1;
        else return Math.min(minDepth(root.left), minDepth(root.right))+1;
    }
}
```

2）优化后
```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null) return 0;
        else if(root.left==null ) return minDepth(root.right)+1;
        else if(root.right==null ) return minDepth(root.left)+1;
        else return Math.min(minDepth(root.left), minDepth(root.right))+1;
    }
}
```

> 时间：`O(n)`
> 
> 空间：`O(log_2 n)` 递归调用栈

---
> 思路二：迭代

todo

## 完全二叉树的节点个数

> 题目 [222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

给你一棵 **完全二叉树** 的根节点 `root` ，求出该树的节点个数。

[完全二叉树](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin) 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 `h` 层，则该层包含 `1~ 2^h` 个节点。

示例：
- 输入：`root = [1,2,3,4,5,6]`
- 输出：`6`
 
说明：
- 树中节点的数目范围是`[0, 5 * 10^4]`
- `0 <= Node.val <= 5 * 10^4`
- 题目数据保证输入的树是 **完全二叉树**

进阶：遍历树来统计节点是一种时间复杂度为 `O(n)` 的简单解决方案。你可以设计一个更快的算法吗？

> 思路一：递归

后序：当前树节点总数=左子树节点总数+右子树节点总数+1

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null) return 0;
        return countNodes(root.left)+countNodes(root.right)+1;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

层序 todo

## 平衡二叉树

> 题目 [222. 完全二叉树的节点个数 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-tree-nodes/description/)

给定一个二叉树，判断它是否是高度平衡的二叉树。

本题中，一棵高度平衡二叉树定义为：一个二叉树_每个节点_ 的左右两个子树的高度差的绝对值不超过 1 。

示例：
- 输入：`root = [3,9,20,null,null,15,7]`
- 输出：`true`
 
说明：
- 树中的节点数在范围 `[0, 5000]` 内
- `-104 <= Node.val <= 104`

> 思路一：递归

后序：求树的最大深度

```java
class Solution {
    boolean flag=true;

    public boolean isBalanced(TreeNode root) {
        maxDepth(root);
        return flag;
    }

    // max(左子树最大深度, 右子树最大深度)
    public int maxDepth(TreeNode root){
        if(root==null) return 0;
        if(flag==false) return 0;
        int leftDepth=maxDepth(root.left);
        int rightDepth=maxDepth(root.right);
        int gap=Math.abs(leftDepth-rightDepth);
        if(gap>1) flag=false;
        return Math.max(leftDepth, rightDepth)+1;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 二叉树的所有路径

> 题目 [257. 二叉树的所有路径 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-tree-paths/description/)

给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。

**叶子节点** 是指没有子节点的节点。

示例：
- 输入：`root = [1,2,3,null,5]`
- 输出：`["1->2->5","1->3"]`
 
说明：
- 树中节点的数目在范围 `[1, 100]` 内
- `-100 <= Node.val <= 100`**

> 思路一：递归

先序

```java
public class Solution {
    public List<String> res = new ArrayList();

    public List<String> binaryTreePaths(TreeNode root) {
        getPath(root, "");
        return res;
    }

    public void getPath(TreeNode node, String path) {
        if (node == null)
            return;
        // 叶子结点
        if (node.left == null && node.right == null) {
            res.add(path + node.val);
            return;
        }
        getPath(node.right, path + node.val + "->");
        getPath(node.left, path + node.val + "->");
        return;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 左叶子之和

> 题目 [404. 左叶子之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-left-leaves/)

给定二叉树的根节点 `root` ，返回所有左叶子之和。

示例：
- 输入: `root = [3,9,20,null,null,15,7] `
- 输出: 24 
- 解释：在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
 
说明：
- 节点数在 `[1, 1000]` 范围内
- `-1000 <= Node.val <= 1000`

> 思路一：递归

先序。By Boer.
```java
public class Solution {
    public List<String> res = new ArrayList();

    public List<String> binaryTreePaths(TreeNode root) {
        getPath(root, "");
        return res;
    }

    public void getPath(TreeNode node, String path) {
        if (node == null)
            return;
        // 叶子结点
        if (node.left == null && node.right == null) {
            res.add(path + node.val);
            return;
        }
        getPath(node.right, path + node.val + "->");
        getPath(node.left, path + node.val + "->");
        return;
    }
}
```

后序参考代码
```java
class Solution {
    public int sumOfLeftLeaves(TreeNode root) {
        if (root == null) return 0;
        int leftValue = sumOfLeftLeaves(root.left);    // 左
        int rightValue = sumOfLeftLeaves(root.right);  // 右
                                                       
        int midValue = 0;
        if (root.left != null && root.left.left == null && root.left.right == null) { 
            midValue = root.left.val;
        }
        int sum = midValue + leftValue + rightValue;  // 中
        return sum;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 找树左下角的值(1)

> 题目 [513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

示例：
- 输入: `root = [2,1,3] `
- 输出: 1
 
说明：
- 二叉树的节点个数的范围是 `[1,10^4]`
- `-2^31 <= Node.val <= 2^31 - 1`

> 思路一：递归

先序。先递归左子树以及 `depth > maxDepth` 能够确保同一层获取的是最左边的节点值。
```java
class Solution {
    int res;
    int maxDepth;

    public int findBottomLeftValue(TreeNode root) {
        inorder(root, 1);
        return res;
    }

    public void inorder(TreeNode root, int depth) {
        if (root == null)
            return;
        if (root.left == null && root.right == null) {
            if (depth > maxDepth) {
                maxDepth = depth;
                res = root.val;
            }
        }
        inorder(root.left, depth + 1);
        inorder(root.right, depth + 1);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 路径总和

> 题目 [513. 找树左下角的值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-bottom-left-tree-value/description/)

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

示例：
- 输入：`root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22`
- 输出：`true`
- 解释：等于目标和的根节点到叶节点路径如上图所示。
 
说明：
- 树中节点的数目在范围 `[0, 5000]` 内
- `-1000 <= Node.val <= 1000`
- `-1000 <= targetSum <= 1000`

> 思路一：递归

先序
```java
class Solution {
    int target;
    boolean flag = false;

    public boolean hasPathSum(TreeNode root, int targetSum) {
        target = targetSum;
        traversal(root, 0);
        return flag;
    }

    public void traversal(TreeNode root, int currentSum) {
        if (flag == true)
            return;
        if (root == null)
            return;
        currentSum += root.val;
        if (currentSum == target && root.left==null && root.right==null) {
            flag = true;
            return;
        }
        traversal(root.left, currentSum);
        traversal(root.right, currentSum);
    }
}
```

先序简便写法。targetsum每次减掉当前节点值
```java
class solution {
    public boolean haspathsum(treenode root, int targetsum) {
        if (root == null) return false; // 为空退出

        // 叶子节点判断是否符合
        if (root.left == null && root.right == null) return root.val == targetsum;

        // 求两侧分支的路径和
        return haspathsum(root.left, targetsum - root.val) || haspathsum(root.right, targetsum - root.val);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 从中序与后序遍历序列构造二叉树(1)

> 题目 [106. 从中序与后序遍历序列构造二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/)

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 _二叉树_ 。

示例：
- 输入：`inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]`
- 输出：`[3,9,20,null,null,15,7]`

说明：
- `1 <= inorder.length <= 3000`
- `postorder.length == inorder.length`
- `-3000 <= inorder[i], postorder[i] <= 3000`
- `inorder` 和 `postorder` 都由 **不同** 的值组成
- `postorder` 中每一个值都在 `inorder` 中
- `inorder` **保证**是树的中序遍历
- `postorder` **保证**是树的后序遍历

> 思路一：递归

先序
```java
public class Solution {
    Map<Integer, Integer> map;
    int[] myInorder;
    int[] myPostorder;
    
    public TreeNode buildTree(int[] inorder, int[] postorder) {
        map = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i], i);
        }
        myInorder = inorder;
        myPostorder = postorder;
        return findRoot(0, inorder.length - 1, 0, postorder.length - 1);
    }

    public TreeNode findRoot(int inBegin, int inEnd, int postBegin, int postEnd) {
        if (inEnd < inBegin || postEnd < postBegin)
            return null;
        int rootIndex = map.get(myPostorder[postEnd]);
        TreeNode root = new TreeNode(myInorder[rootIndex]);
        // 左子树序列
        root.left = findRoot(inBegin, rootIndex - 1, postBegin, postBegin + rootIndex - inBegin - 1);
        // 右子树序列
        root.right = findRoot(rootIndex + 1, inEnd, postBegin + rootIndex - inBegin, postEnd - 1);
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

## 最大二叉树

> 题目 [654. 最大二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-binary-tree/description/)

给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:

1. 创建一个根节点，其值为 `nums` 中的最大值。
2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。

返回 _`nums` 构建的_ **_最大二叉树_** 。

示例：
- 输入：`nums = [3,2,1,6,0,5]`
- 输出：`[6,3,5,null,2,0,null,null,1]`
- 解释：递归调用如下所示：
	- `[3,2,1,6,0,5]` 中的最大值是 6 ，左边部分是 `[3,2,1] `，右边部分是 `[0,5]` 。
	    - `[3,2,1]` 中的最大值是 3 ，左边部分是 `[]` ，右边部分是 `[2,1]` 。
	        - 空数组，无子节点。
	        - `[2,1]` 中的最大值是 2 ，左边部分是 `[]` ，右边部分是 `[1]` 。
	            - 空数组，无子节点。
	            - 只有一个元素，所以子节点是一个值为 1 的节点。
	    - `[0,5]` 中的最大值是 5 ，左边部分是 `[0]` ，右边部分是 `[]` 。
	        - 只有一个元素，所以子节点是一个值为 0 的节点。
	        - 空数组，无子节点。

说明：
- `1 <= nums.length <= 1000`
- `0 <= nums[i] <= 1000`
- `nums` 中的所有整数 **互不相同**

> 思路一：递归

先序
```java
class Solution {
    int[] myNums;

    public TreeNode constructMaximumBinaryTree(int[] nums) {
        myNums = nums;
        return construct(0, nums.length - 1);
    }

    public TreeNode construct(int start, int end) {
        if (start > end)
            return null;
        if (start == end)
            return new TreeNode(myNums[start]);
        // 获取最大值
        int maxVal = myNums[start];
        int maxIdx = start;
        for (int i = start + 1; i <= end; i++) {
            if (myNums[i] > maxVal) {
                maxVal = myNums[i];
                maxIdx = i;
            }
        }
        // 新建节点
        TreeNode node = new TreeNode(maxVal);
        // 递归调用
        node.left = construct(start, maxIdx - 1);
        node.right = construct(maxIdx + 1, end);
        return node;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

## 合并二叉树(1)

> 题目 [617. 合并二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-binary-trees/description/)

给你两棵二叉树： `root1` 和 `root2` 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，**不为** null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

**注意:** 合并过程必须从两个树的根节点开始。

示例：
- 输入：`root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]`
- 输出：`[3,4,5,5,4,null,7]`
 
说明：
- 两棵树中的节点数目在范围 `[0, 2000]` 内
- `-10^4 <= Node.val <= 10^4`

> 思路一：递归

先序
```java
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if (root1 == null)
            return root2;
        if (root2 == null)
            return root1;
        TreeNode node = new TreeNode(root1.val + root2.val);
        node.left = mergeTrees(root1.left, root2.left);
        node.right = mergeTrees(root1.right, root2.right);
        return node;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## ---------- 二叉搜索树
## 二叉搜索树中的搜索

> 题目 [700. 二叉搜索树中的搜索 - 力扣（LeetCode）](https://leetcode.cn/problems/search-in-a-binary-search-tree/description/)

给定二叉搜索树（BST）的根节点 `root` 和一个整数值 `val`。

你需要在 BST 中找到节点值等于 `val` 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 `null` 。

示例：
- 输入：`root = [4,2,7,1,3], val = 2`
- 输出：`[2,1,3]`
 
说明：
- 树中节点数在 `[1, 5000]` 范围内
- `1 <= Node.val <= 107`
- `root` 是二叉搜索树
- `1 <= val <= 10^7`

> 思路一：递归

先序
```java
class Solution {
    public TreeNode searchBST(TreeNode root, int val) {
        if (root == null || root.val == val)
            return root;
        if (root.val < val)
            return searchBST(root.right, val);
        else
            return searchBST(root.left, val);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 验证二叉搜索树(1)

> 题目 [98. 验证二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/validate-binary-search-tree/description/)

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含 **小于** 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

示例：
- 输入：`root = [2,1,3]`
- 输出：`true`
 
说明：
- 树中节点数目范围在`[1, 104]` 内
- `-231 <= Node.val <= 231 - 1`

> 思路一：递归

【陷阱】不能单纯的比较左节点小于中间节点，右节点大于中间节点就完事了。我们要比较的是 左子树所有节点小于中间节点，右子树所有节点大于中间节点

中序遍历下，输出的二叉搜索树节点的数值是有序序列，可以递归中序遍历将二叉搜索树转变成一个数组，看这个数组是不是有序的就可以了

但其实不用转变成数组，可以在递归遍历的过程中直接判断是否有序。

中序
```java
class Solution {
    TreeNode max;

    public boolean isValidBST(TreeNode root) {
        if (root == null)
            return true;
        boolean left = isValidBST(root.left);
        if (!left) {
            return false; // 剪枝
        }
        if (max != null && root.val <= max.val)
            return false; // 剪枝
        max = root;
        boolean right = isValidBST(root.right);
        return right;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

todo

## 二叉搜索树的最小绝对差

> 题目 [530. 二叉搜索树的最小绝对差 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/)

给你一个二叉搜索树的根节点 `root` ，返回 **树中任意两不同节点值之间的最小差值** 。

差值是一个正数，其数值等于两值之差的绝对值。

示例：
- 输入：`root = [4,2,6,1,3]`
- 输出：1
 
说明：
- 树中节点的数目范围是 `[2, 104]`
- `0 <= Node.val <= 105`

> 思路一：递归

中序
```java
class Solution {
    int min=Integer.MAX_VALUE;
    TreeNode pre;

    public int getMinimumDifference(TreeNode root) {
        inOrder(root);
        return min;
    }

    public void inOrder(TreeNode root) {
        if (root == null)
            return;
        inOrder(root.left);
        if(pre!=null)
            min = Math.min(min, root.val - pre.val);
        pre = root;
        inOrder(root.right);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

Todo

## 二叉搜索树中的众数 (1)

> 题目 [501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

给你一个含重复值的二叉搜索树（BST）的根节点 `root` ，找出并返回 BST 中的所有 [众数](https://baike.baidu.com/item/%E4%BC%97%E6%95%B0/44796)（即，出现频率最高的元素）。

如果树中有不止一个众数，可以按 **任意顺序** 返回。

假定 BST 满足如下定义：

- 结点左子树中所含节点的值 **小于等于** 当前节点的值
- 结点右子树中所含节点的值 **大于等于** 当前节点的值
- 左子树和右子树都是二叉搜索树

示例：
- 输入：`root = [1,null,2,2]`
- 输出：`[2]`
 
说明：
- 树中节点的数目在范围 `[1, 10^4]` 内
- `-10^5 <= Node.val <= 10^5`

> 思路一：递归

中序。难度在于如何一次遍历就得到众数的集合，并且不使用额外的空间（递归调用栈除外）
```java
class Solution {
    List<Integer> list = new ArrayList<>();
    int maxCount;
    int count;
    TreeNode pre;

    public int[] findMode(TreeNode root) {
        traversal(root);
        int[] res = new int[list.size()];
        for (int i = 0; i < res.length; i++) {
            res[i] = list.get(i);
        }
        return res;
    }

    public void traversal(TreeNode root) {
        if (root == null)
            return;
        traversal(root.left);
        if (pre == null || root.val != pre.val) {
            count = 1;
        } else {
            count++;
        }
        if (count > maxCount) {
            list.clear();
            list.add(root.val);
            maxCount = count;
        } else if (count == maxCount) {
            list.add(root.val);
        }
        pre = root;
        traversal(root.right);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

> 思路二：迭代

Todo

## 二叉树的最近公共祖先

> 题目 [501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

示例：
- 输入：`root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1`
- 输出：`3`
- 解释：节点 `5` 和节点 `1` 的最近公共祖先是节点 `3 。`
 
说明：
- 树中节点数目在范围 `[2, 10^5]` 内。
- `-10^9 <= Node.val <= 10^9`
- 所有 `Node.val` `互不相同` 。
- `p != q`
- `p` 和 `q` 均存在于给定的二叉树中。

> 思路一：递归

后序 By Boer.
```java
class Solution {
    TreeNode res;

    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        traversal(root, p, q);
        return res;
    }

    public boolean traversal(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null) {
            return false;
        } else if (root == p) {
            res = p;
            return true;
        } else if (root == q) {
            res = q;
            return true;
        }
        boolean left = traversal(root.left, p, q);
        boolean right = traversal(root.right, p, q);
        if (left == true && right == true) {
            res = root;
            return true;
        }
        return left || right;
    }
}
```

优化写法
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) { // 递归结束条件
            return root;
        }

        // 后序遍历
        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left == null && right == null) { // 若未找到节点 p 或 q
            return null;
        }else if(left == null && right != null) { // 若找到一个节点
            return right;
        }else if(left != null && right == null) { // 若找到一个节点
            return left;
        }else { // 若找到两个节点
            return root;
        }
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

## 二叉树搜索树的最近公共祖先 (1)

[501. 二叉搜索树中的众数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

最近公共祖先的定义为：“ 对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。”

> 示例：
> - 输入：`root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8`
> - 输出：`6`
>  
> 	说明：
> - 所有节点的值都是唯一的。
> - p、q 为不同节点且均存在于给定的二叉搜索树中。

---
【思路一：递归】

- 等同于：沿着一条边搜索一棵树（先序的思想）
- 一定能找到公共祖先，所以不需要判空了

> 沿着一条边搜索一棵树模板：
> 
> ```java
> if (递归函数(root->left)) return ;
> if (递归函数(root->right)) return ;
> ```
> 
> 搜索整个树模板：
> 
> ```java
> left = 递归函数(root->left);
> right = 递归函数(root->right);
> left与right的逻辑处理;
> ```

中序
```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root.val>p.val && root.val>q.val){
            return lowestCommonAncestor(root.left,p,q);
        }
        if(root.val<p.val && root.val<q.val){
            return lowestCommonAncestor(root.right,p,q);
        }
        // root.val在中间，root.val==p.val，root.val==q.val
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```

## 二叉树搜索树中的插入操作

[701. 二叉搜索树中的插入操作 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/)

给定二叉搜索树（BST）的根节点 `root` 和要插入树中的值 `value` ，将值插入二叉搜索树。返回插入后二叉搜索树的根节点。输入数据 **保证** ，新值和原始二叉搜索树中的任意节点值都不同。

**注意**，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 **任意有效的结果** 。

> 示例：
> - 输入：`root = [4,2,7,1,3], val = 5`
> - 输出：`[4,2,7,1,3,5]`
>  
> 说明：
> - 树中的节点数将在 `[0, 104]` 的范围内。
> - `-108 <= Node.val <= 108`
> - 所有值 `Node.val` 是 **独一无二** 的。
> - `-108 <= val <= 108`
> - **保证** `val` 在原始BST中不存在。

---
【思路一：递归】

中序
```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if (root == null) {
            root = new TreeNode(val);
        } else if (root.val < val) {
            root.right = insertIntoBST(root.right, val);
        } else {
            root.left = insertIntoBST(root.left, val);
        }
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```

## 删除二叉搜索树中的节点 (1)

> 题目： [450. 删除二叉搜索树中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-bst/description/)

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：
1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

> 示例：
> - 输入：`root = [5,3,6,2,4,null,7], key = 3`
> - 输出：`[5,4,6,2,null,null,7]`
>  
> 说明：
> - 节点数的范围 `[0, 104]`.
> - `-105 <= Node.val <= 105`
> - 节点值唯一
> - `root` 是合法的二叉搜索树
> - `-105 <= key <= 105`

---
【思路一：递归】
- 删除当前 root 不用真的删除节点，直接返回子节点或者 null 即可
- 前序

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        // 没找到
        if (root == null) {
            return null;
        }
        if (root.val == key) {
            // 叶节点：直接删
            if (root.left == null && root.right == null) {
                return null;
            } else if (root.left == null) {
                // 右子树为空
                return root.right;
            } else if (root.right == null) {
                // 左子树为空
                return root.left;
            } else {
                // 左右子树都不为空
                TreeNode cur = root.right;
                while (cur.left != null) {
                    cur = cur.left;
                }
                cur.left = root.left;
                return root.right;
            }
        } else if (root.val > key) {
            root.left = deleteNode(root.left, key);
        } else {
            root.right = deleteNode(root.right, key);
        }
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```


## 修建二叉搜索树(1)

> 题目： [669. 修剪二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/trim-a-binary-search-tree/description/)

给你二叉搜索树的根节点 `root` ，同时给定最小边界 `low` 和最大边界 `high`。通过修剪二叉搜索树，使得所有节点的值在 `[low, high]` 中。修剪树 **不应该** 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。可以证明，存在 **唯一的答案** 。

所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。

> 示例：
> - 输入：`root = [1,0,2], low = 1, high = 2`
> - 输出：`[1,null,2]`
>  
> 说明：
> - 树中节点数在范围 `[1, 104]` 内
> - `0 <= Node.val <= 104`
> - 树中每个节点的值都是 **唯一** 的
> - 题目数据保证输入是一棵有效的二叉搜索树
> - `0 <= low <= high <= 104`

---
【思路一：递归】
- 不要收到 [修建二叉搜索树 (1)]( #修建二叉搜索树 %20 (1)) 的影响
- 利用二叉搜索树的特性
- 前序

```java
class Solution {
    public static TreeNode trimBST(TreeNode root, int low, int high) {
        // 退出条件
        if (root == null) {
            return null;
        }
        // 本层操作
        if (root.val < low) {
            return trimBST(root.right, low, high);
        }
        if (root.val > high) {
            return trimBST(root.left, low, high);
        }
        // 递归调用
        root.left = trimBST(root.left, low, high);
        root.right = trimBST(root.right, low, high);
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```

## 将有序数组转换为二叉搜索树

> 题目： [108. 将有序数组转换为二叉搜索树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/)

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵 **高度平衡** 二叉搜索树。

**高度平衡** 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。

> 示例：
> - 输入：`nums = [-10,-3,0,5,9]`
> - 输出：`[0,-3,9,-10,null,5]`
>  
> 说明：
> - `1 <= nums.length <= 104`
> - `-104 <= nums[i] <= 104`
> - `nums` 按 **严格递增** 顺序排列

---
【思路一：递归】
- 前序
- 二分查找

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        // 二分查找
        return constructTree(nums, 0, nums.length - 1);
    }

    public TreeNode constructTree(int[] nums, int l, int r) {
        // 终止条件
        if (l > r)
            return null;
        // 本层操作
        int mid = (l + r) / 2;
        TreeNode node = new TreeNode(nums[mid]);
        // 递归调用
        node.left = constructTree(nums, l, mid - 1);
        node.right = constructTree(nums, mid + 1, r);
        // 返回值
        return node;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```

## 把二叉搜索树转换为累加树

> 题目： [538. 把二叉搜索树转换为累加树 - 力扣（LeetCode）](https://leetcode.cn/problems/convert-bst-to-greater-tree/description/)

给出二叉 **搜索** 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 `node` 的新值等于原树中大于或等于 `node.val` 的值之和。

> 示例：
> - 输入：`[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]`
> - 输出：`[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]`
>  
> 说明：
> - 树中的节点数介于 `0` 和 `10^4` 之间。
> - 每个节点的值介于 `-10^4` 和 `10^4` 之间。
> - 树中的所有值 **互不相同** 。
> - 给定的树为二叉搜索树。

---
【思路一：递归】
- 逆中序：右中左

```java
class Solution {
    int sum;

    public TreeNode convertBST(TreeNode root) {
        // 终止条件
        if (root == null) {
            return null;
        }
        convertBST(root.right);
        sum += root.val;
        root.val = sum;
        convertBST(root.left);
        return root;
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(log_2 n)` 递归调用栈

---
【思路二：迭代】

Todo
```java

```

## 补充：完全二叉树插入器 (1)

> 题目：[919. 完全二叉树插入器 - 力扣（LeetCode）](https://leetcode.cn/problems/complete-binary-tree-inserter/description/)

**完全二叉树** 是每一层（除最后一层外）都是完全填充（即，节点数达到最大）的，并且所有的节点都尽可能地集中在左侧。

设计一种算法，将一个新节点插入到一个完整的二叉树中，并在插入后保持其完整。

实现 `CBTInserter` 类:
- `CBTInserter(TreeNode root)` 使用头节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)`  向树中插入一个值为 `Node.val == val`的新节点 `TreeNode`。使树保持完全二叉树的状态，**并返回插入节点** `TreeNode` **的父节点的值**；
- `CBTInserter.get_root()` 将返回树的头节点。

> 示例：
> - 输入：
> 	- `["CBTInserter", "insert", "insert", "get_root"]`
> 	- `[[[1, 2]], [3], [4], []]`
> - 输出：`[null, 1, 2, [1, 2, 3, 4]]`
>  
> 说明：
> - `CBTInserter cBTInserter = new CBTInserter([1, 2]);`
> - `cBTInserter.insert(3);  // 返回 1`
> - `cBTInserter.insert(4);  // 返回 2`
> - `cBTInserter.get_root(); // 返回 [1, 2, 3, 4]`

思路：把层序的顺序保存在列表里，并且记录首个左右孩子不全的节点在 list 中的索引

```java
class CBTInserter {
    List<TreeNode> list = new ArrayList<>();
    // 记录首个左右孩子不全的节点在list中的索引
    int idx = 0;

    public CBTInserter(TreeNode root) {
        list.add(root);
        int cur = 0;
        // 把所有节点加入到list里
        while (cur < list.size()) {
            TreeNode node = list.get(cur);
            if (node.left != null) {
                list.add(node.left);
            }
            if (node.right != null) {
                list.add(node.right);
            }
            cur++;
        }
    }

    public int insert(int val) {
        TreeNode node = new TreeNode(val);
        // 左右子节点都不为空
        while (list.get(idx).left != null && list.get(idx).right != null) {
            idx++;
        }

        TreeNode fa = list.get(idx);
        if (fa.left == null) {
            fa.left = node;
        } else if (fa.right == null) {
            fa.right = node;
        }
        list.add(node);
        return fa.val;
    }

    public TreeNode get_root() {
        return list.get(0);
    }
}
```

复杂度分析：
- 时间：`O(n)`
- 空间：`O(n)`

# 回溯

【是啥？】回溯法也可以叫做“回溯搜索法”，它是一种搜索的方式。
- 回溯是递归的副产品，只要有递归就会有回溯。

回溯法的效率
- 回溯法并不是什么高效的算法。因为回溯的本质是**穷举**，穷举所有可能，然后选出我们想要的答案。
- 不高效为什么还要用它呢？因为没得选，一些问题能暴力搜出来就不错了，撑死了再**剪枝**一下，还没有更高效的解法

> #Boer 不剪枝在效率上和暴力没区别，但是有的问题暴力是写不出来了的！比如 n 数之和就得写 n 个循环。

回溯法思想：
- 回溯法解决的问题都可以抽象为**树形结构**。
- 回溯法解决的都是在集合中递归查找子集，递归就要有终止条件，所以必然是一棵高度有限的树（N叉树）

回溯模板代码：

```java
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

## 组合(1)

> 题目：[77. 组合 - 力扣（LeetCode）](https://leetcode.cn/problems/combinations/)

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

> 示例：
> - 输入： `n = 4, k = 2`
> - 输出：`[[2,4],[3,4],[2,3],[1,2],[1,3],[1,4],]`
>  
> 说明：
> - `1 <= n <= 20`
> - `1 <= k <= n`

![](assets/Pasted%20image%2020240201224507.png)

【思路】类似 n 叉树的前序遍历
- #Boer 也不知道算不算回溯，因为每次都 new 一个新 list，没有回溯那一步，很显然比较耗费内存。

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();

    public List<List<Integer>> combine(int n, int k) {
        backtracking(n,k,1,new ArrayList<Integer>());
        return res;
    }

    public void backtracking(int n, int k, int start, List<Integer> list) {
        if(list.size()==k){
            res.add(list);
            return;
        }
        for (int i = start; i <= n; i++) {
            List<Integer> list2 = new ArrayList<>();
            for(Integer item:list){
                list2.add(item);
            }
            list2.add(i);
            backtracking(n,k,i+1,list2);
        }
    }
}
```

【思路】回溯
- 相比上面的做了内存优化，只用了一个 链表 保存路径。
- 注意！**res 保存的时候一定要复制 path 到一个新的 list，因为 path 后续会改动**
- 删除尾元素方便可以用 LinkedList，LinkedList 实现了 List 接口，ArrayList 的构造函数可以传入 `Collection<? extends E>`

```java
class Solution {
    List<List<Integer>> result= new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        backtracking(n,k,1);
        return result;
    }

    public void backtracking(int n,int k,int startIndex){
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i =startIndex;i<=n;i++){
            path.add(i);
            backtracking(n,k,i+1);
            path.removeLast();
        }
    }
}
```

【思路】回溯，剪枝优化
- 如果 for 循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索

![](assets/Pasted%20image%2020240201224654.png)

```java
class Solution {
    List<List<Integer>> result = new ArrayList<>();
    LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> combine(int n, int k) {
        combineHelper(n, k, 1);
        return result;
    }

    /**
     * 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围，就是要靠startIndex
     * @param startIndex 用来记录本层递归的中，集合从哪里开始遍历（集合就是[1,...,n] ）。
     */
    private void combineHelper(int n, int k, int startIndex){
        //终止条件
        if (path.size() == k){
            result.add(new ArrayList<>(path));
            return;
        }
        // 剪枝：path还需要的元素个数<=剩余的元素个数。k-pathSize<=n-i+1
        for (int i = startIndex; i <= n - (k - path.size()) + 1; i++){
            path.add(i);
            combineHelper(n, k, i + 1);
            path.removeLast();
        }
    }
}
```

复杂度分析：
- 时间： #todo
- 空间： #todo

## 组合总数 III

> 题目：[216. 组合总和 III - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-iii/description/)

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 _所有可能的有效组合的列表_ 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

> 示例：
> - 输入： `k = 3, n = 7`
> - 输出：`[[1,2,4]]`
>  
> 说明：
> - `2 <= k <= 9`
> - `1 <= n <= 60`

【思路】回溯，剪枝优化
- path 还需要的元素个数 > 剩余的元素个数，剪
- path 中的总和 > target，剪

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum;
    int target;

    public List<List<Integer>> combinationSum3(int k, int n) {
        target = n;
        // 只能用1~9的数字
        backtracking(k, Math.min(9, n), 1);
        return res;
    }

    public void backtracking(int k, int n, int start) {
        // 剪枝
        if (sum > target) {
            return;
        }
        // 结束条件
        if (path.size() == k) {
            if (sum == target) {
                res.add(new ArrayList<Integer>(path));
            }
            return;
        }
        // 剪枝：path还需要的元素个数<=剩余的元素个数。k-pathSize<=n-i+1
        for (int i = start; i <= n - k + path.size() + 1; i++) {
            path.add(i);
            sum += i;
            backtracking(k, n, i + 1);
            // 回溯
            path.remove(path.size() - 1);
            sum -= i;
        }
    }
}
```

## 电话号码的字母组合(1)

> 题目：[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](assets/Pasted%20image%2020240203215403.png)

> 示例：
> - 输入： `digits = "23"`
> - 输出：`["ad","ae","af","bd","be","bf","cd","ce","cf"]`
>  
> 说明：
> - `0 <= digits.length <= 4`
> - `digits[i]` 是范围 `['2', '9']` 的一个数字。

【思路】回溯
- 存储数字和字母的印射关系，不用 map，`String[]` 即可
- 获取数字对应的字母串，基本功：`String str = numString[digits.charAt(cur) - '0'];`

![](assets/Pasted%20image%2020240203215546.png)

```java
class Solution {
    List<String> res = new ArrayList<>();
    StringBuilder path = new StringBuilder();

    public List<String> letterCombinations(String digits) {
        if (digits.length() == 0) {
            return res;
        }
        String[] numString = { "", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz" };
        backtracking(digits, numString, 0);
        return res;
    }

    // cur是当前path中的位置（索引），cur决定递归深度，str.length()决定每层的宽度
    public void backtracking(String digits, String[] numString, int cur) {
        // 出口
        if (cur == digits.length()) {
            res.add(path.toString());
            return;
        }
        String str = numString[digits.charAt(cur) - '0'];
        for (int i = 0; i < str.length(); i++) {
            path.append(str.charAt(i));
            backtracking(digits, numString, ++cur);
            // 回溯
            cur--;
            path.deleteCharAt(path.length() - 1);
        }
    }
}
```

## 组合总和(1)

> 题目：[17. 电话号码的字母组合 - 力扣（LeetCode）](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/)

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

> 示例：
> - 输入： `candidates = [2,3,5]`, ` target = 8`
> - 输出：`[[2,2,2,2],[2,3,3],[3,5]]`
>  
> 说明：
> - `1 <= candidates.length <= 30`
> - `2 <= candidates[i] <= 40`
> - `candidates` 的所有元素 **互不相同**
> - `1 <= target <= 40`

解法：回溯法
- 同一个数字可以无限使用

![](assets/Pasted%20image%2020240204205335.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backTracking(candidates, target, 0);
        return res;
    }

    public void backTracking(int[] candidates, int target, int start) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            res.add(new ArrayList(path));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            path.add(candidates[i]);
            sum += candidates[i];
            backTracking(candidates, target, i);
            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```

如何剪枝？
- 对总集合排序之后，如果下一层的 sum（就是本层的 `sum + candidates[i]`）已经大于 target，就可以结束本轮 for 循环的遍历。
- 横向的剪枝要在 for 里面进行

![](assets/Pasted%20image%2020240204222152.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum;

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        Arrays.sort(candidates);
        backTracking(candidates, target, 0);
        return res;
    }

    public void backTracking(int[] candidates, int target, int start) {
        if (sum == target) {
            res.add(new ArrayList(path));
            return;
        }
        for (int i = start; i < candidates.length; i++) {
            if (sum + candidates[i] > target) {
                return;
            }
            path.add(candidates[i]);
            sum += candidates[i];
            backTracking(candidates, target, i);
            // 回溯
            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```

## 组合总和 2(1)

> 题目：[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

注意：**解集不能包含重复的组合。**

> 示例：
> - 输入: candidates = `[10,1,2,7,6,1,5]`, target = `8`,
> - 输出：`[[1,1,6],[1,2,5],[1,7],[2,6]]`
>  
> 说明：
> - `1 <= candidates.length <= 100`
> - `1 <= candidates[i] <= 50`
> - `1 <= target <= 30`

解法：回溯法
- 不能包含重复的元素，剪枝的时候要跳过同一树层使用过的元素
- 纵向使用过的元素不用删除的

![](assets/Pasted%20image%2020240206001408.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    int sum;

    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        Arrays.sort(candidates);
        backTracing(candidates, target, 0);
        return res;
    }

    public void backTracing(int[] candidates, int target, int start) {
        if (sum == target) {
            res.add(new ArrayList<Integer>(path));
        }
        for (int i = start; i < candidates.length; i++) {
            if (sum + i > target)
                break;
            // 跳过同一树层使用过的元素
            if (i > start && candidates[i] == candidates[i - 1]) {
                continue;
            }
            path.add(candidates[i]);
            sum += candidates[i];
            backTracing(candidates, target, i + 1);
            // 回溯
            path.remove(path.size() - 1);
            sum -= candidates[i];
        }
    }
}
```

## 分割回文串(1)

> 2024年2月7日

> 题目：[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

> 示例：
> - 输入: `s = "aab"`
> - 输出：`[["a","a","b"],["aa","b"]]`
>  
> 说明：
> - `1 <= s.length <= 16`
> - `s` 仅由小写英文字母组成

---
解法：回溯法

![](assets/Pasted%20image%2020240207222346.png)

```java
class Solution {
    List<List<String>> res = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<List<String>> partition(String s) {
        backTracing(s, 0);
        return res;
    }

    public void backTracing(String s, int start) {
        if (start >= s.length()) {
            res.add(new ArrayList<>(path));
        }
        for (int i = start; i < s.length(); i++) {
            if (!isPalindrome(s, start, i)) {
                continue;
            }
            path.add(s.substring(start, i + 1));
            backTracing(s, i + 1);
            // 回溯
            path.remove(path.size() - 1);
        }
    }

    private boolean isPalindrome(String s, int left, int right) {
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
}
```

## 复原 IP 地址

> 2024年2月13日21:25:15

> 题目：[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

> 示例：
> - 输入: `s = "25525511135"`
> - 输出：`["255.255.11.135","255.255.111.35"]`
>  
> 说明：
> - `1 <= s.length <= 16`
> - `s` 仅由小写英文字母组成

---
解法：回溯法
- break代表当前递归结束了，剩余长度不符合的情况应该是跳过循环 continue，因为下一次循环cur变长以后可能满足剩余长度的要求

![](assets/Pasted%20image%2020240213213819.png)

```java
class Solution {
    List<String> res = new ArrayList<>();
    List<String> path = new ArrayList<>();
    int length;

    public List<String> restoreIpAddresses(String s) {
        if (s.length() > 12)
            return res;
        backTracing(s, 0);
        return res;
    }

    public void backTracing(String s, int start) {
        if (path.size() == 4) {
            StringBuilder str = new StringBuilder();
            for (int i = 0; i < 4; i++) {
                if (i == 3) {
                    str.append(path.get(i));
                } else {
                    str.append(path.get(i)).append(".");
                }
            }
            res.add(str.toString());
        }
        for (int i = start; i < s.length(); i++) {
            // 不能含有前导 0
            if (s.charAt(start) == '0' && start < i) {
                break;
            }
            String cur = s.substring(start, i + 1);
            // 剪枝：剩余长度不符合
            if ((4 - path.size() - 1) * 3 + cur.length() + length < s.length()) {
                continue;
            }
            // 数字范围不符合
            if (Integer.parseInt(cur) > 255) {
                break;
            }
            path.add(cur);
            length += cur.length();
            backTracing(s, i + 1);
            path.remove(path.size() - 1);
            length -= cur.length();
        }
    }
}
```

## 子集

> 2024年2月14日15:39:18

> 题目：[40. 组合总和 II - 力扣（LeetCode）](https://leetcode.cn/problems/combination-sum-ii/description/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

> 示例：
> - 输入: `nums = [1,2,3]`
> - 输出：`[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]`
>  
> 说明：
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有元素 **互不相同**

解法：回溯法
- 组合问题和分割问题都是收集树的叶子节点，而子集问题是找树的所有节点！

![](assets/Pasted%20image%2020240214155217.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        res.add(new ArrayList<Integer>());
        backTracing(nums, 0);
        return res;
    }

    public void backTracing(int[] nums, int start) {
        for (int i = start; i < nums.length; i++) {
            path.add(nums[i]);
            res.add(new ArrayList(path));
            backTracing(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 子集II

> 2024年2月15日16:16:59

> 题目：[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)

给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。

> 示例：
> - 输入: `nums = [1,2,2]`
> - 输出：`[[],[1],[1,2],[1,2,2],[2],[2,2]]`
>  
> 说明：
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`

---
解法：回溯法
- 本题和组合的区别：去重
- 去重的逻辑：`if (i > start && nums[i] == nums[i - 1]) `

![](assets/Pasted%20image%2020240215161930.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsetsWithDup(int[] nums) {
        Arrays.sort(nums);
        res.add(new ArrayList<Integer>());
        backTracing(nums, 0);
        return res;
    }

    public void backTracing(int[] nums, int start) {
        for (int i = start; i < nums.length; i++) {
            if (i > start && nums[i] == nums[i - 1]) {
                continue;
            }
            path.add(nums[i]);
            res.add(new ArrayList(path));
            backTracing(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 非递减子序列(1)

> 题目：[90. 子集 II - 力扣（LeetCode）](https://leetcode.cn/problems/subsets-ii/description/)

给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。

数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。

> 示例：
> - 输入: `nums = [4,6,7,7]`
> - 输出：`[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]`
>  
> 说明：
> - `1 <= nums.length <= 15`
> - `-100 <= nums[i] <= 100`

---
> 2024年2月16日22:01:44

解法：回溯法
- 本题的原始序列不是有序的，所以不能用原先的去重逻辑
- 去重的逻辑：通过 Set 集合记录本层的元素是否使用过

![](assets/Pasted%20image%2020240216222807.png)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        backTracing(nums, 0);
        return res;
    }

    public void backTracing(int[] nums, int start) {
        HashSet<Integer> set = new HashSet<>();
        for (int i = start; i < nums.length; i++) {
            // 去重
            if (set.contains(nums[i])) {
                continue;
            }
            // 保证递增
            if (start > 0 && nums[i] < nums[start - 1]) {
                continue;
            }
            path.add(nums[i]);
            set.add(nums[i]);
            // 至少两个元素
            if (path.size() >= 2) {
                res.add(new ArrayList(path));
            }
            backTracing(nums, i + 1);
            path.remove(path.size() - 1);
        }
    }
}
```

## 全排列

> 题目：[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。

> 示例：
> - 输入: `nums = [1,2,3]`
> - 输出：`[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]`
>  
> 说明：
> - `1 <= nums.length <= 6`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有整数 **互不相同**

---
> 2024年2月19日12:39:15

解法：回溯法
- 本题是不需要 start 索引的，因为**排列是有序的，也就是说 [1,2] 和 [2,1] 是两个集合，这和之前分析的子集以及组合所不同的地方**。所以每次 for 循环，i 都要从0开始
- 去重的逻辑：
	- Set 集合复杂了，不推荐
	- `boolean[] used` 查询最快
	- List 接口本身的 `contains()` 方法

![](assets/Pasted%20image%2020240219124408.png)

used 数组去重：

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;

    public List<List<Integer>> permute(int[] nums) {
        used = new boolean[nums.length];
        backTracing(nums);
        return res;
    }

    public void backTracing(int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList(path));
        }
        for (int i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            backTracing(nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

## 全排列II

> 题目：[47. 全排列 II - 力扣（LeetCode）](https://leetcode.cn/problems/permutations-ii/solutions/417937/quan-pai-lie-ii-by-leetcode-solution/)

给定一个可包含重复数字的序列 `nums` ，_**按任意顺序**_ 返回所有不重复的全排列。

> 示例：
> - 输入: `nums = [1,1,2]`
> - 输出：`[[1,1,2],[1,2,1],[2,1,1]]`
>  
> 说明：
> - `1 <= nums.length <= 8`
> - `-10 <= nums[i] <= 10`

---
> 2024年2月21日21:42:29

解法：回溯法
- 去重版全排列
- 不排序去重的逻辑：
	- Set 集合同层去重（for）
	- `boolean[] used` 纵向去重
- 排序去重的逻辑：（效率更高）
	- 相邻节点判断

不排序去重 #Boer 

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    List<Integer> path = new ArrayList<>();
    boolean[] used;

    public List<List<Integer>> permuteUnique(int[] nums) {
        used = new boolean[nums.length];
        backTracing(nums);
        return res;
    }

    public void backTracing(int[] nums) {
        if (path.size() == nums.length) {
            res.add(new ArrayList(path));
        }
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < nums.length; i++) {
            if (set.contains(nums[i])) {
                continue;
            }
            if (used[i]) {
                continue;
            }
            path.add(nums[i]);
            used[i] = true;
            set.add(nums[i]);
            backTracing(nums);
            path.remove(path.size() - 1);
            used[i] = false;
        }
    }
}
```

排序去重

![](assets/Pasted%20image%2020240221215032.png)

```java
class Solution {
    //存放结果
    List<List<Integer>> result = new ArrayList<>();
    //暂存结果
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permuteUnique(int[] nums) {
        boolean[] used = new boolean[nums.length];
        Arrays.fill(used, false);
        Arrays.sort(nums);
        backTrack(nums, used);
        return result;
    }

    private void backTrack(int[] nums, boolean[] used) {
        if (path.size() == nums.length) {
            result.add(new ArrayList<>(path));
            return;
        }
        for (int i = 0; i < nums.length; i++) {
            // used[i - 1] == true，说明同⼀树⽀nums[i - 1]使⽤过
            // used[i - 1] == false，说明同⼀树层nums[i - 1]使⽤过
            // 如果同⼀树层nums[i - 1]使⽤过则直接跳过
            if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {
                continue;
            }
            //如果同⼀树⽀nums[i]没使⽤过开始处理
            if (used[i] == false) {
                used[i] = true;//标记同⼀树⽀nums[i]使⽤过，防止同一树枝重复使用
                path.add(nums[i]);
                backTrack(nums, used);
                path.remove(path.size() - 1);//回溯，说明同⼀树层nums[i]使⽤过，防止下一树层重复
                used[i] = false;//回溯
            }
        }
    }
}
```

## 重新安排行程

#todo 

## N皇后

#todo 

## 解数独

#todo 

# 贪心算法

贪心算法一般分为如下四步：

- 将问题分解为若干个子问题
- 找出适合的贪心策略
- 求解每一个子问题的最优解
- 将局部最优解堆叠成全局最优解

## 分发饼干

> [455. 分发饼干 - 力扣（LeetCode）](https://leetcode.cn/problems/assign-cookies/description/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

> 示例：
> - 输入: `g = [1,2,3], s = [1,1]`
> - 输出：`1`
> - 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。所以你应该输出1。
>  
> 说明：
> - `1 <= g.length <= 3 * 104`
> - `0 <= s.length <= 3 * 104`
> - `1 <= g[i], s[j] <= 231 - 1`

---
> 2024年2月26日20:36:14

解法：贪心，
- `s[j] >= g[i]` 就能喂饱，一块饼干喂得胃口越大越好
- 1）大饼干大胃口
- 2）小饼干小胃口

大饼干大胃口

```java
class Solution {
    public int findContentChildren(int[] g, int[] s) {
        // 大饼干优先给大胃口
        Arrays.sort(g);
        Arrays.sort(s);
        int max = 0;
        for (int i = g.length - 1, j = s.length - 1; i >= 0 && j >= 0;) {
            if (s[j] >= g[i]) {
                max++;
                j--;
            }
            i--;
        }
        return max;
    }
}
```