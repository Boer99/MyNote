# 01. 复杂度
## 斐波那契数列复杂度分析
### 递归解法
```java
public static int fib1(int n) {
	if (n <= 1) return n;
	return fib1(n - 1) + fib1(n - 2);
}
```
调用一下：`System.out.println(fib1(50));` 运行不出来<br />每次调用`fib1()`都要执行加法，所以就是看函数执行多少次来分析时间复杂度<br />以`fib(5)`为例，共执行了1+2+4+8次，`2^(5-1)-1`<br />`fib(n)`执行`2^(n-1)-1`次<br />所以时间复杂度是`O(2^N)`<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1681401333511-d428f042-d601-4d6f-9a07-373d911f1135.png#averageHue=%23f6f3ed&clientId=uc8369a09-9d53-4&from=paste&height=401&id=u83c50900&originHeight=751&originWidth=1651&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=234012&status=done&style=none&taskId=u9c2fbb44-a5f8-4d16-a64b-8be70cbebbe&title=&width=880.5333333333333)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1681402157018-853df055-c4b8-4037-a288-c9b94d9517da.png#averageHue=%23ebebeb&clientId=uc8369a09-9d53-4&from=paste&height=124&id=u721552d6&originHeight=233&originWidth=1017&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=126602&status=done&style=none&taskId=u0c9cf535-c755-4082-b7f5-0cff3cfcaec&title=&width=542.4)
### O(N)解法
```java
public static int fib2(int n) {
    if (n <= 1) return n;
    int first = 0;
    int second = 1;
    for (int i = 0; i < n - 1; i++) {
        int sum = first + second;
        first = second;
        second = sum;
    }
    return second;
}
```
# 02. 动态数组ArrayList
## 线性表介绍
### 什么是数据结构？
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1681525363686-673691d2-15e9-4812-8dca-0eeaa5c0266a.png#averageHue=%23f6f6f6&clientId=uf634c7e5-a0bd-4&from=paste&height=442&id=u006b946e&originHeight=828&originWidth=1779&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=402669&status=done&style=none&taskId=ufb35d872-8b97-4b71-8c21-2c102d95be2&title=&width=948.8)
### 线性表概念
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1681525468396-dd152b08-6651-4f5e-bcdc-6d54b2f4fad2.png#averageHue=%23fafafa&clientId=uf634c7e5-a0bd-4&from=paste&height=431&id=u4050b1c8&originHeight=808&originWidth=1772&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=240634&status=done&style=none&taskId=u49f717b1-a1a9-4e1d-a046-d47fb95e439&title=&width=945.0666666666667)
## 动态数组实现ArrayList
在很多程语言中，数组都有个致命的缺点，无法动态修改容量<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1681525887432-4532f95f-99b9-483a-bbf1-a4ead82ec1cd.png#averageHue=%23ed9155&clientId=uf634c7e5-a0bd-4&from=paste&height=453&id=uc0f3610f&originHeight=849&originWidth=1021&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=315763&status=done&style=none&taskId=ud69e9ab1-c0c8-4023-ab65-885d1ab313b&title=&width=544.5333333333333)<br />添加泛型：注意Java中的泛型只能是对象，不能是基本数据类型，可以使用基本数据类型的包装类
```java
public ArrayList(int capacity) {
capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
// 报错写法：
// elements = new E[capacity];
// 向下转型，可调用子类所有的成员
elements = (E[]) new Object[capacity];
}
```
对象数组里放的是对象的地址值，所以即便存储对象的类改变了也不会影响<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682046447322-3cfafe9c-e8fe-4ba5-b386-95e6b8c3769d.png#averageHue=%231ab262&clientId=ua76dbf77-57f2-4&from=paste&height=438&id=u83500dbc&originHeight=482&originWidth=873&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=81054&status=done&style=none&taskId=u44251406-e09d-441a-ae34-72bc1881a4e&title=&width=793.636346434759)
### clear
clear操作只`size = 0`会导致对象数组所有指向的Person都留存在内存中，不会释放，因为引用还存在<br />ArrayList类中实现`clear()`方法
```java
public void clear() {
    for (int i = 0; i < size; i++) {
        elements[i] = null;
    }
    size = 0;
}
```
Person类中实现遗言方法`finalize()`
```java
public class Person {
    ......

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(name+" finalize");
    }
}
```
测试的时候要提醒JVM垃圾回收
```java
public static void main(String[] args) {
    ArrayList<Person> arrayList = new ArrayList<>();

    arrayList.add(new Person(12, "Bruce"));
    arrayList.add(new Person(12, "Bruce"));

    arrayList.clear();
    // 提醒JVM垃圾回收
    System.gc();

    //Bruce finalize
    //Bruce finalize
}
```
### remove
同理，remove操作时清除最后一个单元存放的地址值
```
public E remove(int index) {
    rangeCheck(index);
    E old = elements[index];
    for (int i = index + 1; i < size; i++) {
        elements[i - 1] = elements[i];
    }
    // 最后一个元素清空
    elements[--size] = null;
    return old;
}
```
### indexOf()
比较元素的时候不能使用==，不然只是比较存放的地址值是不是一样<br />通过equals()方法比较，包装类已经重写了equals()方法，直接比较的是值
```
public int indexOf(E element) {
    for (int i = 0; i < size; i++) {
        //if (elements[i] == element) return i;
        if (elements[i].equals(element)) return i;
    }
    return ELEMENT_NOT_FOUND;
}
```
重写Person类的equals()方法
```
public class Person {
    private int age;
    private String name;

    @Override
    public boolean equals(Object obj) {
        Person person = (Person) obj;
        return this.age == person.age && this.name == person.name;
    }
}

```
### null值处理
```java
arrayList.add(null);
System.out.println(arrayList.indexOf(null));
```
.equals()内传参如果是null会报空指针异常，所以要先空值判断
```
public int indexOf(E element) {
    if (element == null) {
        for (int i = 0; i < size; i++) {
            if (elements[i] == null) return i;
        }
    } else {
        for (int i = 0; i < size; i++) {
            //if (elements[i] == element) return i;
            if (elements[i].equals(element)) return i;
        }
    }
    return ELEMENT_NOT_FOUND;
}
```
### 缩容处理
```java
private void trim() {
    int oldCapacity = elements.length;
    int newCapacity = oldCapacity >> 1;
    if (size >= newCapacity || size <= DEFAULT_CAPACITY) return;
    E[] newElements = (E[]) new Object[newCapacity];
    for (int i = 0; i < size; i++) {
        newElements[i] = elements[i];
    }
    elements = newElements;
    System.out.println(oldCapacity + "缩容为" + newCapacity);
}
```
缩容处理在remove()中调用，每删除一个元素看看是否要缩容
```java
public E remove(int index) {
    rangeCheck(index);
    E old = elements[index];
    for (int i = index + 1; i < size; i++) {
        elements[i - 1] = elements[i];
    }
    // 最后一个元素清空
    elements[--size] = null;
    // 缩容
    trim();
    return old;
}
```
clear()操作后也要缩容
```java
public void clear() {
    for (int i = 0; i < size; i++) {
        elements[i] = null;
    }
    size = 0;
    // 缩容
    if (elements != null && elements.length > DEFAULT_CAPACITY) {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }
}
```
### 完整代码
```java
package com.boer.limingjie_suanfa.动态数组;

import com.boer.limingjie_suanfa.AbstractList;
import com.boer.limingjie_suanfa.List;

public class ArrayList<E> extends AbstractList<E> {

    private E[] elements;

    public ArrayList(int capacity) {
        capacity = (capacity < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capacity;
        // 报错写法：
        // elements = new E[capacity];
        // 向下转型，可调用子类所有的成员
        elements = (E[]) new Object[capacity];
    }

    public ArrayList() {
        //elements=new int[DEFAULT_CAPACITY];
        this(DEFAULT_CAPACITY);
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[i] = null;
        }
        size = 0;
        // 缩容
        if (elements != null && elements.length > DEFAULT_CAPACITY) {
            elements = (E[]) new Object[DEFAULT_CAPACITY];
        }
    }


    public E get(int index) {
        rangeCheck(index);
        return elements[index];
    }

    public E set(int index, E element) {
        rangeCheck(index);
        E old = elements[index];
        elements[index] = element;
        return old;
    }

    public int indexOf(E element) {
        if (element == null) {
            for (int i = 0; i < size; i++) {
                if (elements[i] == null) return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                //if (elements[i] == element) return i;
                if (elements[i].equals(element)) return i;
            }
        }
        return ELEMENT_NOT_FOUND;
    }


    public void add(int index, E element) {
        rangeCheckForAdd(index);
        ensureCapacity(size + 1);
        for (int i = size - 1; i >= index; i--) {
            elements[i + 1] = elements[i];
        }
        elements[index] = element;
        size++;
    }

    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 位运算的效率高
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + "扩容为" + newCapacity);
    }

    public E remove(int index) {
        rangeCheck(index);
        E old = elements[index];
        for (int i = index + 1; i < size; i++) {
            elements[i - 1] = elements[i];
        }
        // 最后一个元素清空
        elements[--size] = null;
        // 缩容
        trim();
        return old;
    }

    private void trim() {
        int oldCapacity = elements.length;
        int newCapacity = oldCapacity >> 1;
        if (size >= newCapacity || size <= DEFAULT_CAPACITY) return;
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[i];
        }
        elements = newElements;
        System.out.println(oldCapacity + "缩容为" + newCapacity);
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        for (int i = 0; i < size; i++) {
            if (i != 0) string.append(", ");
            string.append(elements[i]);
        }
        string.append("]");
        return string.toString();
    }
}

```
# 03. 链表
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682059970737-7178f868-c3a5-4171-a484-3673c01124f5.png#averageHue=%23f5eae3&clientId=ua76dbf77-57f2-4&from=paste&height=415&id=ub6f79b2c&originHeight=456&originWidth=824&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=128906&status=done&style=none&taskId=u66d5a2d1-3880-4870-93d2-2dc58586e77&title=&width=749.0908928548013)
## 单向链表
### List接口及AbstractList抽象类
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682063425070-a13e1872-1c05-46a9-8872-43fa4edb8484.png#averageHue=%23fefefc&clientId=ua76dbf77-57f2-4&from=paste&height=369&id=l1R8u&originHeight=406&originWidth=373&originalType=binary&ratio=1.25&rotation=0&showTitle=false&size=37556&status=done&style=none&taskId=u041f3107-76ea-4a59-af5d-b74ad3e99b9&title=&width=339.0909017413117)<br />LinkedList和ArrayList方法名几乎都是相似的，故可以在List接口中声明公共的方法，实现多态！<br />AbstractList作为抽象类可以抽取相同的代码，AbstractList和LinkedList共同继承AbstractList类，AbstractList实现List接口，抽象类可以不实现接口中的全部方法，交给子类实现<br />AbstractList类中方法声明为protected，只给子类用。<br />DEFAULT_CAPACITY、ELEMENT_NOT_FOUND应该放在List中，默认是public，但要用final修饰，外界可以访问但不允许修改<br />size放在AbstractList中，protected修饰，不让外界访问
```java
public interface List<E> {
    // 不允许外界修改
    static final int DEFAULT_CAPACITY = 3;
    static final int ELEMENT_NOT_FOUND = -1;

    void clear();

    int size();

    boolean isEmpty();

    boolean contains(E element);

    E get(int index);

    E set(int index, E element);

    int indexOf(E element);

    void add(E element);

    void add(int index, E element);

    E remove(int index);
}
```
```java
// abstract类可以不实现接口中的某些方法，交给子类实现
public abstract class AbstractList<E> implements List<E>{
    protected int size;

    protected void rangeCheck(int index) {
        if (index < 0 || index >= size) outOfBounds(index);
    }

    protected void rangeCheckForAdd(int index) {
        if (index < 0 || index > size) outOfBounds(index);
    }

    protected void outOfBounds(int index) {
        throw new IndexOutOfBoundsException("Index:" + index + ", Size:" + size);
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean contains(E element) {
        return indexOf(element) != ELEMENT_NOT_FOUND;
    }

    public void add(E element) {
//        ensureCapacity(size + 1);
//        elements[size++] = element;
        add(size, element);
    }
}

```

### 无虚拟头结点版
#### clear()
把头结点设为null，后面的节点都会自动释放（应该是没引用能指向这条链表了，垃圾回收会释放掉）
```
@Override
public void clear() {
    size = 0;
    first = null;
}
```
#### 获取index位置对应的节点对象
链表是没有索引的，只能用顺序查找的办法
```java
/**
 * 获取index位置对应的节点对象
 */
private Node<E> node(int index) {
    rangeCheck(index);
    Node<E> node = first;
    for (int i = 0; i < index; i++) {
        node = node.next;
    }
    return node;
}
```
#### 完整代码
```java
package com.boer.limingjie_suanfa.链表;

import com.boer.limingjie_suanfa.AbstractList;
import com.boer.limingjie_suanfa.List;

public class LinkedList<E> extends AbstractList<E> {
    private static int ELEMENT_NOT_FOUND = -1;

    private Node<E> first;

    public LinkedList() {
    }

    public LinkedList(int size, Node<E> first) {
        this.size = size;
        this.first = first;
    }

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            first = new Node<>(element, first);
        } else {
            Node<E> prev = node((index - 1));
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node;
        if (index == 0) {
            node = first;
            first = first.next;
        } else {
            Node<E> prev = node(index - 1);
            node = prev.next;
            prev.next = node.next;
        }
        size--;
        return node.element;
    }

    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node.element);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}
```
### 虚拟头结点版
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682216043548-660afaf6-a6e0-4fc3-91c2-55752c27dc72.png#averageHue=%23f7e9e2&clientId=u9a38e4b2-2715-4&from=paste&height=299&id=ua94d0f2f&originHeight=329&originWidth=893&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=87604&status=done&style=none&taskId=ub821c236-f016-40b8-8ce7-9a23bd31bf2&title=&width=811.818164222497)<br />在需要找到前置结点的操作中，因为头结点没有前置结点，所以需要区别对待，有了虚拟头结点就可以统一处理逻辑
#### 构造函数
```java
public LinkedList2() {
    first = new Node<E>(null, null);
}
```
#### 统一操作
以add为例，这里Override的是List接口的add方法
```java
@Override
public void add(int index, E element) {
    rangeCheckForAdd(index);
    Node<E> prev = index == 0 ? first : node((index - 1));
    prev.next = new Node<>(element, prev.next);
    size++;
}
```
#### 完整代码
```java
/**
 * 增加虚拟头结点
 *
 * @param <E>
 */
public class LinkedList2<E> extends AbstractList<E> {
    private static int ELEMENT_NOT_FOUND = -1;

    private Node<E> first;

    public LinkedList2() {
        first = new Node<E>(null, null);
    }

    public LinkedList2(int size, Node<E> first) {
        this.size = size;
        this.first = first;
    }

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first.next;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first.next;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        Node<E> prev = index == 0 ? first : node((index - 1));
        prev.next = new Node<>(element, prev.next);
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> prev = index == 0 ? first : node((index - 1));
        Node<E> node = prev.next;
        prev.next = node.next;
        size--;
        return node.element;
    }

    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first.next;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first.next;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node.element);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}
```
## 双向链表

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682236942852-241c651c-06d3-4d0a-91cf-2bc7d5cdf2f8.png#averageHue=%23f7eae1&clientId=u9a38e4b2-2715-4&from=paste&height=352&id=ue9e8044f&originHeight=387&originWidth=883&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=110781&status=done&style=none&taskId=udd65215e-b90b-4b93-b528-9911a82a927&title=&width=802.7272553286281)
### 完整代码
```java
package com.boer.limingjie_suanfa.链表;

import com.boer.limingjie_suanfa.AbstractList;

/**
 * 增加虚拟头结点
 *
 * @param <E>
 */
public class LinkedList<E> extends AbstractList<E> {
    private Node<E> first;
    private Node<E> last;

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;

        public Node(E element, Node<E> prev, Node<E> next) {
            this.element = element;
            this.prev = prev;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_").append(element).append("_");
            if (next != null) {
                sb.append(next.element);
            } else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        //往最后面添加元素
        if (index == size) {
            Node<E> oldLast = last;
            last = new Node<>(element, oldLast, null);
            // size=index=0，这是链表添加的第一个元素
            if (oldLast == null) {
                first = last;
            } else {
                oldLast.next = last;
            }
        } else {
            Node<E> next = node(index);
            Node<E> prev = next.prev;
            Node<E> node = new Node<>(element, prev, next);
            next.prev = node;
            //在链表的第一个位置添加元素
            if (prev == null) {
                first = node;
            } else {
                prev.next = node;
            }
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = node(index);
        Node<E> prev = node.prev;
        Node<E> next = node.next;
        if (prev == null) {
            first = next;
        } else {
            prev.next = next;
        }
        if (next == null) {
            last = prev;
        } else {
            next.prev = prev;
        }
        size--;
        return node.element;
    }

    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        if (index < size >> 1) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}

```
### 性能对比
双向链表vs单向链表<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682315961818-d17937d7-83ee-473b-bbdc-682f128ca6c3.png#averageHue=%23f6f6f6&clientId=u9a38e4b2-2715-4&from=paste&height=176&id=ueb97476c&originHeight=194&originWidth=707&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=48039&status=done&style=none&taskId=ue2483538-c5a4-4c04-aa1e-028816d802d&title=&width=642.7272587965346)<br />双向链表vs动态数组<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682316341702-6731db73-97fd-4807-888b-b8c17af7fb9f.png#averageHue=%23f0efee&clientId=u9a38e4b2-2715-4&from=paste&height=208&id=uad02432d&originHeight=229&originWidth=745&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=125702&status=done&style=none&taskId=u7eeecd81-b8ab-4adc-a2f6-5411504b7e7&title=&width=677.2727125932365)
## 单向循环链表
直接修改单向链表，`add()`和`remove()`操作时需要维护尾结点的尾指针<br />`add()`
```java
@Override
public void add(int index, E element) {
    rangeCheckForAdd(index);
    if (index == 0) {
        // first指针还没变
        Node<E> newFirst = new Node<>(element, first);
        Node<E> last = (size == 0) ? newFirst : node(size - 1);
        last.next = newFirst;
        first = newFirst;
    } else {
        Node<E> prev = node((index - 1));
        prev.next = new Node<>(element, prev.next);
    }
    size++;
}
```
`remove()`
```java
@Override
public E remove(int index) {
    rangeCheck(index);
    Node<E> node = first;
    if (index == 0) {
        // size>=1
        if (size == 1) {
            first = null;
            return null;
        } else {
            Node<E> last = node(size - 1);
            first = first.next;
            last.next = first;
        }
    } else {
        Node<E> prev = node(index - 1);
        node = prev.next;
        prev.next = node.next;
    }
    size--;
    return node.element;
}
```
### 完整代码
```java
package com.boer.limingjie_suanfa.链表;

import com.boer.limingjie_suanfa.AbstractList;

public class SingleCircleLinkedList<E> extends AbstractList<E> {

    private Node<E> first;

    public SingleCircleLinkedList() {
    }

    public SingleCircleLinkedList(int size, Node<E> first) {
        this.size = size;
        this.first = first;
    }

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> next;

        public Node(E element, Node<E> next) {
            this.element = element;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(element).append("_").append(next.element);
            return sb.toString();
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        if (index == 0) {
            // first指针还没变
            Node<E> newFirst = new Node<>(element, first);
            Node<E> last = (size == 0) ? newFirst : node(size - 1);
            last.next = newFirst;
            first = newFirst;
        } else {
            Node<E> prev = node((index - 1));
            prev.next = new Node<>(element, prev.next);
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = first;
        if (index == 0) {
            // size>=1
            if (size == 1) {
                first = null;
                return null;
            } else {
                Node<E> last = node(size - 1);
                first = first.next;
                last.next = first;
            }
        } else {
            Node<E> prev = node(index - 1);
            node = prev.next;
            prev.next = node.next;
        }
        size--;
        return node.element;
    }

    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        Node<E> node = first;
        for (int i = 0; i < index; i++) {
            node = node.next;
        }
        return node;
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}

```
## 双向循环链表
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682321245771-d68f7224-4608-4d30-b0ba-b609f933d602.png#averageHue=%23f7e7de&clientId=u9a38e4b2-2715-4&from=paste&height=375&id=u3b703a4a&originHeight=413&originWidth=713&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=93250&status=done&style=none&taskId=uf2f625d5-8c78-4c02-9733-206d36161f3&title=&width=648.181804132856)<br />同双向链表的差别在于`add()`和`remove()`操作上
```java
@Override
public void add(int index, E element) {
    rangeCheckForAdd(index);
    if (index == 0) {
        // first指针还没变
        Node<E> newFirst = new Node<>(element, first);
        Node<E> last = (size == 0) ? newFirst : node(size - 1);
        last.next = newFirst;
        first = newFirst;
    } else {
        Node<E> prev = node((index - 1));
        prev.next = new Node<>(element, prev.next);
    }
    size++;
}

@Override
public E remove(int index) {
    rangeCheck(index);
    Node<E> node = first;
    if (index == 0) {
        // size>=1
        if (size == 1) {
            first = null;
            return null;
        } else {
            Node<E> last = node(size - 1);
            first = first.next;
            last.next = first;
        }
    } else {
        Node<E> prev = node(index - 1);
        node = prev.next;
        prev.next = node.next;
    }
    size--;
    return node.element;
}
```
### 完整代码
```java
package com.boer.limingjie_suanfa.链表;

import com.boer.limingjie_suanfa.AbstractList;

/**
 * 增加虚拟头结点
 *
 * @param <E>
 */
public class CircleLinkedList<E> extends AbstractList<E> {
    private Node<E> first;
    private Node<E> last;

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;

        public Node(E element, Node<E> prev, Node<E> next) {
            this.element = element;
            this.prev = prev;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_").append(element).append("_");
            if (next != null) {
                sb.append(next.element);
            } else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        //往最后面添加元素
        if (index == size) {
            Node<E> oldLast = last;
            last = new Node<>(element, oldLast, first);
            // size=index=0，这是链表添加的第一个元素
            if (oldLast == null) {
                first = last;
                first.next = first;
                first.prev = first;
            } else {
                oldLast.next = last;
                first.prev = last;
            }
        } else {
            Node<E> next = node(index);
            Node<E> prev = next.prev;
            Node<E> node = new Node<>(element, prev, next);
            next.prev = node;
            prev.next = node;
            //在链表的第一个位置添加元素，这里已经不存在prev==null的情况
            //if (prev == null) {
            if (index == 0) {
                first = node;
            }
        }
        size++;
    }

    @Override
    public E remove(int index) {
        rangeCheck(index);
        Node<E> node = first;
        if (size == 1) {
            first = null;
            last = null;
        } else {
            node = node(index);
            Node<E> prev = node.prev;
            Node<E> next = node.next;
            prev.next = next;
            next.prev = prev;
            if (node == first) { // 删除头结点
                first = next;
            }
            if (node == last) { // 删除尾结点
                last = prev;
            }
        }
        size--;
        return node.element;
    }

    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        if (index < size >> 1) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}
```
## 练习
### 237. 删除链表中的节点
难点：获取不到前置结点
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
class Solution {
    public void deleteNode(ListNode node) {
        node.val=node.next.val;
        node.next=node.next.next;
    }
}
```
### 206. 反转链表
递归解法：（难）
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        ListNode newHead= reverseList(head.next);
        //从最后一个结点的前一个结点开始修改指针操作
        head.next.next=head;
        //最后结点1的next需要为null
        head.next=null;
        //返回的newHead始终是结点5
        return newHead;
    }
}
```
迭代：难点在于需要一个节点防止丢失链表
```java
public class Solution207 {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode tmp;
        ListNode newHead = null;
        while (head != null) {
            tmp = head.next;
            head.next = newHead;
            newHead = head;
            head = tmp;
        }
        return newHead;
    }
}
```
### 141. 环形链表
快慢指针
```java
public class Solution141 {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) return false;
        ListNode fast = head.next;
        while (fast != null && fast.next != null) {
            if (fast == head) return true;
            fast = fast.next.next;
            head = head.next;
        }
        return false;
    }
}
```
### 约瑟夫问题
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682325595270-f9d9d4a6-aab7-47c8-8224-b0371a2466f2.png#averageHue=%23f6f6f6&clientId=u9a38e4b2-2715-4&from=paste&height=208&id=u03dcfbf6&originHeight=229&originWidth=634&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=60237&status=done&style=none&taskId=u86c19e8b-af27-49dc-bf21-3ecb6c1eebd&title=&width=576.3636238712912)<br />在单向循环或者双向循环链表上该都可以，因为方法都已经封装好了，这里以双向循环链表为例<br />看三个新增的方法即可
```java
package com.boer.limingjie_suanfa.链表.practice;

import com.boer.limingjie_suanfa.AbstractList;

/**
 * 增加虚拟头结点
 *
 * @param <E>
 */
public class JosephCircleLinkedList<E> extends AbstractList<E> {
    private Node<E> first;
    private Node<E> last;
    private Node<E> current;

    //建议设置为静态内部类，不要问为什么，语法问题
    private static class Node<E> {
        E element;
        Node<E> prev;
        Node<E> next;

        public Node(E element, Node<E> prev, Node<E> next) {
            this.element = element;
            this.prev = prev;
            this.next = next;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            if (prev != null) {
                sb.append(prev.element);
            } else {
                sb.append("null");
            }
            sb.append("_").append(element).append("_");
            if (next != null) {
                sb.append(next.element);
            } else {
                sb.append("null");
            }
            return sb.toString();
        }
    }

    public void reset() {
        current = first;
    }

    public E next() {
        if (current == null) return null;
        //循环链表，只剩一个结点，next还是指向自己
        current = current.next;
        return current.element;
    }

    // 删除current节点
    public E remove() {
        if (current == null) return null;
        Node<E> next = current.next;
        E element = remove(current);
        if (size == 0) {
            current = null;
        } else {
            //循环链表，只剩一个结点，next还是指向自己
            current = next;
        }
        return element;
    }

    // 根据索引删除
    @Override
    public E remove(int index) {
        rangeCheck(index);
        return remove(node(index));
    }

    // 根据节点删除
    private E remove(Node<E> node) {
        if (size == 1) {
            first = null;
            last = null;
        } else {
            Node<E> prev = node.prev;
            Node<E> next = node.next;
            prev.next = next;
            next.prev = prev;
            if (node == first) { // 删除头结点
                first = next;
            }
            if (node == last) { // 删除尾结点
                last = prev;
            }
        }
        size--;
        return node.element;
    }

    @Override
    public void clear() {
        size = 0;
        first = null;
        last = null;
    }

    @Override
    public E get(int index) {
        return node(index).element;
    }

    @Override
    public E set(int index, E element) {
        Node<E> node = node(index);
        E old = node.element;
        node.element = element;
        return old;
    }

    @Override
    public int indexOf(E element) {
        if (element == null) {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element == null) return i;
                node = node.next;
            }
        } else {
            Node<E> node = first;
            for (int i = 0; i < size; i++) {
                if (node.element.equals(element)) return i;
                node = node.next;
            }
        }
        return ELEMENT_NOT_FOUND;
    }

    @Override
    public void add(int index, E element) {
        rangeCheckForAdd(index);
        //往最后面添加元素
        if (index == size) {
            Node<E> oldLast = last;
            last = new Node<>(element, oldLast, first);
            // size=index=0，这是链表添加的第一个元素
            if (oldLast == null) {
                first = last;
                first.next = first;
                first.prev = first;
            } else {
                oldLast.next = last;
                first.prev = last;
            }
        } else {
            Node<E> next = node(index);
            Node<E> prev = next.prev;
            Node<E> node = new Node<>(element, prev, next);
            next.prev = node;
            prev.next = node;
            //在链表的第一个位置添加元素，这里已经不存在prev==null的情况
            //if (prev == null) {
            if (index == 0) {
                first = node;
            }
        }
        size++;
    }


    /**
     * 获取index位置对应的节点对象
     */
    private Node<E> node(int index) {
        rangeCheck(index);
        if (index < size >> 1) {
            Node<E> node = first;
            for (int i = 0; i < index; i++) {
                node = node.next;
            }
            return node;
        } else {
            Node<E> node = last;
            for (int i = size - 1; i > index; i--) {
                node = node.prev;
            }
            return node;
        }
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string.append("size=").append(size).append(", [");
        Node<E> node = first;
        for (int i = 0; i < size; i++) {
            if (i != 0) {
                string.append(", ");
            }
            string.append(node);
            node = node.next;
        }
        string.append("]");
        return string.toString();
    }
}

```
主逻辑
```java
/**
 * 测试约瑟夫问题
 */
public static void testJoseph() {
    JosephCircleLinkedList<Integer> list = new JosephCircleLinkedList<>();
    for (int i = 0; i < 8; i++) {
        list.add(i);
    }
    list.reset();
    while (!list.isEmpty()) {
        list.next();
        list.next();
        System.out.println(list.remove());
    }
}
```
# 04. 栈
## 接口设计
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682471618246-e0f00711-1562-4730-921d-1b46032a2383.png#averageHue=%23f9f9f9&clientId=u9a38e4b2-2715-4&from=paste&height=295&id=u44d77d1f&originHeight=325&originWidth=692&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=70490&status=done&style=none&taskId=ufd49316f-2b27-45a4-b773-4a23ab800fc&title=&width=629.0908954557311)
## 具体实现
我们可以直接使用之前已经实现的ArrayList，继承是一种方式
```java
public class Stack<E> extends ArrayList<E>
```
继承的弊端在于，Stack同时也拥有了很多它不具备的功能，比如`add(int index, E element)`等，栈只能在顶部添加元素<br />可以采用下面的方式
```java
public class Stack<E> {

    private List<E> list = new ArrayList<>();

    public void clear() {
        list.clear();
    }

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    public void push(E element) {
        list.add(element);
    }

    public E pop() {
        return list.remove(list.size() - 1);
    }

    public E top() {
        return list.get(list.size() - 1);
    }
}
```
## java官方栈
`java.util.stack`
```java
public class Stack<E> extends Vector<E>{}
```
java官方栈直接继承的Vector（坏处前面已经提过），Vector和ArrayList的区别是线程安全与不安全
## 练习
### 20. 有效的括号
```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    int len = s.length();
    for (int i = 0; i < len; i++) {
        char c = s.charAt(i);
        if (c == '(' || c == '{' || c == '[') {
            stack.push(c);
        } else {
            if (stack.isEmpty()) return false;
            //左括号
            char left = stack.pop();
            if (left == '(' && c != ')') return false;
            if (left == '[' && c != ']') return false;
            if (left == '{' && c != '}') return false;
        }
    }
    // 栈里可能还有左括号没匹配完
    return stack.isEmpty();
}
```
# 05. 队列
## 普通队列
### 接口设计
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682476949524-74c47b7f-5499-42d1-abe2-db31f39ff908.png#averageHue=%23f9f8f8&clientId=ub9a3d675-03a9-4&from=paste&height=325&id=u69690732&originHeight=357&originWidth=847&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=102791&status=done&style=none&taskId=u99da595f-5ea3-4d7d-ba8a-7e746de2108&title=&width=769.9999833106998)
### 具体实现
这列我们用之前实现的双向链表`LinkedList`来实现队列<br />在表尾添加元素，表头删除元素。即队头表头，队尾表尾
```java
public class Queue<E> {
    List<E> list = new LinkedList<>();

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    // 入队
    public void enQueue(E element) {
        list.add(element);
    }

    // 出队
    public E deQueue() {
        return list.remove(0);
    }

    // 获取队列的头元素
    public E front() {
        return list.get(0);
    }

    public void clear() {
        list.clear();
    }
}
```
## 双端队列
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682491873463-3b059741-5e5b-4243-a477-b229df17492d.png#averageHue=%23f9f9f9&clientId=u4c7c04e3-7a7a-4&from=paste&height=369&id=uea31c4fe&originHeight=406&originWidth=838&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=118794&status=done&style=none&taskId=u1094e233-6f46-4bbe-a3ce-ec14923438e&title=&width=761.8181653062178)
```java
public class Deque<E> {
    List<E> list = new LinkedList<>();

    public int size() {
        return list.size();
    }

    public boolean isEmpty() {
        return list.isEmpty();
    }

    // 队尾入队
    public void enQueueRear(E element) {
        list.add(element);
    }

    // 队头入队
    public void enQueueFront(E element) {
        list.add(0, element);
    }

    // 队尾出队
    public E deQueueRear() {
        return list.remove(list.size() - 1);
    }

    // 队头出队
    public E deQueueFront() {
        return list.remove(0);
    }

    // 获取队头元素
    public E front() {
        return list.get(0);
    }

    // 获取队尾元素
    public E rear() {
        return list.get(list.size() - 1);
    }

    public void clear() {
        list.clear();
    }

    @Override
    public String toString() {
        return list.toString();
    }
}
```
## Java官方队列

查看`java.util.Queue`，发现这是个接口，下面还有个子接口`Deque`，而`LinkedList`是其具体的一个实现类，故Java官方的`LinkedList`实现了双向链表和双端队列

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682490014194-10ed5775-1c57-4548-b8cd-0f34c90f7e35.png#averageHue=%23514e42&clientId=ub9a3d675-03a9-4&from=paste&height=237&id=bJnk7&originHeight=261&originWidth=385&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=16262&status=done&style=none&taskId=u77b67685-5992-4588-b9b5-23114774f72&title=&width=349.9999924139545)

> Doubly-linked list implementation of the List and Deque interfaces.  Implements all optional list operations, and permits all elements (including null).
> list和Deque接口的双链表实现。实现所有可选列表操作，并允许所有元素(包括null)。

## 循环队列

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682493633453-33da20cd-2d2a-49bf-9803-1142e1baf82b.png#averageHue=%23fbfafa&clientId=u4c7c04e3-7a7a-4&from=paste&height=239&id=u73135a9d&originHeight=263&originWidth=634&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=47155&status=done&style=none&taskId=uee7ca6e6-ef9f-4a62-8bae-a8c7e884bf7&title=&width=576.3636238712912)
### 循环队列具体实现
#### 索引转换
循环队列中的索引和在数组中存放的真实索引可能不同，所以需要进行索引转换<br />front是当前队头在数组中的索引
```java
//将循环队列上当前虚拟的索引转换为在数组中真实存放的索引
private int index(int index) {
    return (front + index) % elements.length;
}
```
%运算符优化：尽量避免使用乘*、除/、模%、浮点数运算，效率低下<br />上面的代码和下面这段是等价的
```java
private int index(int index) {
    index += front;
    return index - (index >= elements.length ? elements.length : 0);
}
```
#### clear()
这里判断条件是`i < size`，而不是`i < elements.length`，因为可能1000的容量里只存了两个元素，这么清可以节约时间
```java
public void clear() {
    for (int i = 0; i < size; i++) {
        elements[index(i)] = null;
    }
    size = 0;
    front = 0;
}
```
#### 完整代码
```java
public class CircleQueue<E> {
    public int front; //存储头的下标
    public int size;
    private E[] elements;
    static final int DEFAULT_CAPACITY = 10;

    public CircleQueue() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[index(i)] = null;
        }
        size = 0;
        front = 0;
    }

    public void enQueue(E element) {
        ensureCapacity(size + 1);
        elements[index(size)] = element;
        size++;
    }

    public E deQueue() {
        E frontElement = elements[front];
        elements[front] = null;
        front = index(1);
        size--;
        return frontElement;
    }

    public E front() {
        return elements[front];
    }

    //将循环队列上当前虚拟的索引转换为在数组中真实存放的索引
    private int index(int index) {
        index += front;
        return index - (index >= elements.length ? elements.length : 0);
    }

    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 位运算的效率高
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        front = 0;
        System.out.println(oldCapacity + "扩容为" + newCapacity);
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string
                .append("capacity=")
                .append(elements.length)
                .append(", size=")
                .append(size)
                .append(", front=")
                .append(front)
                .append(", [");
        for (int i = 0; i < elements.length; i++) {
            if (i != 0) string.append(", ");
            string.append(elements[i]);
        }
        string.append("]");
        return string.toString();
    }
}

```
### 双端循环队列具体实现
> 在循环队列的基础上修改

双端循环队列不需要额外设计队尾索引，我们只要知道队头索引`front`和`size`就能计算出队尾索引，还不用额外维护队尾索引（需要考虑边界问题）<br />双端循环队列新增了在队头入队，队尾出队的操作
```java
// 队头入队
public void enQueueFront(E element) {
    ensureCapacity(size + 1);
    front = index(-1);
    elements[front] = element;
    size++;
}
```
这里`index(-1)`表示在当前的`front`位置前面一个插入元素，当`front=0`时会出现负数的情况，所以需要修改`index()`方法
```java
//将循环队列上当前虚拟的索引转换为在数组中真实存放的索引
private int index(int index) {
    index += front;
    if (index < 0) {
        return index + elements.length;
    }
//        return index % elements.length;
    // %运算符优化
    return index - (index >= elements.length ? elements.length : 0);
}
```
队尾出队：这里直接计算出队尾索引`realIndex`，且删除队尾元素后不需要额外维护队尾索引
```java
// 队尾出队
public E deQueueRear() {
    int realIndex = index(size - 1);
    E real = elements[realIndex];
    elements[realIndex] = null;
    size--;
    return real;
}
```
#### 完整代码
```java
/**
 * 循环双端队列
 *
 * @param <E>
 */
public class CircleDeque<E> {
    private int front; //存储头的下标
    private int size;
    private E[] elements;
    static final int DEFAULT_CAPACITY = 10;

    public CircleDeque() {
        elements = (E[]) new Object[DEFAULT_CAPACITY];
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {
        for (int i = 0; i < size; i++) {
            elements[index(i)] = null;
        }
        size = 0;
        front = 0;
    }

    // 队尾入队
    public void enQueueRear(E element) {
        ensureCapacity(size + 1);
        elements[index(size)] = element;
        size++;
    }

    // 队头入队
    public void enQueueFront(E element) {
        ensureCapacity(size + 1);
        front = index(-1);
        elements[front] = element;
        size++;
    }

    // 队尾出队
    public E deQueueRear() {
        int realIndex = index(size - 1);
        E real = elements[realIndex];
        elements[realIndex] = null;
        size--;
        return real;
    }

    // 队头出队
    public E deQueueFront() {
        E frontElement = elements[front];
        elements[front] = null;
        front = index(1);
        size--;
        return frontElement;
    }

    // 获取队头元素
    public E front() {
        return elements[front];
    }

    // 获取队尾元素
    public E rear() {
        return elements[index(size - 1)];
    }

    //将循环队列上当前虚拟的索引转换为在数组中真实存放的索引
    private int index(int index) {
        index += front;
        if (index < 0) {
            return index + elements.length;
        }
//        return index % elements.length;
        // %运算符优化
        return index - (index >= elements.length ? elements.length : 0);
    }

    private void ensureCapacity(int capacity) {
        int oldCapacity = elements.length;
        if (oldCapacity >= capacity) return;
        // 位运算的效率高
        int newCapacity = oldCapacity + (oldCapacity >> 1);
        E[] newElements = (E[]) new Object[newCapacity];
        for (int i = 0; i < size; i++) {
            newElements[i] = elements[index(i)];
        }
        elements = newElements;
        front = 0;
        System.out.println(oldCapacity + "扩容为" + newCapacity);
    }

    @Override
    public String toString() {
        StringBuilder string = new StringBuilder();
        string
                .append("capacity=")
                .append(elements.length)
                .append(", size=")
                .append(size)
                .append(", front=")
                .append(front)
                .append(", [");
        for (int i = 0; i < elements.length; i++) {
            if (i != 0) string.append(", ");
            string.append(elements[i]);
        }
        string.append("]");
        return string.toString();
    }
}

```
## 练习
### 232. 用栈实现队列
```java
public class MyQueue {
    private Stack<Integer> inStack;
    private Stack<Integer> outStack;

    public MyQueue() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }

    public void push(int x) {
        inStack.push(x);
    }

    public int pop() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.pop();
    }

    public int peek() {
        if (outStack.isEmpty()) {
            while (!inStack.isEmpty()) {
                outStack.push(inStack.pop());
            }
        }
        return outStack.peek();
    }

    public boolean empty() {
        return inStack.isEmpty() && outStack.empty();
    }
}
```

# 06. 二叉树

## 完全二叉树

面试题

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682348154796-0e7c00e1-754c-4a70-9b78-18e523d039d5.png#averageHue=%23f3f2f2&clientId=u97d08d7e-4035-4&from=paste&height=353&id=u5a54644f&originHeight=809&originWidth=1256&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=357263&status=done&style=none&taskId=uf654dd58-e19b-4049-b308-baa727104d8&title=&width=548.7802734375)
## 具体实现
### 二叉树的遍历
#### 前序遍历
```java
public void preorderTraversal(Node<E> node) {
    if (node == null) return;
    System.out.println(node.element); //可替换其他操作
    preorderTraversal(node.left);
    preorderTraversal(node.right);
}
```
#### 中序遍历
```java
private void inorderTraversal(Node<E> node) {
    if (node == null) return;
    inorderTraversal(node.left);
    System.out.println(node.element); //可替换其他操作
    inorderTraversal(node.right);
}
```
#### 后序遍历
```java
private void postorderTraversal(Node<E> node) {
    if (node == null) return;
    postorderTraversal(node.left);
    postorderTraversal(node.right);
    System.out.println(node.element); //可替换其他操作
}
```
#### 层序遍历
```java
public void levelOrderTraversal() {
    if (root == null) return;
    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
    Node<E> node;
    while (!queue.isEmpty()) {
        node = queue.poll();
        System.out.println(node.element);
        if (node.left!=null){
            queue.offer(node.left);
        }
        if (node.right!=null){
            queue.offer(node.right);
        }
    }
}
```

#### 根据遍历结果重构二叉树

以下结果可以保证重构出唯一一棵二叉树
- 前序遍历 + 中序遍历
- 后序遍历 + 中序遍历

#### 增强二叉树遍历

我们可以自定义遍历时对节点的操作，比如遇到结点元素值=2时停止遍历

```java
public class BinarySearchTree<E> implements BinaryTreeInfo {

    /**
     * 自定义访问结点的操作
     * @param <E>
     */
    public static abstract class Visitor<E> {
        boolean stop;

        // 返回true就代表停止遍历
        abstract boolean visit(E element);
    }

    public void preorderTraversal(Visitor<E> visitor) {
        if (visitor == null) return;
        preorderTraversal(root, visitor);
    }

    public void preorderTraversal(Node<E> node, Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
        preorderTraversal(node.left, visitor);
        preorderTraversal(node.right, visitor);
    }

    public void inorderTraversal(Visitor<E> visitor) {
        if (visitor == null) return;
        inorderTraversal(root, visitor);
    }

    private void inorderTraversal(Node<E> node, Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        inorderTraversal(node.left, visitor);
        if (visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
        inorderTraversal(node.right, visitor);
    }

    public void postorderTraversal(Visitor<E> visitor) {
        if (visitor == null) return;
        postorderTraversal(root, visitor);
    }

    private void postorderTraversal(Node<E> node, Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        postorderTraversal(node.left, visitor);
        postorderTraversal(node.right, visitor);
        if (visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
    }

    public void levelOrderTraversal(Visitor<E> visitor) {
        if (root == null || visitor == null) return;

        Queue<Node<E>> queue = new LinkedList<>();
        queue.offer(root);
        Node<E> node;

        while (!queue.isEmpty()) {
            node = queue.poll();
            if (visitor.visit(node.element)) return;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }
}
```
调用
```java
public static void testVisitor() {
    BinarySearchTree<Integer> bst = new BinarySearchTree<>();
    for (int i = 0; i < 30; i++) {
        bst.add((int) (Math.random() * 100));
    }
    BinaryTrees.println(bst);

    // 传入Visitor的子类，实现visit()方法
    bst.levelOrderTraversal(new BinarySearchTree.Visitor<Integer>() {
        @Override
        public boolean visit(Integer element) {
            System.out.print(element+" ");
            // 遇到元素2就停止遍历
            return element == 2 ? true : false;
        }
    });
}
```

## 完整代码

```java
package com.boer.limingjie_suanfa._07_二叉搜索树;

import com.boer.limingjie_suanfa._07_二叉搜索树.BST;
import com.boer.limingjie_suanfa.utils.printer.BinaryTreeInfo;

import java.util.LinkedList;
import java.util.Queue;

public class BinaryTree<E> implements BinaryTreeInfo {
    protected int size;
    protected Node<E> root;

    protected static class Node<E> {
        E element;
        Node<E> left;
        Node<E> right;
        Node<E> parent;

        public Node(E element, Node<E> parent) {
            this.element = element;
            this.parent = parent;
        }

        public boolean isLeaf() {
            return left == null && right == null;
        }

        public boolean hasTwoChildren() {
            return left != null && right != null;
        }

        @Override
        public String toString() {
            return element.toString();
        }
    }

    /**
     * 自定义访问结点的操作
     *
     * @param <E>
     */
    public static abstract class Visitor<E> {
        boolean stop;

        // 返回true就代表停止遍历
        abstract boolean visit(E element);
    }

    @Override
    public Object root() {
        return root;
    }

    @Override
    public Object left(Object node) {
        return ((Node<E>) node).left;
    }

    @Override
    public Object right(Object node) {
        return ((Node<E>) node).right;
    }

    @Override
    public Object string(Object node) {
        Node<E> myNode = (Node<E>) node;
        String parentString = null;
        if (myNode.parent != null) {
            parentString = myNode.parent.element.toString();
        }
        return ((Node<E>) node).element + "_p(" + parentString + ")";
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {
        root = null;
        size = 0;
    }

    /**
     * 中序遍历时的前一个节点
     *
     * @return
     */
    protected Node<E> predecessor(Node<E> node) {
        if (node == null) return null;
        // 前驱节点在左子树中
        Node<E> p = node.left;
        if (p != null) {
            while (p.right != null) {
                p = p.right;
            }
            return p;
        }

        // 从父节点、祖父节点中寻找前驱节点
        while (node.parent != null && node == node.parent.left) {
            node = node.parent;
        }
        return node.parent;
    }

    /**
     * 中序遍历时的后一个节点
     *
     * @return
     */
    protected Node<E> successor(Node<E> node) {
        if (node == null) return null;

        // 后驱节点在右子树中
        Node<E> p = node.right;
        if (p != null) {
            while (p.left != null) {
                p = p.left;
            }
            return p;
        }

        // 从父节点、祖父节点中寻找后驱节点
        while (node.parent != null && node == node.parent.right) {
            node = node.parent;
        }
        return node.parent;
    }

    /**
     * 判断是否为完全二叉树
     * -- 重构版（可读性一般）
     *
     * @return
     */
    public boolean isComplete() {
        if (root == null) return false;

        Queue<Node<E>> queue = new LinkedList<>();
        queue.offer(root);
        Node<E> node;
        Boolean leaf = false; // 标志位，第一个叶节点或者只有左节点的节点出现后置为true

        while (!queue.isEmpty()) {
            node = queue.poll();
            // 第一个叶节点或者只有左节点的节点出现后，后面的节点需都为叶节点
            if (leaf && !node.isLeaf()) return false;

            if (node.left != null) {
                queue.offer(node.left);
            } else if (node.right != null) {
                return false;
            }
            if (node.right != null) {
                queue.offer(node.right);
            } else {
                leaf = true;
            }
        }
        return true;
    }

    /**
     * 判断是否为完全二叉树
     *
     * @return
     */
    public boolean isComplete2() {
        if (root == null) return false;

        Queue<Node<E>> queue = new LinkedList<>();
        queue.offer(root);
        Node<E> node;
        Boolean leaf = false; // 标志位，第一个叶节点或者只有左节点的节点出现后置为true

        while (!queue.isEmpty()) {
            node = queue.poll();
            // 第一个叶节点或者只有左节点的节点出现后，后面的节点需都为叶节点
            if (leaf && !node.isLeaf()) return false;

            if (node.hasTwoChildren()) {
                queue.offer(node.left);
                queue.offer(node.right);
            } else if (node.left == null && node.right != null) {
                return false;
            } else {
                leaf = true;
                if (node.left != null) {
                    queue.offer(node.left);
                }
            }
        }
        return true;
    }

    public void invertTree() {
        if (root == null) return;
        invertTree(root);
    }

    /**
     * 翻转二叉树
     *
     * @param root
     */
    public Node<E> invertTree(Node<E> root) {
        if (root.left != null)
            invertTree(root.left);
        if (root.right != null)
            invertTree(root.right);
        Node<E> tmp;
        tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        return root;
    }

    public int height() {
        if (root == null) return 0;

        // 树的高度
        int height = 0;
        // 存储着每一层的元素数量
        int levelSize = 1;
        Queue<Node<E>> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            Node<E> node = queue.poll();
            levelSize--;

            if (node.left != null) {
                queue.offer(node.left);
            }

            if (node.right != null) {
                queue.offer(node.right);
            }

            if (levelSize == 0) { // 意味着即将要访问下一层
                levelSize = queue.size();
                height++;
            }
        }

        return height;
    }

    public int height2() {
        return height(root);
    }

    private int height(Node<E> node) {
        if (node == null) return 0;
        return 1 + Math.max(height(node.left), height(node.right));
    }

    public void preorderTraversal(BST.Visitor<E> visitor) {
        if (visitor == null) return;
        preorderTraversal(root, visitor);
    }

    public void preorderTraversal(Node<E> node, BST.Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
        preorderTraversal(node.left, visitor);
        preorderTraversal(node.right, visitor);
    }

    public void inorderTraversal(BST.Visitor<E> visitor) {
        if (visitor == null) return;
        inorderTraversal(root, visitor);
    }

    private void inorderTraversal(Node<E> node, BST.Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        inorderTraversal(node.left, visitor);
        if (visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
        inorderTraversal(node.right, visitor);
    }

    public void postorderTraversal(BST.Visitor<E> visitor) {
        if (visitor == null) return;
        postorderTraversal(root, visitor);
    }

    private void postorderTraversal(Node<E> node, BST.Visitor<E> visitor) {
        if (node == null || visitor.stop) return;
        postorderTraversal(node.left, visitor);
        postorderTraversal(node.right, visitor);
        if (visitor.stop) return;
        visitor.stop = visitor.visit(node.element);
    }

    public void levelOrderTraversal(BST.Visitor<E> visitor) {
        if (root == null || visitor == null) return;

        Queue<Node<E>> queue = new LinkedList<>();
        queue.offer(root);
        Node<E> node;

        while (!queue.isEmpty()) {
            node = queue.poll();
            if (visitor.visit(node.element)) return;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
    }

}
```
# 07. 二叉搜索树
## 需求分析
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682348569665-acbc993e-3828-4697-b700-3b85c605a1cb.png#averageHue=%23ebdad0&clientId=u97d08d7e-4035-4&from=paste&height=344&id=u2ec8eccd&originHeight=762&originWidth=1333&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=414281&status=done&style=none&taskId=u82338807-0142-4274-a587-d7bcc61cddb&title=&width=601.7764892578125)
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682349012156-548025d3-3efb-43fd-97ca-6eac6e3ecbcc.png#averageHue=%23f4f4f4&clientId=u97d08d7e-4035-4&from=paste&height=427&id=ue78dee6d&originHeight=705&originWidth=1710&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=494544&status=done&style=none&taskId=u6683268b-b7b3-45d1-9bba-388d42eed57&title=&width=1036.3635764634348)
## 接口设计
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1682349302470-aa262f97-c1fc-4cc3-9d22-9dbd3ee41cd7.png#averageHue=%23f9f9f9&clientId=u97d08d7e-4035-4&from=paste&height=372&id=u51a0bf5a&originHeight=614&originWidth=1707&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=434837&status=done&style=none&taskId=uacb6c13d-dea6-48b8-9c0c-973922d2738&title=&width=1034.545394750341)
## 具体实现
### 比较
二叉搜索树的节点是要经过比较存放的<br />**方式一：Comparable**<br />`java.util.Comparable`
```java
public interface Comparable<T> {
    public int compareTo(T o);
}
```
实体类需实现Comparable接口，重写compareTo()方法
```java
public class Person implements Comparable<Person> {
    private int age;
    private String name;

    @Override
    public int compareTo(Person e) {
        return age- e.age;
    }
}
```
规定泛型的上界
```java
public class BinarySearchTree<E extends Comparable> {
	 private int compare(E e1, E e2) {
        return e1.compareTo(e2);
    }
}
```
**方式二：传入比较器，优点是可以定制个性化的比较逻辑，更灵活**<br />创建Comparator接口
```java
public interface Comparator<E> {
    int compare(E e1, E e2);
}
```
BinarySearchTree中引入比较器
```java
public class BinarySearchTree<E> {
    private Comparator<E> comparator;

    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator;
    }

    private int compare(E e1, E e2) {
        return comparator.compare(e1, e2);
    }
}
```
创建二叉搜索树对象时许传入比较器
```java
public static class PersonComparator implements Comparator<Person> {
    @Override
    public int compare(Person e1, Person e2) {
        return e1.getAge() - e2.getAge();
    }
}

public static class PersonComparator2 implements Comparator<Person> {
    @Override
    public int compare(Person e1, Person e2) {
        return e2.getAge() - e1.getAge();
    }
}

public static void testBinarySearchTree() {
    BinarySearchTree<Person> bst = new BinarySearchTree<Person>(new PersonComparator());
 	for (int i = 0; i < 30; i++) {
    	bst.add(new Person((int) (Math.random() * 100), "aa"));
    }
    
    BinarySearchTree<Person> bst2 = new BinarySearchTree<Person>(new PersonComparator2());
    for (int i = 0; i < 30; i++) {
    	bst2.add(new Person((int) (Math.random() * 100), "aa"));
    }
}
```
采用匿名内部类的方式传入比较器
```java
BinarySearchTree<Person> bst3 = new BinarySearchTree<>(new Comparator<Person>() {
    @Override
    public int compare(Person e1, Person e2) {
        return e1.getAge() - e2.getAge();
    }
});
```
**两种方式结合**
```java
public class BinarySearchTree<E> {
	 //允许不传入比较器
    public BinarySearchTree() {
        this(null);
    }

    public BinarySearchTree(Comparator<E> comparator) {
        this.comparator = comparator;
    }

     private int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
//        return e1.compareTo(e2);
        return ((Comparable<E>) e1).compareTo(e2);
    }
}
```
### 添加节点
add操作中需要比较元素
```java
public void add(E element) {
    elementNotNullCheck(element);
    // 添加第一个节点
    if (root == null) {
        root = new Node<E>(element, null);
        size++;
        return;
    }
    Node<E> node = root;
    Node<E> parent = root;
    int cmp = 0; //记录比较结果
    while (node != null) {
        cmp = compare(element, node.element);
        parent = node;
        if (cmp > 0) {
            node = node.right;
        } else if (cmp < 0) {
            node = node.left;
        } else { // 相等
            node.element=element; // 新元素覆盖旧元素
            return;
        }
    }
    node = new Node<>(element, parent);
    if (cmp > 0) {
        parent.right = node;
    } else {
        parent.left = node;
    }
    size++;
}
```
### 前驱结点和后继结点
中序遍历时的前一个节点，如果是二叉搜索树就是前一个比它小的节点<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683164867690-8c9e3472-3239-4979-8380-78256e8ce468.png#averageHue=%23f6f6f6&clientId=uc4e41e88-0d77-4&from=paste&height=345&id=ua21716b5&originHeight=379&originWidth=899&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=157649&status=done&style=none&taskId=udcfc4807-e754-4e18-aca8-dd69b195bb0&title=&width=817.2727095588184)<br />最小的节点（1）是没有前驱节点的
```java
public Node<E> predecessor(Node<E> node) {
    if (node == null) return null;
    // 前驱节点在左子树中
    Node<E> p = node.left;
    if (p != null) {
        while (p.right != null) {
            p = p.right;
        }
        return p;
    }

    // 从父节点、祖父节点中寻找前驱节点
    while (node.parent != null && node == node.parent.left) {
        node = node.parent;
    }
    return node.parent;
}
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683166253322-644a3a48-99df-4edd-89d6-37018225902f.png#averageHue=%23f7f6f6&clientId=uc4e41e88-0d77-4&from=paste&height=365&id=ue6b32b23&originHeight=402&originWidth=887&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=152729&status=done&style=none&taskId=u8306df15-9018-4dee-9c64-f799201dde1&title=&width=806.3636188861756)<br />最大的节点（11）是没有后继结点的
```java
public Node<E> successor(Node<E> node) {
    if (node == null) return null;

    // 后驱节点在右子树中
    Node<E> p = node.right;
    if (p != null) {
        while (p.left != null) {
            p = p.left;
        }
        return p;
    }

    // 从父节点、祖父节点中寻找后驱节点
    while (node.parent != null && node == node.parent.right) {
        node = node.parent;
    }
    return node.parent;
}
```
### 根据节点元素返回节点
```java
private Node<E> node(E element) {
    Node<E> node = root;
    while (node != null) {
        int cmp = compare(element, node.element);
        if (cmp == 0) return node;
        if (cmp > 0) {
            node = node.right;
        } else {
            node = node.left;
        }
    }
    return null;
}
```
### 删除节点（复杂）
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683167674042-d4ab7b4b-3571-497c-bf4b-5e9f597dc5a0.png#averageHue=%23f6f5f5&clientId=uc4e41e88-0d77-4&from=paste&height=334&id=u992373f6&originHeight=367&originWidth=706&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=136586&status=done&style=none&taskId=u7719ad3a-953f-45b0-a0fc-94c632d2d8a&title=&width=641.8181679071477)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683172449187-d50d70bf-50c7-4e16-89f0-cbb980733567.png#averageHue=%23f4f3f3&clientId=uc4e41e88-0d77-4&from=paste&height=362&id=u53a1d36c&originHeight=398&originWidth=821&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=122052&status=done&style=none&taskId=u09ab28bc-2de8-4e9b-9422-f1f1e30671f&title=&width=746.3636201866406)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683186857768-fcefae59-1833-4a88-80ce-3cde45d6dd9d.png#averageHue=%23f8f8f8&clientId=uc4e41e88-0d77-4&from=paste&height=300&id=ucf5d9337&originHeight=330&originWidth=687&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=84091&status=done&style=none&taskId=ufb37ea72-6e26-41f1-9b88-af50be32ecf&title=&width=624.5454410087966)
```java
public void remove(E element) {
    remove(node(element));
}

public void remove(Node<E> node) {
    if (node == null) return;
    size--;

    if (node.hasTwoChildren()) { //度为2的节点
        // 找到后继结点
        Node<E> s = successor(node);
        node.element = s.element;
        // 让node指向后继结点，删除
        node = s;
    }
    // 删除node节点，此时node度为0或1
    Node<E> replacement = node.left != null ? node.left : node.right;
    if (replacement != null) { // 度为1的节点
        replacement.parent = node.parent;
        // 更改parent的left、right指向
        if (node.parent == null) { // 根节点
            root = replacement;
        } else if (node == node.parent.left) {
            node.parent.left = replacement;
        } else { // node == node.parent.right
            node.parent.right = replacement;
        }
    } else if (node.parent == null) { // 叶节点且为根节点
        root = null;
    } else { // 叶节点但不是根节点
        if (node == node.parent.left) {
            node.parent.left = null;
        } else { // node == node.parent.right
            node.parent.right = null;
        }
    }

}
```
## 完整代码
```java
public class BST<E> extends BinaryTree<E> {
    private Comparator<E> comparator;

    //允许不传入比较器
    public BST() {
        this(null);
    }

    public BST(Comparator<E> comparator) {
        this.comparator = comparator;
    }

    public void add(E element) {
        elementNotNullCheck(element);
        // 添加第一个节点
        if (root == null) {
            root = new Node<E>(element, null);
            size++;
            return;
        }
        Node<E> node = root;
        Node<E> parent = root;
        int cmp = 0; //记录比较结果
        while (node != null) {
            cmp = compare(element, node.element);
            parent = node;
            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else { // 相等
                node.element = element; // 新元素覆盖旧元素
                return;
            }
        }
        node = new Node<>(element, parent);
        if (cmp > 0) {
            parent.right = node;
        } else {
            parent.left = node;
        }
        size++;
    }

    public void remove(E element) {
        remove(node(element));
    }

    public void remove(Node<E> node) {
        if (node == null) return;
        size--;

        if (node.hasTwoChildren()) { //度为2的节点
            // 找到后继结点
            Node<E> s = successor(node);
            node.element = s.element;
            // 让node指向后继结点，删除
            node = s;
        }
        // 删除node节点，此时node度为0或1
        Node<E> replacement = node.left != null ? node.left : node.right;
        if (replacement != null) { // 度为1的节点
            replacement.parent = node.parent;
            // 更改parent的left、right指向
            if (node.parent == null) { // 根节点
                root = replacement;
            } else if (node == node.parent.left) {
                node.parent.left = replacement;
            } else { // node == node.parent.right
                node.parent.right = replacement;
            }
        } else if (node.parent == null) { // 叶节点且为根节点
            root = null;
        } else { // 叶节点但不是根节点
            if (node == node.parent.left) {
                node.parent.left = null;
            } else { // node == node.parent.right
                node.parent.right = null;
            }
        }

    }

    /**
     * 根据节点元素返回节点
     *
     * @param element
     * @return
     */
    private Node<E> node(E element) {
        Node<E> node = root;
        while (node != null) {
            int cmp = compare(element, node.element);
            if (cmp == 0) return node;
            if (cmp > 0) {
                node = node.right;
            } else {
                node = node.left;
            }
        }
        return null;
    }

    public boolean contains(E element) {
        return node(element) != null;
    }

    private int compare(E e1, E e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
//        return e1.compareTo(e2);
        return ((Comparable<E>) e1).compareTo(e2);
    }

    private void elementNotNullCheck(E element) {
        if (element == null) {
            throw new IllegalArgumentException("element must not be null");
        }
    }

}
```
## 练习
### 104. 二叉树的最大深度
> 也即二叉树的最大高度

递归
```java
// 递归
public int height2(Node<E> node) {
    if (node == null) return 0;
    return 1 + Math.max(height2(node.left), height2(node.right));
}
```
迭代
```java
// 迭代————层序遍历
public int height1() {
    if (root == null) return 0;

    int height = 0;
    int levelSize = 1; //存储每一层元素数量
    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        Node<E> node = queue.poll();
        levelSize--;
        if (node.left != null) {
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
        if (levelSize == 0) { //要访问下一层了
            levelSize = queue.size();
            height++;
        }
    }
    return height;
}
```
leetcode
```java
public class Solution104 {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
    }
}
```
### 完全二叉树的判断
思路<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683019320819-04bbedb9-ff5c-4542-8463-2e3dbef41500.png#averageHue=%23f8f8f8&clientId=u896a2647-f6e5-4&from=paste&height=510&id=u064adb75&originHeight=842&originWidth=1595&originalType=binary&ratio=1.875&rotation=0&showTitle=false&size=408601&status=done&style=none&taskId=u19bac505-4997-4e37-835f-b8a4a46c921&title=&width=966.6666107948413)
```java
public boolean isComplete2() {
    if (root == null) return false;

    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
    Node<E> node;
    Boolean leaf = false; // 标志位，第一个叶节点或者只有左节点的节点出现后置为true

    while (!queue.isEmpty()) {
        node = queue.poll();
        // 第一个叶节点或者只有左节点的节点出现后，后面的节点需都为叶节点
        if (leaf && !node.isLeaf()) return false;

        if (node.hasTwoChildren()) {
            queue.offer(node.left);
            queue.offer(node.right);
        } else if (node.left == null && node.right != null) {
            return false;
        } else {
            leaf = true;
            if (node.left != null) {
                queue.offer(node.left);
            }
        }
    }
    return true;
}
```
重构版
```java
public boolean isComplete() {
    if (root == null) return false;

    Queue<Node<E>> queue = new LinkedList<>();
    queue.offer(root);
    Node<E> node;
    Boolean leaf = false; // 标志位，第一个叶节点或者只有左节点的节点出现后置为true

    while (!queue.isEmpty()) {
        node = queue.poll();
        // 第一个叶节点或者只有左节点的节点出现后，后面的节点需都为叶节点
        if (leaf && !node.isLeaf()) return false;

        if (node.left != null) {
            queue.offer(node.left);
        } else if (node.right != null) {
            return false;
        }
        if (node.right != null) {
            queue.offer(node.right);
        } else {
            leaf = true;
        }
    }
    return true;
}
```
### **226. 翻转二叉树**
递归
```java
public class Solution226 {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;

        invertTree(root.left);
        invertTree(root.right);

        TreeNode tmp = root.left;
        root.left = root.right;
        root.right = tmp;
        
        return root;
    }
}
```
迭代
```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);

    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        TreeNode tmp = node.left;
        node.left = node.right;
        node.right = tmp;

        if (node.left != null) {
            queue.offer(node.left);
        }
        if (node.right != null) {
            queue.offer(node.right);
        }
    }
    
    return root;
}
```
# 08. 平衡二叉搜索树——AVL树
## 介绍
二叉搜索树的复杂度分析<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683198058701-d4d66374-f54e-4f88-b8c4-52b3d496a507.png#averageHue=%23f8f8f8&clientId=uc4e41e88-0d77-4&from=paste&height=358&id=u0cdc7f0c&originHeight=394&originWidth=839&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=117597&status=done&style=none&taskId=u2ebc3110-5c10-48b0-862a-5c294a84dc8&title=&width=762.7272561956047)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683198090418-a5c78b53-31ad-42a4-849d-ea3c98131562.png#averageHue=%23f8f8f8&clientId=uc4e41e88-0d77-4&from=paste&height=323&id=u1c34659d&originHeight=355&originWidth=836&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=71442&status=done&style=none&taskId=u210db80f-39c1-4cbf-9f5a-5d13f085195&title=&width=759.999983527444)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683198525392-0f25f783-0d21-414d-bdb8-813d8c86734a.png#averageHue=%23f3f3f3&clientId=uc4e41e88-0d77-4&from=paste&height=394&id=ue253d1f0&originHeight=433&originWidth=828&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=114148&status=done&style=none&taskId=u82f4a63d-f8ed-4fa5-ad44-3d73264f013&title=&width=752.7272564123489)
## 调整平衡——旋转
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683214727546-c88192a4-d0bd-4ab6-8b3a-bd2a9d1d462c.png#averageHue=%23f9f7f7&clientId=u428b60ea-d754-4&from=paste&height=593&id=u5c17ed52&originHeight=979&originWidth=1833&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=581557&status=done&style=none&taskId=uadcd35a7-2dae-4699-8a86-4d193263aa7&title=&width=1110.9090267002784)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683215236734-30a54547-a786-4237-a31a-8c11cc381f76.png#averageHue=%23f0e7e4&clientId=u428b60ea-d754-4&from=paste&height=586&id=u5d936252&originHeight=967&originWidth=1789&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=551425&status=done&style=none&taskId=ue8be4432-2933-4230-aa13-18728348aaa&title=&width=1084.2423615749035)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683215396482-b32d2197-a230-4e86-88fa-27bc8075d0ea.png#averageHue=%23f7f4f3&clientId=u428b60ea-d754-4&from=paste&height=489&id=uaebd21a9&originHeight=807&originWidth=1799&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=369629&status=done&style=none&taskId=u4f80e390-03df-4355-bc20-6a976453496&title=&width=1090.302967285216)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683215692925-7883d578-6c2f-4261-b699-de9d792929dd.png#averageHue=%23f9eeeb&clientId=u428b60ea-d754-4&from=paste&height=587&id=uc83d0145&originHeight=968&originWidth=1795&originalType=binary&ratio=1.6500000953674316&rotation=0&showTitle=false&size=470122&status=done&style=none&taskId=u0049e76c-c0f0-4a68-80e2-8221888f633&title=&width=1087.878725001091)
## 添加导致的失衡
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683252392371-fd728645-7a47-4829-a103-44dcbfd2a540.png#averageHue=%23f4f3f2&clientId=ubc064e04-7ad6-4&from=paste&height=405&id=u27ea6631&originHeight=446&originWidth=566&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=92448&status=done&style=none&taskId=u0058fb43-c0fa-4ec6-9150-1a62c7ce6c9&title=&width=514.5454433929824)
## 删除导致的失衡
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683264828876-3f7c2d20-bfb4-4665-99fe-bd32b7f6d367.png#averageHue=%23f6f5f5&clientId=ubc064e04-7ad6-4&from=paste&height=343&id=uf3304194&originHeight=377&originWidth=823&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=109372&status=done&style=none&taskId=u8483fbcf-896b-4ef2-ba48-cf73251a3dd&title=&width=748.1818019654144)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683253881793-2d5b5d4a-3d41-495b-96fd-e9e274424d2a.png#averageHue=%23f7f6f6&clientId=ubc064e04-7ad6-4&from=paste&height=431&id=u855d347d&originHeight=474&originWidth=848&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=148846&status=done&style=none&taskId=u0bb267f4-91a1-4a60-b06b-7dfd3504aa9&title=&width=770.9090742000867)
## 统一所有旋转操作
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683250390372-999e935f-9818-451d-94a9-37b9dbb48f07.png#averageHue=%23f6f4f4&clientId=ubc064e04-7ad6-4&from=paste&height=426&id=nttcb&originHeight=469&originWidth=887&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=179869&status=done&style=none&taskId=u3930ac09-96d9-48bc-94d9-9d39cc8715d&title=&width=806.3636188861756)
## 总结
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683264907765-112c3985-51c4-4af2-817c-549a1ffac897.png#averageHue=%23efefef&clientId=ubc064e04-7ad6-4&from=paste&height=475&id=ub337c527&originHeight=522&originWidth=890&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=182955&status=done&style=none&taskId=u99269d0f-c161-4c02-bdd3-b266c5d0321&title=&width=809.0908915543363)
## 完整代码
核心：`afterAdd()`、`afterRemove()`<br />直接继承BST树，关键在于每次添加和删除节点后对于平衡的调整
```java
public class AVLTree<E> extends BST<E> {
    public AVLTree() {
        this(null);
    }

    public AVLTree(Comparator<E> comparator) {
        super(comparator);
    }

    private class AVLNode<E> extends Node<E> {
        // 新增属性
        int height = 1;

        public AVLNode(E element, Node<E> parent) {
            super(element, parent);
        }

        // 平衡因子
        public int balanceFactor() {
            int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
            return leftHeight - rightHeight;
        }

        public void updateHeight() {
            int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
            height = 1 + Math.max(leftHeight, rightHeight);
        }

        public Node<E> tallerChild() {
            int leftHeight = left == null ? 0 : ((AVLNode<E>) left).height;
            int rightHeight = right == null ? 0 : ((AVLNode<E>) right).height;
            if (leftHeight > rightHeight) return left;
            if (leftHeight < rightHeight) return right;
            // 返回和自己同方向的，自己是左，就返回左子。同理
            return isLeftChild() ? left : right;
        }

        @Override
        public String toString() {
            String parentString = "null";
            if (parent != null) {
                parentString = parent.element.toString();
            }
            return element + "_p(" + parentString + ")_h(" + height + ")";
        }
    }

    private boolean isBalanced(Node<E> node) {
        return Math.abs(((AVLNode<E>) node).balanceFactor()) <= 1;
    }

    private void updateHeight(Node<E> node) {
        ((AVLNode<E>) node).updateHeight();
    }

    @Override
    protected Node<E> createNode(E element, Node<E> parent) {
        return new AVLNode<>(element, parent);
    }

    @Override
    protected void afterAdd(Node<E> node) {
        while ((node = node.parent) != null) {
            if (isBalanced(node)) {
                // 更新高度
                updateHeight(node);
            } else {
                // 恢复平衡
                rebalance(node);
                break;
            }
        }
    }

    @Override
    protected void afterRemove(Node<E> node) {
        while ((node = node.parent) != null) {
            if (isBalanced(node)) {
                // 更新高度
                updateHeight(node);
            } else {
                // 恢复平衡
                rebalance(node);
                // 不能break，因为更高层的祖先节点可能还会失衡
            }
        }
    }

    /**
     * 恢复平衡
     * -- 统一旋转操作
     * @param grand 高度最低的那个不平衡节点
     */
    private void rebalance(Node<E> grand) {
        Node<E> parent = ((AVLNode<E>) grand).tallerChild();
        Node<E> node = ((AVLNode<E>) parent).tallerChild();
        if (parent.isLeftChild()) { // L
            if (node.isLeftChild()) { // LL
                rotate(grand, node, node.right, parent, parent.right, grand);
            } else { // LR
                rotate(grand, parent, node.left, node, node.right, grand);
            }
        } else { // R
            if (node.isLeftChild()) { // RL
                rotate(grand, grand, node.left, node, node.right, parent);
            } else { // RR
                rotate(grand, grand, parent.left, parent, node.left, node);
            }
        }
    }

    private void rotate(
            Node<E> r, // 子树的根节点
            Node<E> b, Node<E> c,
            Node<E> d,
            Node<E> e, Node<E> f) {
        // 让d成为这棵子树的根节点
        d.parent = r.parent;
        if (r.isLeftChild()) {
            r.parent.left = d;
        } else if (r.isRightChild()) {
            r.parent.right = d;
        } else {
            root = d;
        }

        //b-c
        b.right = c;
        if (c != null) {
            c.parent = b;
        }
        updateHeight(b);

        // e-f
        f.left = e;
        if (e != null) {
            e.parent = f;
        }
        updateHeight(f);

        // b-d-f
        d.left = b;
        d.right = f;
        b.parent = d;
        f.parent = d;
        updateHeight(d);
    }

//    /**
//     * 恢复平衡
//     *
//     * @param grand 高度最低的那个不平衡节点
//     */
//    private void rebalance2(Node<E> grand) {
//        Node<E> parent = ((AVLNode<E>) grand).tallerChild();
//        Node<E> node = ((AVLNode<E>) parent).tallerChild();
//        if (parent.isLeftChild()) {
//            if (node.isLeftChild()) { //LL
//                rotateRight(parent);
//            } else { //LR
//                rotateLeft(parent);
//                rotateRight(parent);
//            }
//        } else {
//            if (node.isLeftChild()) { //RL
//                rotateRight(parent);
//                rotateLeft(parent);
//            } else { //RR
//                rotateLeft(parent);
//            }
//        }
//    }
//
//    // 左旋转
//    private void rotateLeft(Node<E> grand) {
//        Node<E> parent = grand.right;
//        Node<E> child = parent.left;
//        grand.right = child;
//        parent.left = grand;
//        afterRotate(grand, parent, child);
//    }
//
//    // 右旋转
//    private void rotateRight(Node<E> grand) {
//        Node<E> parent = grand.left;
//        Node<E> child = parent.right;
//        grand.left = child;
//        parent.right = grand;
//        afterRotate(grand, parent, child);
//    }
//
//    private void afterRotate(Node<E> grand, Node<E> parent, Node<E> child) {
//        // 让parent称为子树的根节点
//        parent.parent = grand.parent;
//        if (grand.isLeftChild()) {
//            grand.parent.left = parent;
//        } else if (grand.isRightChild()) {
//            grand.parent.right = parent;
//        } else { // grand是root节点
//            root = parent;
//        }
//
//        // 更新child的parent
//        if (child != null) {
//            child.parent = grand;
//        }
//
//        // 更新grand的parent
//        grand.parent = parent;
//
//        // 更新高度
//        updateHeight(grand);
//        updateHeight(parent);
//    }

}
```
## 和BST速度对比
```java
static void test2() {
    List<Integer> data = new ArrayList<>();
    for (int i = 0; i < 100_0000; i++) {
        data.add((int)(Math.random() * 100_0000));
    }
    
    BST<Integer> bst = new BST<>();
    for (int i = 0; i < data.size(); i++) {
        bst.add(data.get(i));
    }
    for (int i = 0; i < data.size(); i++) {
        bst.contains(data.get(i));
    }
    for (int i = 0; i < data.size(); i++) {
        bst.remove(data.get(i));
    }
    
    AVLTree<Integer> avl = new AVLTree<>();
    for (int i = 0; i < data.size(); i++) {
        avl.add(data.get(i));
    }
    for (int i = 0; i < data.size(); i++) {
        avl.contains(data.get(i));
    }
    for (int i = 0; i < data.size(); i++) {
        avl.remove(data.get(i));
    }
}
```
# 09. B树
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683266727328-a4c91ad7-d650-49e8-9f96-30c376e1db83.png#averageHue=%23f6f6f6&clientId=ubc064e04-7ad6-4&from=paste&height=429&id=ucb019338&originHeight=472&originWidth=891&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=189925&status=done&style=none&taskId=uf3469a21-458d-4f28-b7bc-855cdb0ef31&title=&width=809.9999824437232)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683267799188-199e2db6-71ed-4ae6-9b32-c7285929d000.png#averageHue=%23f3f1f1&clientId=ubc064e04-7ad6-4&from=paste&height=425&id=u60807075&originHeight=467&originWidth=890&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=216848&status=done&style=none&taskId=uf7f6d177-4734-4a98-81f7-bb055014942&title=&width=809.0908915543363)
## 添加
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683269428676-c935b588-666b-4acd-b384-c38385029f49.png#averageHue=%23f2f0f0&clientId=ubc064e04-7ad6-4&from=paste&height=450&id=u8686b7e9&originHeight=495&originWidth=893&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=171105&status=done&style=none&taskId=u1e5865d6-1790-4eea-aad2-685748bceca&title=&width=811.818164222497)
## 删除
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683269977672-0b2d6a7c-b47f-46c4-9e3c-9b44b4b2f58c.png#averageHue=%23f3f3f3&clientId=ubc064e04-7ad6-4&from=paste&height=587&id=ubae3815e&originHeight=646&originWidth=1265&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=310884&status=done&style=none&taskId=uaf6471f2-8944-414d-b358-88f72bfa249&title=&width=1149.9999750744219)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683283603342-734d87cd-f20f-40ea-ad7e-28cb3614b9ee.png#averageHue=%23f2ebeb&clientId=ubc064e04-7ad6-4&from=paste&height=426&id=u6c1e90ab&originHeight=469&originWidth=893&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=197693&status=done&style=none&taskId=u2cf78adf-746d-4f8b-a6e7-c9b635edafc&title=&width=811.818164222497)
## 4阶B树
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683283943714-7d6b6d0d-e528-4fbc-88c5-fbcae29cecd2.png#averageHue=%23f6f6f6&clientId=ubc064e04-7ad6-4&from=paste&height=355&id=ud83c0dc1&originHeight=391&originWidth=688&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=115016&status=done&style=none&taskId=u5cf85d2e-b711-42a2-8772-26afee6b059&title=&width=625.4545318981835)
# 10. 红黑树
## 介绍
红黑树也是二叉搜索树，可以直接继承我们之前实现的BST<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683285473617-8b9ee346-57ba-4009-aebe-b6003f8570c8.png#averageHue=%23e1dbda&clientId=ubc064e04-7ad6-4&from=paste&height=384&id=ubb9e4284&originHeight=422&originWidth=897&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=243802&status=done&style=none&taskId=u1598a7dd-7824-4150-a1a9-35aa382cc79&title=&width=815.4545277800446)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683285638843-14873451-1a12-49d2-a57e-636a0f9c7846.png#averageHue=%23eae5e5&clientId=ubc064e04-7ad6-4&from=paste&height=298&id=u0f494ee4&originHeight=328&originWidth=897&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=152868&status=done&style=none&taskId=u3f6ebc4b-2b13-4abf-92a0-15d39931288&title=&width=815.4545277800446)
## 红黑树的等价变换
本身是黑色节点才能独立形成一个b树节点<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683285834468-788af214-1e39-4651-acbb-b9d1f02a5513.png#averageHue=%23ede4e4&clientId=ubc064e04-7ad6-4&from=paste&height=397&id=ucb486131&originHeight=437&originWidth=893&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=200513&status=done&style=none&taskId=u1f0aa02e-9b32-4bba-9293-f1de8f82128&title=&width=811.818164222497)
## 添加
### 添加规则
新增节点为红色（根节点为黑）<br />空节点默认为黑色<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683290121600-cf641b74-87b6-46f6-99bc-a1e3610585bb.png#averageHue=%23f1ecec&clientId=ubc064e04-7ad6-4&from=paste&height=264&id=u9763e3df&originHeight=290&originWidth=646&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=80780&status=done&style=none&taskId=u7b4a6003-2245-4b4c-bfaf-f5e9deb2703&title=&width=587.272714543934)
### 添加的所有情况
四种情况parent为黑色，直接满足<br />8中情况parent为红色，出现双红，需要修复性质4<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683335240225-64a826dd-a06e-4a91-bfd9-426b4031e72a.png#averageHue=%23f1e9e9&clientId=ubc064e04-7ad6-4&from=paste&height=429&id=u8414d4e8&originHeight=472&originWidth=877&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=191431&status=done&style=none&taskId=u914a1706-0a15-4196-9734-f0398e734dd&title=&width=797.2727099923067)
### 修复性质4
> 染色+旋转

**1、uncle（叔父节点）不是红色的情况**<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683334305456-82463fbc-e625-4da4-9fcb-6da1d66c4b72.png#averageHue=%23f2ecec&clientId=ubc064e04-7ad6-4&from=paste&height=425&id=u84462995&originHeight=467&originWidth=891&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=174574&status=done&style=none&taskId=ueb211520-b659-4992-b1d9-3380da3986e&title=&width=809.9999824437232)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683334858861-76870b95-3ee3-4e5d-b293-d6c723a5be3b.png#averageHue=%23f2eaea&clientId=ubc064e04-7ad6-4&from=paste&height=434&id=u9a494830&originHeight=477&originWidth=900&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=191702&status=done&style=none&taskId=u0c88d15b-f9e5-4983-8f26-f98088afb5b&title=&width=818.1818004482052)<br />**2、叔父节点是红色的情况**<br />234树中一个节点最多有三个元素，所以会出现上溢<br />uncle是红色说明不为null，图中17\25\33这三个元素已满<br />把parent和uncle染黑作为独立的两个b树节点<br />上溢只要染色即可，下面四种情况做法都是一样的<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683337523411-f16c965b-3d8b-48ff-bd58-b99632882c85.png#averageHue=%23f0eaea&clientId=ubc064e04-7ad6-4&from=paste&height=430&id=u82273d0a&originHeight=473&originWidth=897&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=209593&status=done&style=none&taskId=ufe965448-95b1-4531-8502-55fff66a907&title=&width=815.4545277800446)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683338065820-665f3f4f-cadc-4ddc-9c39-1a8676884308.png#averageHue=%23f1ebeb&clientId=ubc064e04-7ad6-4&from=paste&height=428&id=u0641772d&originHeight=471&originWidth=897&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=187540&status=done&style=none&taskId=u623c61c6-3d83-44b4-8fb1-b67a074810d&title=&width=815.4545277800446)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683338204734-c9fb0d5c-af6d-4068-9be0-ee955128a166.png#averageHue=%23f1ebeb&clientId=ubc064e04-7ad6-4&from=paste&height=426&id=uc6404793&originHeight=469&originWidth=893&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=181740&status=done&style=none&taskId=u5db8ee7c-4582-4bac-9a72-3c2cad223f2&title=&width=811.818164222497)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683338714312-4dd54e07-e996-4617-a5ff-bc58f94628bb.png#averageHue=%23f1ebeb&clientId=ubc064e04-7ad6-4&from=paste&height=321&id=u52fa6a15&originHeight=353&originWidth=677&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=126035&status=done&style=none&taskId=u0f453483-6214-49f3-852f-9ad36798293&title=&width=615.4545321149277)
## 删除
红色节点可直接删除<br />删除黑色节点有三种情况，需要仔细分析的是后两种情况：

- 拥有一个RED节点的BLACK节点（46、76）
- BLACK叶子节点（88）

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683356738637-4ebbd32f-9aef-4678-aa0a-a78da12537d7.png#averageHue=%23f1e6e6&clientId=ubc064e04-7ad6-4&from=paste&height=269&id=u3bdba92a&originHeight=296&originWidth=897&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=114182&status=done&style=none&taskId=u9e6fb1a8-60bb-4592-816a-31eeee1b8b3&title=&width=815.4545277800446)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683357258296-2f0c248c-7614-455c-b67a-9087a689a96a.png#averageHue=%23f1eded&clientId=ubc064e04-7ad6-4&from=paste&height=350&id=u740a907c&originHeight=385&originWidth=762&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=93245&status=done&style=none&taskId=u74bd16ca-d234-41c6-bab0-d159fde4368&title=&width=692.7272577128138)<br />删除黑色叶节点主要有两种情况（前提：兄弟节点为黑色）<br />1、兄弟节点有至少一个红色子节点<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683359342485-09aaaee4-a1b3-4090-a4b9-89d530c91734.png#averageHue=%23e8e1e1&clientId=ubc064e04-7ad6-4&from=paste&height=327&id=u8f4ced0c&originHeight=360&originWidth=672&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=134811&status=done&style=none&taskId=ue0cd85fa-730f-429a-b9db-f112f2044a6&title=&width=610.9090776679933)<br />2、兄弟节点没有红色子节点

# 11. 集合 Set
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683430598276-6b24ac73-b293-46d1-ae63-526e7ffc2641.png#averageHue=%23f8f8f7&clientId=ubc064e04-7ad6-4&from=paste&height=416&id=u9cd2d934&originHeight=458&originWidth=821&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=154134&status=done&style=none&taskId=ua3166b9c-e16e-4c88-b764-5e5ab4bdd40&title=&width=746.3636201866406)<br />集合中添加元素时相同的元素采取覆盖
## ListSet
用链表实现的集合<br />重点：`add(), remove()`
```java
package com.boer.limingjie_suanfa._11_集合;

import com.boer.limingjie_suanfa._11_集合.list.LinkedList;
import com.boer.limingjie_suanfa._11_集合.list.List;

public class ListSet<E> implements Set<E> {

    private List<E> list = new LinkedList<>();

    @Override
    public int size() {
        return list.size();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void clear() {
        list.clear();
    }

    @Override
    public boolean contains(E element) {
        return list.contains(element);
    }

    @Override
    public void add(E element) {
//        if (list.contains(element)) return;
//        list.add(element);
        int index = list.indexOf(element);
        if (index != List.ELEMENT_NOT_FOUND) { // 存在就覆盖
            list.set(index, element);
        } else { // 不存在添加
            list.add(element);
        }
    }

    @Override
    public void remove(E element) {
        int index = list.indexOf(element);
        if (index != list.ELEMENT_NOT_FOUND) {
            list.remove(index);
        }
    }

    // 遍历
    @Override
    public void traversal(Visitor<E> visitor) {
        if (visitor == null) return;

        int size = list.size();
        for (int i = 0; i < size; i++) {
            if (visitor.visit(list.get(i))) return;
        }
    }

}
```
## TreeSet
红黑树实现的集合<br />重点：`traversal()`
```java
public class TreeSet<E> implements Set<E> {

    // 红黑树
    private RBTree<E> tree;

    public TreeSet() {
        this(null);
    }

    public TreeSet(Comparator<E> comparator) {
        tree = new RBTree<>(comparator);
    }

    @Override
    public int size() {
        return tree.size();
    }

    @Override
    public boolean isEmpty() {
        return tree.isEmpty();
    }

    @Override
    public void clear() {
        tree.clear();
    }

    @Override
    public boolean contains(E element) {
        return tree.contains(element);
    }

    @Override
    public void add(E element) {
        // 二叉搜索树默认是去重的，且相同元素策略是覆盖
        tree.add(element);
    }

    @Override
    public void remove(E element) {
        tree.remove(element);
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        // 注意这new的是 BinaryTree.Visitor，不是Set中的，因为inorder()中接收的是BinaryTree.Visitor
        // 中序遍历的结果：从小到大
        tree.inorder(new BinaryTree.Visitor<E>() {
            @Override
            public boolean visit(E element) {
                // 可以在 BinaryTree.Visitor的visit()方法中调用参数visitor的visit()方法
                return visitor.visit(element);
            }
        });
    }

}

```
## 性能对比
TreeSet吊打ListSet
# 12. 映射
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683437460755-8c1cd74c-b202-4292-90b9-d66bb41160df.png#averageHue=%23f8f6f6&clientId=ubc064e04-7ad6-4&from=paste&height=333&id=uc34be770&originHeight=366&originWidth=790&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=86401&status=done&style=none&taskId=uac6d4147-a32c-4220-abb9-c73cb286d21&title=&width=718.1818026156468)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683437680815-04165230-b3bb-4dc3-8ea1-f556ccc0a981.png#averageHue=%23f8f8f8&clientId=ubc064e04-7ad6-4&from=paste&height=389&id=u7245cf8c&originHeight=428&originWidth=765&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=142803&status=done&style=none&taskId=u1a85b27b-3bcf-4a56-9cf5-1daf8f74ac7&title=&width=695.4545303809745)
## Map
```java
public interface Map<K, V> {

    int size();

    boolean isEmpty();

    void clear();

    V put(K key, V value);

    V get(K key);

    V remove(K key);

    boolean containsKey(K key);

    boolean containsValue(V value);

    void traversal(Visitor<K, V> visitor);

    public static abstract class Visitor<K, V> {
        boolean stop;

        public abstract boolean visit(K key, V value);
    }

}
```
## TreeMap
直接改造红黑树RBTree<br />每个节点Node中包含键值对KV，每次添加节点时我们比较的是key
```java
@SuppressWarnings({"unchecked", "unused"})
public class TreeMap<K, V> implements Map<K, V> {
    private static final boolean RED = false;
    private static final boolean BLACK = true;
    private int size;
    private Node<K, V> root;
    private Comparator<K> comparator;

    public TreeMap() {
        this(null);
    }

    public TreeMap(Comparator<K> comparator) {
        this.comparator = comparator;
    }

    public int size() {
        return size;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public void clear() {
        root = null;
        size = 0;
    }

    @Override
    public V put(K key, V value) {
        keyNotNullCheck(key);

        // 添加第一个节点
        if (root == null) {
            root = new Node<>(key, value, null);
            size++;

            // 新添加节点之后的处理
            afterPut(root);
            return null;
        }

        // 添加的不是第一个节点
        // 找到父节点
        Node<K, V> parent = root;
        Node<K, V> node = root;
        int cmp = 0;
        do {
            cmp = compare(key, node.key);
            parent = node;
            if (cmp > 0) {
                node = node.right;
            } else if (cmp < 0) {
                node = node.left;
            } else { // 相等
                node.key = key;
                V oldValue = node.value;
                node.value = value;
                return oldValue;
            }
        } while (node != null);

        // 看看插入到父节点的哪个位置
        Node<K, V> newNode = new Node<>(key, value, parent);
        if (cmp > 0) {
            parent.right = newNode;
        } else {
            parent.left = newNode;
        }
        size++;

        // 新添加节点之后的处理
        afterPut(newNode);
        return null;
    }

    @Override
    public V get(K key) {
        Node<K, V> node = node(key);
        return node != null ? node.value : null;
    }

    @Override
    public V remove(K key) {
        return remove(node(key));
    }

    @Override
    public boolean containsKey(K key) {
        return node(key) != null;
    }

    @Override
    public boolean containsValue(V value) {
        if (root == null) return false;

        Queue<Node<K, V>> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            Node<K, V> node = queue.poll();
            if (valEquals(value, node.value)) return true;

            if (node.left != null) {
                queue.offer(node.left);
            }

            if (node.right != null) {
                queue.offer(node.right);
            }
        }

        return false;
    }

    @Override
    public void traversal(Visitor<K, V> visitor) {
        if (visitor == null) return;
        traversal(root, visitor);
    }

    // 中序遍历
    private void traversal(Node<K, V> node, Visitor<K, V> visitor) {
        if (node == null || visitor.stop) return;

        traversal(node.left, visitor);
        if (visitor.stop) return;
        visitor.visit(node.key, node.value);
        traversal(node.right, visitor);
    }

    private boolean valEquals(V v1, V v2) {
        // v1和v2都不为null才比较，都为null返回true
        return v1 == null ? v2 == null : v1.equals(v2);
    }

    private V remove(Node<K, V> node) {
        if (node == null) return null;

        size--;

        V oldValue = node.value;

        if (node.hasTwoChildren()) { // 度为2的节点
            // 找到后继节点
            Node<K, V> s = successor(node);
            // 用后继节点的值覆盖度为2的节点的值
            node.key = s.key;
            node.value = s.value;
            // 删除后继节点
            node = s;
        }

        // 删除node节点（node的度必然是1或者0）
        Node<K, V> replacement = node.left != null ? node.left : node.right;

        if (replacement != null) { // node是度为1的节点
            // 更改parent
            replacement.parent = node.parent;
            // 更改parent的left、right的指向
            if (node.parent == null) { // node是度为1的节点并且是根节点
                root = replacement;
            } else if (node == node.parent.left) {
                node.parent.left = replacement;
            } else { // node == node.parent.right
                node.parent.right = replacement;
            }

            // 删除节点之后的处理
            afterRemove(replacement);
        } else if (node.parent == null) { // node是叶子节点并且是根节点
            root = null;
        } else { // node是叶子节点，但不是根节点
            if (node == node.parent.left) {
                node.parent.left = null;
            } else { // node == node.parent.right
                node.parent.right = null;
            }

            // 删除节点之后的处理
            afterRemove(node);
        }

        return oldValue;
    }

    private void afterRemove(Node<K, V> node) {
        // 如果删除的节点是红色
        // 或者 用以取代删除节点的子节点是红色
        if (isRed(node)) {
            black(node);
            return;
        }

        Node<K, V> parent = node.parent;
        if (parent == null) return;

        // 删除的是黑色叶子节点【下溢】
        // 判断被删除的node是左还是右
        boolean left = parent.left == null || node.isLeftChild();
        Node<K, V> sibling = left ? parent.right : parent.left;
        if (left) { // 被删除的节点在左边，兄弟节点在右边
            if (isRed(sibling)) { // 兄弟节点是红色
                black(sibling);
                red(parent);
                rotateLeft(parent);
                // 更换兄弟
                sibling = parent.right;
            }

            // 兄弟节点必然是黑色
            if (isBlack(sibling.left) && isBlack(sibling.right)) {
                // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并
                boolean parentBlack = isBlack(parent);
                black(parent);
                red(sibling);
                if (parentBlack) {
                    afterRemove(parent);
                }
            } else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素
                // 兄弟节点的左边是黑色，兄弟要先旋转
                if (isBlack(sibling.right)) {
                    rotateRight(sibling);
                    sibling = parent.right;
                }

                color(sibling, colorOf(parent));
                black(sibling.right);
                black(parent);
                rotateLeft(parent);
            }
        } else { // 被删除的节点在右边，兄弟节点在左边
            if (isRed(sibling)) { // 兄弟节点是红色
                black(sibling);
                red(parent);
                rotateRight(parent);
                // 更换兄弟
                sibling = parent.left;
            }

            // 兄弟节点必然是黑色
            if (isBlack(sibling.left) && isBlack(sibling.right)) {
                // 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并
                boolean parentBlack = isBlack(parent);
                black(parent);
                red(sibling);
                if (parentBlack) {
                    afterRemove(parent);
                }
            } else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素
                // 兄弟节点的左边是黑色，兄弟要先旋转
                if (isBlack(sibling.left)) {
                    rotateLeft(sibling);
                    sibling = parent.left;
                }

                color(sibling, colorOf(parent));
                black(sibling.left);
                black(parent);
                rotateRight(parent);
            }
        }
    }

    private Node<K, V> predecessor(Node<K, V> node) {
        if (node == null) return null;

        // 前驱节点在左子树当中（left.right.right.right....）
        Node<K, V> p = node.left;
        if (p != null) {
            while (p.right != null) {
                p = p.right;
            }
            return p;
        }

        // 从父节点、祖父节点中寻找前驱节点
        while (node.parent != null && node == node.parent.left) {
            node = node.parent;
        }

        // node.parent == null
        // node == node.parent.right
        return node.parent;
    }

    private Node<K, V> successor(Node<K, V> node) {
        if (node == null) return null;

        // 前驱节点在左子树当中（right.left.left.left....）
        Node<K, V> p = node.right;
        if (p != null) {
            while (p.left != null) {
                p = p.left;
            }
            return p;
        }

        // 从父节点、祖父节点中寻找前驱节点
        while (node.parent != null && node == node.parent.right) {
            node = node.parent;
        }

        return node.parent;
    }

    private Node<K, V> node(K key) {
        Node<K, V> node = root;
        while (node != null) {
            int cmp = compare(key, node.key);
            if (cmp == 0) return node;
            if (cmp > 0) {
                node = node.right;
            } else { // cmp < 0
                node = node.left;
            }
        }
        return null;
    }

    private void afterPut(Node<K, V> node) {
        Node<K, V> parent = node.parent;

        // 添加的是根节点 或者 上溢到达了根节点
        if (parent == null) {
            black(node);
            return;
        }

        // 如果父节点是黑色，直接返回
        if (isBlack(parent)) return;

        // 叔父节点
        Node<K, V> uncle = parent.sibling();
        // 祖父节点
        Node<K, V> grand = red(parent.parent);
        if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】
            black(parent);
            black(uncle);
            // 把祖父节点当做是新添加的节点
            afterPut(grand);
            return;
        }

        // 叔父节点不是红色
        if (parent.isLeftChild()) { // L
            if (node.isLeftChild()) { // LL
                black(parent);
            } else { // LR
                black(node);
                rotateLeft(parent);
            }
            rotateRight(grand);
        } else { // R
            if (node.isLeftChild()) { // RL
                black(node);
                rotateRight(parent);
            } else { // RR
                black(parent);
            }
            rotateLeft(grand);
        }
    }

    private void rotateLeft(Node<K, V> grand) {
        Node<K, V> parent = grand.right;
        Node<K, V> child = parent.left;
        grand.right = child;
        parent.left = grand;
        afterRotate(grand, parent, child);
    }

    private void rotateRight(Node<K, V> grand) {
        Node<K, V> parent = grand.left;
        Node<K, V> child = parent.right;
        grand.left = child;
        parent.right = grand;
        afterRotate(grand, parent, child);
    }

    private void afterRotate(Node<K, V> grand, Node<K, V> parent, Node<K, V> child) {
        // 让parent称为子树的根节点
        parent.parent = grand.parent;
        if (grand.isLeftChild()) {
            grand.parent.left = parent;
        } else if (grand.isRightChild()) {
            grand.parent.right = parent;
        } else { // grand是root节点
            root = parent;
        }

        // 更新child的parent
        if (child != null) {
            child.parent = grand;
        }

        // 更新grand的parent
        grand.parent = parent;
    }

    private Node<K, V> color(Node<K, V> node, boolean color) {
        if (node == null) return node;
        node.color = color;
        return node;
    }

    private Node<K, V> red(Node<K, V> node) {
        return color(node, RED);
    }

    private Node<K, V> black(Node<K, V> node) {
        return color(node, BLACK);
    }

    private boolean colorOf(Node<K, V> node) {
        return node == null ? BLACK : node.color;
    }

    private boolean isBlack(Node<K, V> node) {
        return colorOf(node) == BLACK;
    }

    private boolean isRed(Node<K, V> node) {
        return colorOf(node) == RED;
    }

    private int compare(K e1, K e2) {
        if (comparator != null) {
            return comparator.compare(e1, e2);
        }
        return ((Comparable<K>) e1).compareTo(e2);
    }

    private void keyNotNullCheck(K key) {
        if (key == null) {
            throw new IllegalArgumentException("key must not be null");
        }
    }

    private static class Node<K, V> {
        K key;
        V value;
        boolean color = RED;
        Node<K, V> left;
        Node<K, V> right;
        Node<K, V> parent;

        public Node(K key, V value, Node<K, V> parent) {
            this.key = key;
            this.value = value;
            this.parent = parent;
        }

        public boolean isLeaf() {
            return left == null && right == null;
        }

        public boolean hasTwoChildren() {
            return left != null && right != null;
        }

        public boolean isLeftChild() {
            return parent != null && this == parent.left;
        }

        public boolean isRightChild() {
            return parent != null && this == parent.right;
        }

        public Node<K, V> sibling() {
            if (isLeftChild()) {
                return parent.right;
            }

            if (isRightChild()) {
                return parent.left;
            }

            return null;
        }
    }
}
```
## TreeMap实现TreeSet
```java
public class TreeSet<E> implements Set<E> {

    // 只需要map对于key的去重
    Map<E, Object> map = new TreeMap<>();

    @Override
    public int size() {
        return map.size();
    }

    @Override
    public boolean isEmpty() {
        return map.isEmpty();
    }

    @Override
    public void clear() {
        map.clear();
    }

    @Override
    public boolean contains(E element) {
        return map.containsKey(element);
    }

    @Override
    public void add(E element) {
        map.put(element, null);
    }

    @Override
    public void remove(E element) {
        map.remove(element);
    }

    @Override
    public void traversal(Visitor<E> visitor) {
        map.traversal(new Map.Visitor<E, Object>() {
            @Override
            public boolean visit(E key, Object value) {
                return visitor.visit(key);
            }
        });
    }
}
```
## Java官方TreeMap、TreeSet
`java.util.TreeMap`和`java.util.TreeSet`
# 13. 哈希表
## 介绍
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683444142102-1c549ec1-4d2a-4eff-885e-97fe01e50c6f.png#averageHue=%23f5f5f5&clientId=ubc064e04-7ad6-4&from=paste&height=428&id=ue392f18d&originHeight=428&originWidth=751&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=105047&status=done&style=none&taskId=ufb5cee3d-4b92-48eb-9b64-05b318b7444&title=&width=751)<br />时间换空间、散列函数<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683445497797-09eab10a-c176-47f5-b003-8057db25bb77.png#averageHue=%23f0eeee&clientId=ubc064e04-7ad6-4&from=paste&height=405&id=ub50e7e02&originHeight=405&originWidth=830&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=138660&status=done&style=none&taskId=ua6d4ac10-0119-4620-a917-ed1be6198f5&title=&width=830)
## 哈希冲突
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683445862803-325a079c-0333-4f8d-a349-94b1738ec0fa.png#averageHue=%23f2f1f0&clientId=ubc064e04-7ad6-4&from=paste&height=413&id=u0a758a44&originHeight=413&originWidth=827&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=111415&status=done&style=none&taskId=uae0f604b-15f3-4aa6-aea1-6a2b1357993&title=&width=827)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683446935082-d50b5474-6abf-4079-a2e7-e1590fdebc10.png#averageHue=%23edecec&clientId=ubc064e04-7ad6-4&from=paste&height=467&id=u4c574adc&originHeight=467&originWidth=800&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=165308&status=done&style=none&taskId=ubed99fd0-ad44-4b8e-ac2c-707dec3b3b3&title=&width=800)
## 哈希函数设计
![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683447424843-8cda9d5f-b2a7-4c27-90d1-0405564ddb74.png#averageHue=%23f5f4f3&clientId=ubc064e04-7ad6-4&from=paste&height=385&id=u807affaa&originHeight=385&originWidth=843&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=147035&status=done&style=none&taskId=u3a0df177-059c-4e2f-85c9-dad8e01ae7f&title=&width=843)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683448013365-79e19b80-c77c-45a5-aef1-97251a946855.png#averageHue=%23f2f2f2&clientId=ubc064e04-7ad6-4&from=paste&height=454&id=u271b79f4&originHeight=454&originWidth=683&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=130819&status=done&style=none&taskId=u744f873c-7360-4aa6-89fc-d070f66a548&title=&width=683)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683448142310-7b7ef6b8-e19e-4d30-ab85-acc353f66c9d.png#averageHue=%23f2f1f1&clientId=ubc064e04-7ad6-4&from=paste&height=447&id=ud038506e&originHeight=447&originWidth=896&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=160082&status=done&style=none&taskId=u29aed8c3-62ad-4863-b2b8-5ed3c74af32&title=&width=896)<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683448537682-65b70780-ec3a-42aa-976b-f1abb4a80393.png#averageHue=%23f3f3f3&clientId=ubc064e04-7ad6-4&from=paste&height=292&id=u4f311c8f&originHeight=292&originWidth=861&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=101283&status=done&style=none&taskId=u83c217bd-ae88-4b29-b8a4-cdf09e01388&title=&width=861)
## 自定义对象
自定义对象默认实现Object类的hashCode()方法，哈希值根据内存地址计算。<br />重写 equals() 时必须重写 hashCode() 方法
> - 如果两个对象的hashCode 值相等，那这两个对象不一定相等（哈希碰撞）。
> - 如果两个对象的hashCode 值相等并且equals()方法也返回 true，我们才认为这两个对象相等。
> - 如果两个对象的hashCode 值不相等，我们就可以直接认为这两个对象不相等。

![image.png](https://cdn.nlark.com/yuque/0/2023/png/12496339/1683548945807-6a2def4a-2537-4505-8021-73d7afdcb06d.png#averageHue=%23ebebeb&clientId=u3fd13a31-6b56-4&from=paste&height=118&id=u634defb8&originHeight=130&originWidth=529&originalType=binary&ratio=1.100000023841858&rotation=0&showTitle=false&size=48129&status=done&style=none&taskId=uf43129c2-058e-437a-a340-eb5155fbb62&title=&width=480.9090804856673)
```java
public class Person {
    private int age;
    private float height;
    private String name;

    public Person(int age, float height, String name) {
        this.age = age;
        this.height = height;
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;

        // o不是Person对象，两种写法
//        if (o == null || getClass() != o.getClass()) return false;
        if (o == null || !(o instanceof Person)) return false;

        Person person = (Person) o;
        return age == person.age
                && Float.compare(person.height, height) == 0
                && person.name == null ? name == null : name.equals(person.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(age, height, name);
    }
}
```
下面两个的区别是：`instanceof`判断o是Person的子类也满足，但`getClass()`不行
```java
if (o == null || getClass() != o.getClass()) return false;

if (o == null || !(o instanceof Person)) return false; 
```
## 具体实现
采取将红黑树的根节点放在数组中的策略
