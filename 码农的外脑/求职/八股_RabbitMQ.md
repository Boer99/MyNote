
# 整体架构

[✅rabbitMQ的整体架构是怎么样的？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/qh56y0u8fs2gom42)


# RabbitMQ是怎么做消息分发的？

  
rabbitMQ 一共有 6 种工作模式（消息分发方式）分别是
- 简单模式、
- 工作队列模式、
- 发布订阅模式、
- 路由模式、
- 主题模式
- RPC 模式。  
  
1）简单模式

最基本的工作模式，也是最简单的消息传递模式。在简单模式中，一个生产者将消息发送到一个队列中，一个消费者从队列中获取并处理消息。这种模式适用于单个生产者和单个消费者的简单场景，消息的处理是同步的。  

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1690624284380-66eada88-4d89-4ed9-93cd-627e3f93f56e.png?x-oss-process=image%2Fformat%2Cwebp)

2）工作队列模式

用于实现**一个任务在多个消费者之间**的并发处理

- 一个生产者将消息发送到一个队列中，多个消费者从队列中获取并处理消息。
- 每个消息只能被一个消费者处理。
- 默认情况下，RabbitMQ 的会将消息==依次轮询==投递给绑定在队列上的每一个消费者，可能出现消息堆积
- 通过设置 prefetch 来控制消费者预取的消息数量，处理完一条再处理下一条，实现==能者多劳==

这种模式适用于多个消费者并发处理消息的情况，==提高了系统的处理能力和吞吐量==

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1690624355141-ff0dc06e-2a75-4962-9c5c-35ba680eeaea.png?x-oss-process=image%2Fformat%2Cwebp)


3）发布/订阅模式

用于实现**一条消息被多个消费者同时接收和处理**
- 一个生产者将消息发送到交换器（Exchange）中，交换器将消息广播到所有绑定的队列，
- 每个队列对应一个消费者。

> Fanout Exchange

这种模式适用于消息需要被多个消费者同时接收和处理的广播场景，如日志订阅和事件通知等。  

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1691761653923-73c27264-2080-4a26-a3c8-513971f6b941.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1171%2Climit_0)

  
  
4）路由模式

实现**根据消息的路由键（Routing Key）将消息路由到不同的队列中**。
- 一个生产者将消息发送到交换器中，并指定消息的路由键，
- 交换器根据路由键将消息路由到与之匹配的队列中。

> Direct Exchange

这种模式适用于根据不同的条件将消息发送到不同的队列中，以实现消息的==筛选和分发==。  

![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1690624635994-00378b54-2577-4dc5-b1de-f634f4a0a0fd.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1171%2Climit_0)

  
  
  
5）主题模式

一种**更灵活的消息路由模式**，它使用**通配符匹配路由键**，将消息路由到多个队列中。
- 一个生产者将消息发送到交换器中，并指定主题（Topic）作为路由键，
- 交换器根据通配符匹配将消息路由到与之匹配的队列中。

这种模式适用于消息的复杂路由需求，可以实现==高度灵活的消息筛选和分发==。  

> Topic Exchange


![image.png](https://cdn.nlark.com/yuque/0/2023/png/5378072/1690624641506-e406d7f9-3fba-43b5-ad66-10e23f05a8ae.png?x-oss-process=image%2Fformat%2Cwebp%2Fresize%2Cw_1171%2Climit_0)

  
  
6）RPC 模式

是一种用于实现分布式系统中远程调用的工作模式。指的是通过 rabbitMQ 来实现一种 RPC 的能力。  
  

这几种模式，根据不同的场景可以用不同的模式，每种模式的发送方及接收方的代码都不太一样，有的简单，有的复杂， 具体实现可以参考：[https://www.rabbitmq.com/getstarted.html](https://www.rabbitmq.com/getstarted.html)


# 如何保障消息一定能发送到 RabbitMQ？

[✅如何保障消息一定能发送到RabbitMQ](https://www.yuque.com/hollis666/krcpbs/inmrfqk0qyvsdgg3)

**Publisher Confirm**：一种机制，用于确保消息已经被 Exchange 成功接收和处理。
- 一旦消息成功到达 Exchange 并被处理，RabbitMQ 会向消息生产者发送确认信号（ACK）。
- 如果由于某种原因（例如，Exchange 不存在或路由键不匹配）消息无法被处理，RabbitMQ 会向消息生产者发送否认信号（NACK）

**Publisher Returns**：于处理在消息无法路由到任何队列时的情况。
- 当 RabbitMQ 在无法路由消息时将消息返回给消息生产者，
- 但是如果能正确路由，则不会返回消息


# RabbitMQ 如何保证消息不丢？ #面过

[✅RabbitMQ如何保证消息不丢 (yuque.com)](https://www.yuque.com/hollis666/krcpbs/ku3fxiie005axgrz)

1）持久化机制

- 队列、交换机、绑定关系的持久化
- 消息持久化

2）消费者确认机制

- 消费者处理消息成功后可以向 MQ 发送 ack 回执，MQ 收到 ack 回执后才会删除该消息，这样才能确保消息不会丢失。
- 如果消费者在处理消息中出现了异常，那么就会返回 nack 回执，MQ 收到回执之后就会重新投递一次消息
- 如果消费者一直都没有返回 ACK/NACK 的话，那么他也会在尝试重新投递。

如果想要做到100%不丢失，就需要引入本地消息表，来通过轮询的方式来进行消息重投。 #TODO


# 如何防止消息重复消费？ #面过

1）消息消费的**确认机制**

消费者在消息消费成功后，会发送一个确认消息给消息队列，==消息队列接收到之后，就会将该消息从消息队列中删除==，下次也就不会再投递了。

2）但是如果存在**网络延迟**的问题，导致确认消息没有发送到消息队列，导致消息重投了，是有可能

消费者端自己也需要做好幂等控制来防止消息被重复消费。==“一锁、二判、三更新”==

也就是说我们在发送消息是需要生成一个==唯一的标识==并且把它放到消息体中，根据这个标识就可以判断两次消息是不是同一条。这样我们在消费者端，接收到消息以后，只需要解析出消息体中的这个唯一标识，就可以通过'一锁、二判、三更新'的方式来判断是否消费成功过了。


