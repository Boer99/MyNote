# 方案类

## Redis 挂了怎么办？ #元象24 #面过

[✅Redis 如果挂了，你怎么办？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/ni9yghphzz5utfhp)

**限流&降级**：
- 如果场景严重依赖 Redis，就要做好降级方案
	- 如在 Redis 中做库存预扣减，可以直接调用数据库
- 用 Redis 扛并发，限流
	- 数据库库存预扣减，严重影响性能

**备份**：在主实例挂了之后，我们就可以快速的切换到备份实例上面来

> 背后就是一种冗余的思想。备份甚至可以是不同架构的备份，比如备份到 Mangodb 中

**本地缓存**：也是一种降级，当然本地缓存存在数据不一致的问题，就看能不能接受

对于降级方案，可以配置一个开关，在 Redis 挂了以后开启限流（大厂中叫预案）

## 缓存和数据库一致性问题

### 什么情况下会出现数据库和缓存不一致的问题？

==出现了缓存和数据的双写==

**非并发**：缓存的操作和数据库的操作，一个成功一个失败

**写并发**：先写数据库再写缓存，或者先写缓存再写数据库

**读写并发**：假如一个读线程，在读缓存的时候没查到值，他就会去数据库中查询，但是如果自查询到结果之后，更新缓存之前，数据库被更新了，但是这个读线程是完全不知道的，那么就导致最终缓存会被重新用一个”旧值”覆盖掉

> 读写并发的概率较低，因为一般一个读操作是很快的，数据库+缓存的读操作基本在十几毫秒左右就可以完成了。而在这期间，刚好另一个线程执行了一个比较耗时的写操作的概率确实比较低。

而在这期间，刚好另一个线程执行了一个比较耗时的写操作的概率确实比较低。

[✅什么情况下会出现数据库和缓存不一致的问题？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/xr0h8h)


### 怎么保证缓存和数据库的一致性？ #美团24

[✅如何解决Redis和数据库的一致性问题？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/tmcgo0#fFIts)

典型回答：
1. 采用 Cache Aside Pattern（旁路缓存模式）
2. 先更新数据库，再删除缓存
3. 延迟双删：先删除缓存，再更新数据库，再删除一次缓存

####  （一）删除缓存 而不是 更新缓存?

更新缓存的动作，相比于直接删除缓存，比较的复杂（更新时间越长越容易引发并发问题）

> 我们放到缓存中的数据，很多时候可能不只是简单的一个字符串类型的值，他还可能是一个大的 JSON 串，一个 map 类型等等。
> 
> 那就需要从缓存中查出数据，反序列化，修改字段，再序列化，再更新到缓存中

在"写写并发"的场景中，如果同时更新缓存和数据库，那么很容易会出现因为并发的问题导致数据不一致的情况

- 先写数据库，缓存可能是脏的
- 先写缓存，数据库可能是脏的

在"写写并发"的场景中，缓存中的数据都是要被清除的，所以就不会出现数据不一致的问题。

#### （二）先写数据库还是先删缓存？

在“读写并发”场景下，删除缓存依旧会导致数据不一致性


| 写线程   | 读线程   |
| ----- | ----- |
| 删除缓存  |       |
|       | 缓存未命中 |
|       | 查询数据库 |
|       | 写入缓存  |
| 更新数据库 |       |


| 读线程   | 写线程   |
| ----- | ----- |
| 缓存未命中 |       |
| 查询数据库 |       |
|       | 更新数据库 |
|       | 删除缓存  |
| 写入缓存  |       |

先删缓存更容易导致数据不一致，因为==缓存的速度高于数据库很多==

> 先删缓存，更新数据库操作较慢，更新完之前，可能会有读线程重建缓存，缓存里就是脏数据

此外，删缓存和写数据库不是原子操作，==后删缓存失败了，也会导致不一致==

#### （三）延迟双删

[✅为什么需要延迟双删，两次删除的原因是什么？ (yuque.com)](https://www.yuque.com/hollis666/krcpbs/uswtlzlot2lcvy10)

为了避免因为先删除缓存而导致的”读写并发问题“被放大的情况，所以引入了第二次缓存删除。


### 扩展思路

#### 只读缓存


#### 消息队列补偿

删除失败的缓存，作为消息打入 mq，mq 消费者进行监听，再次进行重试刷缓存

#### canal

监听数据库的变化，做一个公共服务，专门来对接缓存刷新。优点业务解耦，业务太多冗余代码复杂度。




## 如何做平滑的数据迁移? #面过 




## 如何解决接口幂等的问题？  #面过

https://www.yuque.com/hollis666/krcpbs/gz2qwl#QEycl

1. 一锁：先加锁。分布式锁或者悲观锁都可以，但一定要是==互斥锁！==
2. 二判：进行幂等性判断。可以基于状态机、流水表、唯一性索引等等进行重复操作的判断。
3. 三更新：进行数据的更新，将数据进行持久化。

第一步加锁、和第二步判断的时候，通常需要和上游约定一个唯一 ID 作为幂等号。然后通过==对幂等号加锁，再通过幂等号进行幂等判断==即可。

> 第一步加锁为了解决高并发场景下的幂等问题，如果没有高并发， 不需要第一步了，就直接查询，更新，在更新的时候做乐观锁控制就行


## 为什么不建议用数据库唯一性约束做幂等控制？

https://www.yuque.com/hollis666/krcpbs/prnect4g81wg2law


## 评论数据库怎么设计？

牛客、b站的评论

[评论设计实现，完全模范bilibili实现评论功能，表的设计、sql如何查找，以及前端的一些设计_用户评论表怎么设计?-CSDN博客](https://blog.csdn.net/to_study/article/details/107578783)


# 通用类

## 为什么 web 场景中常用 json 序列化？ #面过 


## Controller 层和 Service 层可以交换吗？

在传统的分层架构中，Controller 层和 Service 层有着明确的角色分工，它们之间不建议直接交换或互换。每个层次都有其特定的责任和功能，保持这种分离有助于提高代码的可维护性、可测试性和可扩展性。

Controller 层

- **职责**：处理 HTTP 请求，接收来自客户端的数据，并将请求映射到相应的业务逻辑（Service 层）。它负责与视图层交互，返回响应给客户端。
- **特点**：不应该包含复杂的业务逻辑

### Service 层

- **职责**：实现业务逻辑。它是应用程序的核心部分，处理所有的业务规则和服务操作。
- **特点**：
    - 包含主要的业务逻辑。
    - 可能会与其他服务层组件交互以完成复杂任务（和基础能力层交互，如 Dao，消息队列，Redis 等）
    - 划分原子层和复合层

### 为什么不能交换？

1. **职责混淆**：如果把 Controller 和 Service 的职责混淆在一起，会导致代码难以理解和维护。例如，将业务逻辑放在 Controller 中会使 Controller 变得臃肿且不易测试；而将请求处理逻辑放入 Service 层则可能导致违反单一职责原则，使 Service 层变得复杂。
    
2. **耦合度增加**：两者之间的边界模糊后，会增加系统的耦合度，使得修改一个模块时可能需要同时调整另一个模块，增加了开发成本。
    
3. **复用性降低**：清晰地划分职责可以确保各个层的功能模块具有较高的独立性和复用性。比如，多个不同的 Controller 可以共享同一个 Service，反之亦然。
    
4. **安全性问题**：Controller 是与外界直接接触的部分，任何安全检查和权限验证都应该在这里进行。如果这些逻辑被移到了 Service 层，可能会导致潜在的安全风险。
    
5. **测试困难**：良好的分层结构使得单元测试更容易编写和执行。如果各层的功能混杂不清，则很难对单独一层进行有效的隔离测试。

