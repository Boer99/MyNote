# 方法总结

双指针
- 快慢指针
- 双向指针


# 数组

## 二分查找

> 给定一个 n 个元素**有序的**（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在**返回下标**，否则返回 -1。
> 
> 1. 你可以假设 `nums` 中的所有元素是不重复的。
> 2. `n` 将在 `[1, 10000]`之间。
> 3. `nums` 的每个元素都将在 `[-9999, 9999]`之间。
>    
>  https://leetcode.cn/problems/binary-search

**二分的前提条件：** 有序、无重复

```java
// 双向指针
public int search(int[] nums, int tg) {
	int len = nums.length;
	for (int l = 0, r = len - 1; l <= r; ){
		int mid = (l + r) / 2;
		if (nums[mid] == tg) {
			return mid;
		}
		if (nums[mid] > tg) {
			r = mid - 1;
		} else {
			l = mid + 1;
		}
	}      
	return -1;
}
```

> - 时间：`O(log n)`
> - 空间：`O(1)`


## 移除元素

> 给你一个数组 nums 和一个值 val，你需要 **原地** 移除所有数值等于 val 的元素，并**返回移除后数组的新长度**。
> - 不要使用额外的数组空间，你必须仅使用 **O(1) 额外空间**并原地修改输入数组。
> - 元素的顺序可以改变。你**不需要考虑数组中超出新长度后面的元素**。
> 
> 说明：
> - `0 <= nums.length <= 100` (包括空数组)
> - `0 <= nums[i] <= 50`
> - `0 <= val <= 100`
> 
> **示例 2：**
> 输入：`nums = [0,1,2,2,3,0,4,2]`, `val = 2`
> 输出：5, `nums = [0,1,3,0,4]`
> 解释：函数应该返回新的长度 `5`, 并且 nums 中的前五个元素
> `[0,1,3,0,4]`。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
> 
> [27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/)

**特例：**`1,1,1...,1`  (一个数组里全是要删除的)

```java
public class Solution {
    public static void main(String[] args) {
        // 随机生成nums1
        int[] nums1 = new int[1000000];
        int max = 50, min = 0;
        for (int i = 0; i < nums1.length; i++) {
            // 生成随机整数，范围在[minValue, maxValue]
            nums1[i] = new Random().nextInt((max - min + 1)) + min;
        }
        for (int i : nums1) {
            System.out.print(i + " ");
        }
        System.out.println();
        // 硬拷贝nums1给nums2
        int[] nums2 = Arrays.copyOf(nums1, nums1.length);

        int val = 10;

        TestTimeConsumingUtils t1 = new TestTimeConsumingUtils();
        System.out.println("快慢双指针结果：" + removeElement(nums1, val));
        t1.printTime("快慢双指针");

        TestTimeConsumingUtils t2 = new TestTimeConsumingUtils();
        System.out.println("相向双指针结果：" + removeElement2(nums2, val));
        t2.printTime("相向双指针");
    }

    /**
     * 快慢双指针
     */
    public static int removeElement(int[] nums, int val) {
        int slowIndex = 0;
        for (int fastIndex = 0; fastIndex < nums.length; fastIndex++) {
            if (nums[fastIndex] != val) {
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }

    /**
     * 相向双指针
     */
    public static int removeElement2(int[] nums, int val) {
        int len = nums.length;
        if (len == 0 || (len == 1 && nums[0] == val)) return 0;
        int l = 0;
        for (int r = len - 1; l <= r; ) {
            if (nums[l] != val) {
                l++;
                continue;
            }
            while (nums[r] == val && r > 0) {
                r--;
            }
            nums[l] = nums[r--];
        }
        return l;
    }
}

/**
 * 测试代码执行时间
 */
class TestTimeConsumingUtils {
    // 当前时间
    private long thisCurrentTimeMillis = System.currentTimeMillis();

    /**
     * @param desc 输入描述信息
     */
    public void printTime(String desc) {
        long result = System.currentTimeMillis() - thisCurrentTimeMillis;
        System.err.println(desc + "耗时：" + result);
    }
}
```

> 快慢指针
> - 时间：`O(n)`
> - 空间：`O(1)`
> 
> 双向指针
> - 时间：`O(n)`
> - 空间：`O(1)`


## 有序数组的平方

> 给你一个按 **非递减顺序** 排序的整数数组 nums，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。
> 
> 示例：
> - 输入：`nums = [-7,-3,2,3,11]`
> - 输出：`[4,9,9,49,121]`
> 
> 说明：
> - `1 <= nums.length <= 10^4`
> - `-10^4 <= nums[i] <= 10^4`
> 
> [977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/)

有负数，如果都是正数直接平方就好了

一直纠结O(1)的复杂度没做出来

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{-4, -1, 0, 3, 10};
        for (int i : sortedSquares(nums)) {
            System.out.print(i + " ");
        }
    }

    /**
     * 双向指针
     */
    public static int[] sortedSquares(int[] nums) {
        int len = nums.length;
        int[] res = new int[nums.length];
        int i = len - 1; // 结果数组索引
        for (int l = 0, r = len - 1; l <= r; ) {
            if (Math.pow(nums[l], 2) > Math.pow(nums[r], 2)) {
                res[i--] = (int) Math.pow(nums[l++], 2);
            } else {
                res[i--] = (int) Math.pow(nums[r--], 2);
            }
        }
        return res;
    }
}
```

>  双向指针
> - 时间：`O(n)`
> - 空间：`O(n)`


## 长度最小的子数组

> 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其**和 大于等于 s 的长度最小的 连续** 子数组，并**返回其长度**。如果不存在符合条件的子数组，返回 0。
> 
> 示例：
> - 输入：`target = 7`, `nums = [2,3,1,2,4,3]`
> - 输出：2
> - 解释：子数组 `[4,3]` 是该条件下的长度最小的子数组。
> 
> 说明：
> - `1 <= target <= 10^9`
> - `1 <= nums.length <= 10^5`
> - `1 <= nums[i] <= 10^5`

滑动窗口（双指针）

实现滑动窗口，主要确定如下三点：
1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的结束位置？

```java
public class Solution {
    public static void main(String[] args) {
        int[] nums = new int[]{1, 2, 3, 4, 5};
        int tar = 11;
        System.out.println(minSubArrayLen(tar, nums));
    }

    public static int minSubArrayLen(int target, int[] nums) {
        int len = nums.length;
        int res = len + 1;
        int sum = 0;
        for (int l = 0, r = 0; r <= len - 1; r++) {
            sum += nums[r];
            while (sum >= target) {
                res = Math.min(res, r - l + 1);
                sum -= nums[l++];
            }
        }
        return res == len + 1 ? 0 : res;
    }
}
```

> - 时间：`O(n)`
> - 空间：`O(1)`

 
## 螺旋矩阵

> 给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按**顺时针顺序螺旋排列**的正方形矩阵。
> 
> 示例：
> - 输入：`n = 3`
> - 输出：`[[1,2,3],[8,9,4],[7,6,5]]`
> 
> 说明：
>  - `1 <= n <= 20`
> 
> [59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

模拟过程，每次循环画完一圈

坚持**循环不变量原则**，每一圈四条边，每条边保持左闭右开

---
By Boer

```java
class Solution {  
    public static void main(String[] args) {  
        generateMatrix(3);  
    }  
  
    public static int[][] generateMatrix(int n) {  
        int[][] res = new int[n][n];  
        // n为单数需要补中心点
        res[(n - 1) / 2][(n - 1) / 2] = n * n;  
        int y = 0; // 起始位置  
        int x = 1; // 1~n^2  
        for (int i = y, j = y; n >= 0; n--, y++, i = y, j = y) {  
            while (j < n - 1) {  
                res[i][j++] = x++;  
            }  
            while (i < n - 1) {  
                res[i++][j] = x++;  
            }  
            while (j > y) {  
                res[i][j--] = x++;  
            }  
            while (i > y) {  
                res[i--][j] = x++;  
            }  
        }  
        return res;  
    }  
}
```

--- 
参考代码

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int loop = 0;  // 控制循环次数
        int[][] res = new int[n][n];
        int start = 0;  // 每次循环的开始点(start, start)
        int count = 1;  // 定义填充数字
        int i, j;

        while (loop++ < n / 2) { // 判断边界后，loop从1开始
            // 模拟上侧从左到右
            for (j = start; j < n - loop; j++) {
                res[start][j] = count++;
            }

            // 模拟右侧从上到下
            for (i = start; i < n - loop; i++) {
                res[i][j] = count++;
            }

            // 模拟下侧从右到左
            for (; j >= loop; j--) {
                res[i][j] = count++;
            }

            // 模拟左侧从下到上
            for (; i >= loop; i--) {
                res[i][j] = count++;
            }
            start++;
        }

        if (n % 2 == 1) {
            res[start][start] = count;
        }

        return res;
    }
}
```

> 本题模拟过程，时空复杂度不必在意 	
> - 时间：`O(n^2)`
> - 空间：`O(1)`

# 链表

## 移除链表元素

> 给你一个链表的头节点 `head` 和一个整数 `val` ，请你**删除**链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。
> 
> 示例：
> - 输入：`head = [1,2,6,3,4,5,6], val = 6`
> - 输出：`[1,2,3,4,5]`
>  
> 说明：
> - 列表中的节点数目在范围 `[0, 10^4]` 内 （包含空链表）
> - `1 <= Node.val <= 50`
> - `0 <= val <= 50`
>    
> [203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

特例：`[val,...,val]` 一个及以上的val组成的链表

**虚拟头结点**
- ==统一==头结点和其他节点的删除操作
- 初始虚拟头结点需要存档一份，用于后续返回（特例情况下原先的头结点指向的是旧链表）

```java
class Solution {  
    public ListNode removeElements(ListNode head, int val) {  
        ListNode dummy = new ListNode(-1, head); // 前置指针  
        ListNode pre = dummy; // 前置指针存档  
        while (pre.next != null) {  
            if (pre.next.val == val) {  
                pre.next = pre.next.next;  
            } else {  
                pre = pre.next;  
            }  
        }  
        return dummy.next;  
    }  
}
```

> - 时间：`O(n)`
> - 空间：`O(1)`

## 设计链表

> 你可以选择使用单链表或者双链表，设计并实现自己的链表。 
> 单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。
> 如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。
> 
> 实现 `MyLinkedList` 类：
> - `MyLinkedList()` 初始化 `MyLinkedList` 对象。
> - `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 
> - `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
>  - `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
>  - `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
>  - `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。
> 
> 示例：
>  
> 说明：
>  
> [707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/)


```java
```

## 反转链表

> 给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表
> 
> 示例：
> - 输入：`head = [1,2,3,4,5]`
> - 输出：`[5,4,3,2,1]`
>  
> 说明：
> - 链表中节点的数目范围是 `[0, 5000]`
> - `-5000 <= Node.val <= 5000`
>    
> [206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)


--- 
双指针 正向翻转

```java
class Solution {  
    public ListNode reverseList(ListNode head) {  
        ListNode pre = null;  
        ListNode temp = null;  
        while (head != null) {  
            temp = head.next;  
            head.next = pre;  
            pre = head;  
            head = temp;  
        }  
        return pre;  
    }  
}
```

> - 时间：`O(n)`
> - 空间：`O(1)`  

--- 
递归：正向翻转
- 需要两个指针实现
- 先翻转再递归调用

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }

    private ListNode reverse(ListNode prev, ListNode cur) {
	    // 终止条件
        if (cur == null) {
            return prev;
        }
        // 反转操作
        ListNode temp = null;
        temp = cur.next; // 先保存下一个节点
        cur.next = prev; 
        // 递归调用
        return reverse(cur, temp);
    }
}
```

> - 时间：`O(n)`
> - 空间：`O(n)` n层栈

--- 
递归：反向翻转
- 单指针即可实现。
- 先递归调用再翻转

```java
class Solution {
    public ListNode reverseList(ListNode head) {
	    // 终止条件
        if (head == null || head.next == null) return head; 
        // 递归调用，记录尾节点
        ListNode last = reverseList(head.next);
        // 反转操作
        head.next.next = head;
        head.next = null;
        // 每层递归都把尾节点返回
        return last;
    }
}
```

> - 时间：`O(n)`
> - 空间：`O(n)` n层栈